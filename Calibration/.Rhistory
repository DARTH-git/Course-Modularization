hr_S1   <- 3             	          # hazard ratio of death in sick vs healthy
hr_S2   <- 10            	          # hazard ratio of death in sicker vs healthy
r_HD    <- - log(1 - p_HD)          # rate of death in healthy
r_S1D   <- hr_S1 * r_HD  	          # rate of death in sick
r_S2D   <- hr_S2 * r_HD  	          # rate of death in sicker
p_S1D   <- 1 - exp(-r_S1D)          # probability to die in sick
p_S2D   <- 1 - exp(-r_S2D)          # probability to die in sicker
# Cost and utility inputs
c_H     <- 2000                     # cost of remaining one cycle in the healthy state
c_S1    <- 4000                     # cost of remaining one cycle in the sick state
c_S2    <- 15000                    # cost of remaining one cycle in the sicker state
c_trt   <- 12000                    # cost of treatment(per cycle)
c_D     <- 0                        # cost of being in the death state
u_H     <- 1                        # utility when healthy
u_S1    <- 0.75                     # utility when sick
u_S2    <- 0.5                      # utility when sicker
u_D     <- 0                        # utility when dead
u_trt   <- 0.95                     # utility when being treated
# Discounting factor
d_r <- 0.03                         # equal discount of costs and QALYs by 3%
v_dwc <- 1 / (1 + d_r) ^ (0:n_t)    # calculate discount weights for costs for each cycle based on discount rate d_r
v_dwe <- 1 / (1 + d_r) ^ (0:n_t)    # calculate discount weights for effectiveness for each cycle based on discount rate d_r
n_s
n_s_td
#### 04 Define and initialize matrices and vectors ####
#### 04.1 Cohort trace ####
### create the markov trace matrix M capturing the proportion of the cohort in each state at each cycle
m_M_no_trt <- m_M_trt <- matrix(NA,
nrow = n_t + 1, ncol = n_s_td, # Update!
dimnames = list(paste("cycle", 0:n_t, sep = " "), v_n_td)) # Update!
head(m_M_no_trt) # show first 6 rows of the matrix
# The cohort starts as healthy
m_M_no_trt[1, ] <- m_M_trt[1, ] <- c(1, rep(0, tunnel_size), 0, 0) # initialize first cycle of Markov trace accounting for the tunnels
a_P_no_trt <- array(0,                                          # Create 3-D array
dim = c(n_s_td, n_s_td, n_t),
dimnames = list(v_n_td, v_n_td, 0:(n_t-1))) # name dimensions of the transition probability array
n_t
a_P_no_trt
dim(a_P_no_trt)
### fill in the transition probability array
# From Healthy
a_P_no_trt["H", "H", ]            <- 1 - (p_HS1 + p_HD)
a_P_no_trt["H", Sick_tunnel[1], ] <- p_HS1
a_P_no_trt["H", "D", ]            <- p_HD
p_S1D
Sick_tunnel[tunnel_size]
for(i in 1:(tunnel_size - 1)){
a_P_no_trt[Sick_tunnel[i], "H", ]  <- p_S1H
a_P_no_trt[Sick_tunnel[i], Sick_tunnel[i + 1], ] <- 1 - (p_S1H + p_S1S2[i] + p_S1D)
a_P_no_trt[Sick_tunnel[i], "S2", ] <- p_S1S2[i]
a_P_no_trt[Sick_tunnel[i], "D", ]  <- p_S1D
}
a_P_no_trt[Sick_tunnel[tunnel_size], "H", ]  <- p_S1H
a_P_no_trt[Sick_tunnel[tunnel_size], Sick_tunnel[tunnel_size], ] <- 1 - (p_S1H + p_S1S2[tunnel_size] + p_S1D)
a_P_no_trt[Sick_tunnel[tunnel_size], "S2", ] <- p_S1S2[tunnel_size]
a_P_no_trt[Sick_tunnel[tunnel_size], "D", ] <- p_S1D
# From Sicker
a_P_no_trt["S2", "S2", ] <- 1 - p_S2D
a_P_no_trt["S2", "D", ]  <- p_S2D
# From Dead
a_P_no_trt["D", "D", ] <- 1
### Check if transition matrix is valid (i_e_, each row should add up to 1)
valid <- apply(a_P_no_trt, 3, function(x) sum(rowSums(x))==n_s_td)
if (!isTRUE(all.equal(as.numeric(sum(valid)), as.numeric(n_t)))) {
stop("This is not a valid transition Matrix")
}
### create transition probability matrix for treatment same as NO treatment
a_P_trt <- a_P_no_trt
#### 05 Run Markov model ####
for (t in 1:n_t){                                                  # loop through the number of cycles
m_M_no_trt[t + 1, ] <- t(m_M_no_trt[t, ]) %*% a_P_no_trt[ , , t]  # estimate the Markov trace for cycle the next cycle (t + 1)
m_M_trt[t + 1, ]    <- t(m_M_trt[t, ])    %*% a_P_trt[, , t]     # estimate the Markov trace for cycle the next cycle (t + 1)
} # close the loop
head(m_M_no_trt)  # show the first 6 lines of the matrix
### create aggregated traces
m_M_td_no_trt <- cbind(H = m_M_no_trt[, "H"],
S1 = rowSums(m_M_no_trt[, 2:(tunnel_size +1)]),
S2 = m_M_no_trt[, "S2"],
D = m_M_no_trt[, "D"])
head(m_M_td_no_trt)
m_M_td_trt    <- cbind(H = m_M_trt[, "H"],
S1 = rowSums(m_M_trt[, 2:(tunnel_size +1)]),
S2 = m_M_trt[, "S2"],
D = m_M_trt[, "D"])
head(m_M_td_trt)
matplot(m_M_td_no_trt, type = 'l',
ylab = "Probability of state occupancy",
xlab = "Cycle",
main = "Cohort Trace")                     # create a plot of the data
legend("topright", v_n, col = 1:n_s,lty = 1:n_s, bty = "n")  # add a legend to the graph
#### 06.2 Overall Survival (OS) ####
v_os_no_trt_tunnels <- 1 - m_M_no_trt[, "D"]       # calculate the overall survival (OS) probability for no treatment
v_os_no_trt_tunnels <- rowSums(m_M_no_trt[, 1:3])  # alternative way of calculating the OS probability
plot(age:max_age, v_os_no_trt_tunnels, type = 'l',
ylim = c(0, 1),
ylab = "Survival probability",
xlab = "Age",
main = "Overall Survival Age-dependent with tunnels")  # create a simple plot showing the OS
grid(nx = n_t, ny = 10, col = "lightgray", lty = "dotted", lwd = par("lwd"), equilogs = TRUE) # add grid
#### 06.2.1 Life Expectancy (LE) ####
v_le_tunnels <- sum(v_os_no_trt_tunnels)           # summing probablity of OS over time  (i_e_ life expectancy)
#### 06.3 Disease prevalence ####
v_prev_tunnels <- rowSums(m_M_td_no_trt[, c("S1", "S2")]) / v_os_no_trt_tunnels
plot(v_prev_tunnels,
ylim = c(0, 1),
ylab = "Prevalence",
xlab = "Cycle",
main = "Disease prevalence")
dev.off()
#### 06.4 ratio of sick(S1) vs sicker(S2) ####
v_ratio_S1S2_tunnels <- m_M_td_no_trt[, "S1"] / m_M_td_no_trt[, "S2"]
plot(0:n_t, v_ratio_S1S2_tunnels,
xlab = "Cycle",
ylab = "Ratio S1 vs S2",
main = "Ratio of sick and sicker",
col  = "black", type = "l")
#### 07 Compute Cost-Effectiveness Outcomes ####
### Vectors with costs and utilities by treatment
v_u_no_trt  <- c(u_H, u_S1, u_S2, u_D)
v_u_trt     <- c(u_H, u_trt, u_S2, u_D)
v_c_no_trt  <- c(c_H, c_S1, c_S2, c_D)
v_c_trt     <- c(c_H, c_S1 + c_trt, c_S2 + c_trt, c_D)
#### 07.1 Mean Costs and QALYs for Treatment and NO Treatment ####
### estimate mean QALys and costs
v_tu_no_trt <- m_M_td_no_trt  %*% v_u_no_trt
v_tu_trt    <- m_M_td_trt     %*% v_u_trt
v_tc_no_trt <- m_M_td_no_trt  %*% v_c_no_trt
v_tc_trt    <- m_M_td_trt     %*% v_c_trt
#### 07.2 Discounted Mean Costs and QALYs ####
### discount costs and QALYs
tu_d_no_trt <- t(v_tu_no_trt) %*% v_dwe
tu_d_trt    <- t(v_tu_trt)    %*% v_dwe
tc_d_no_trt <- t(v_tc_no_trt) %*% v_dwc
tc_d_trt    <- t(v_tc_trt)    %*% v_dwc
# Vector
v_tc_d      <- c(tc_d_no_trt, tc_d_trt)
v_tu_d      <- c(tu_d_no_trt, tu_d_trt)
# Dataframe with discounted costs and effectiveness
df_ce       <- data.frame(Strategy = v_names_str,
Cost     = v_tc_d,
Effect   = v_tu_d)
df_ce
#### 07.3 Compute ICERs of the Markov model ####
df_cea      <- calculate_icers(cost       = df_ce$Cost,
effect     = df_ce$Effect,
strategies = df_ce$Strategy)
df_cea
df_cea
plot(df_cea, effect_units = "Quality of Life", xlim=c(17,18))
################# Simple 3-state Markov model in R ####################################
################# with age dependency AND          ####################################
################# with time dependency             ####################################
# Developed by the Decision Analysis in R for Technologies in Health (DARTH) workgroup
# Fernando Alarid-Escudero, PhD (1)
# Eva A. Enns, MS, PhD (2)
# M.G. Myriam Hunink, MD, PhD (3,4)
# Hawre J. Jalal, MD, PhD (5)
# Eline M. Krijkamp, MSc (3)
# Petros Pechlivanoglou, PhD (6)
# In collaboration of:
# 1 Drug Policy Program, Center for Research and Teaching in Economics (CIDE) - CONACyT,
#   Aguascalientes, Mexico
# 2 University of Minnesota School of Public Health, Minneapolis, MN, USA
# 3 Erasmus MC, Rotterdam, The Netherlands
# 4 Harvard T.H. Chan School of Public Health, Boston, USA
# 5 University of Pittsburgh Graduate School of Public Health, Pittsburgh, PA, USA
# 6 The Hospital for Sick Children, Toronto and University of Toronto, Toronto ON, Canada
#####################################################################################
# Please cite our publications when using this code
# - Jalal H, Pechlivanoglou P, Krijkamp E, Alarid-Escudero F, Enns E, Hunink MG.
# An Overview of R in Health Decision Sciences. Med Decis Making. 2017; 37(3): 735-746.
# https://journals.sagepub.com/doi/abs/10.1177/0272989X16686559
# - Krijkamp EM, Alarid-Escudero F, Enns EA, Jalal HJ, Hunink MGM, Pechlivanoglou P.
# Microsimulation modeling for health decision sciences using R: A tutorial.
# Med Decis Making. 2018;38(3):400â€“22.
# https://journals.sagepub.com/doi/abs/10.1177/0272989X18754513
# - Krijkamp EM, Alarid-Escudero F, Enns E, Pechlivanoglou P, Hunink MM, Jalal H.
# A Multidimensional Array Representation of State-Transition Model Dynamics.
# BioRxiv 670612 2019.https://www.biorxiv.org/content/10.1101/670612v1
#####################################################################################
# Copyright 2017, THE HOSPITAL FOR SICK CHILDREN AND THE COLLABORATING INSTITUTIONS.
# All rights reserved in Canada, the United States and worldwide. Copyright,
# trademarks, trade names and any and all associated intellectual property are
# exclusively owned by THE HOSPITAL FOR Sick CHILDREN and the collaborating
# institutions. These materials may be used, reproduced, modified, distributed
# and adapted with proper attribution.
#####################################################################################
rm(list = ls())      # clear memory (removes all the variables from the workspace)
#### 01 Load packages ####
# no packages required
# library(dampack)
#### 02 Load Functions ####
# no functions required
#### 03 Input Model Parameters ####
## Strategy names
v_names_str <- c("Base Case")
## Number of strategies
n_str <- length(v_names_str)
## Markov model parameters
v_n  <- c("Healthy", "Sick", "Dead")    # state names
n_s  <- length(v_n)                     # number of states
n_t  <- 60                              # number of cycles
# Update!
###
# Tunnels
tunnel_size <- n_t
# Sick state
Sick_tunnel <- paste("Sick_", seq(1, tunnel_size), "Yr", sep = "")
# Create variables for time-dependent model
v_n_td  <- c("Healthy", Sick_tunnel, "Dead")   # state names
n_s_td  <- length(v_n_td)                      # number of states
###
p_HD <- seq(0.003, 0.01, length.out = n_t)  # probability to die when sick (age-dependent)
p_HS <- 0.05                    # probability to become sick when healthy
# Update!
###
# Weibull parameters
l <- 0.08
g <- 1.1
p_SD <- l*g*(1:tunnel_size)^{g-1}         # probability to die when sick (time-dependent)
###
# Costs and utilities
c_H  <- 400         # cost of remaining one cycle healthy
c_S  <- 100         # cost of remaining one cycle sick
c_D  <- 0           # cost of remaining one cycle dead
u_H  <- 0.8         # utility when healthy
u_S  <- 0.5         # utility when sick
u_D  <- 0           # utility when dead
d_c <- d_e <- 0.03  # discount rate per cycle, same for costs and effectiveness
v_dwc <- 1 / (1 + d_c) ^ (0:n_t) # calculate discount weights for costs for each cycle based on discount rate d_c
v_dwe <- 1 / (1 + d_e) ^ (0:n_t) # calculate discount weights for effectiveness for each cycle based on discount rate d_e
#### 04 Define and initialize matrices and vectors ####
#### 04.1 Cohort trace ####
# create the cohort trace
m_M <- matrix(NA,
nrow = n_t + 1 ,                # create Markov trace (n_t + 1 because R doesn't understand  Cycle 0)
ncol = n_s_td,                  # Update!
dimnames = list(0:n_t, v_n_td)) # Update!
# Update!
####
# The cohort starts as healthy
m_M[1, ] <- c(1, rep(0, tunnel_size), 0)      # initialize first cycle of Markov trace accounting for the tunnels
####
#### 04.2 Transition probability ARRAY ####
# create the transition probability array
a_P <- array(0,                                          # Create 3-D array
dim = c(n_s_td, n_s_td, n_t),               # Update!
dimnames = list(v_n_td, v_n_td, 0:(n_t-1))) # Update!
# fill in the transition probability array
### From Healthy
a_P["Healthy", "Healthy", ]  <- 1 - p_HD - p_HS
a_P["Healthy", "Sick_1Yr", ] <- p_HS
a_P["Healthy", "Dead", ]     <- p_HD
# Update!
###
### From Sick
for(i in 1:(tunnel_size - 1)){ # i <- 1
a_P[Sick_tunnel[i], Sick_tunnel[i + 1], ] <- 1 - p_SD[i]
a_P[Sick_tunnel[i], "Dead", ] <- p_SD[i]
}
a_P[Sick_tunnel[tunnel_size], Sick_tunnel[tunnel_size], ] <- 1 - p_SD[tunnel_size]
a_P[Sick_tunnel[tunnel_size], "Dead", ] <- p_SD[tunnel_size]
###
### From Dead
a_P["Dead", "Dead", ] <- 1
# Check if transition matrix is valid (i.e., each row should add up to 1)
valid <- apply(a_P, 3, function(x) sum(rowSums(x))==n_s_td)
if (!isTRUE(all.equal(as.numeric(sum(valid)), as.numeric(n_t)))) {
stop("This is not a valid transition Matrix")
}
####### PROCESS  ###########################################
# Run Markov model
for (t in 1:n_t) {                        # loop through the number of cycles
m_M[t + 1, ] <- m_M[t, ] %*% a_P[, , t] # estimate the Markov trace for cycle t + 1 using the t-th matrix from the probability array
}
head(m_M, n = 30)
# create aggregated trace
m_M_td <- cbind(Healthy = m_M[, "Healthy"],
Sick = rowSums(m_M[, 2:(tunnel_size +1)]),
Dead = m_M[, "Dead"])
head(m_M_td)
#### 06 Compute and Plot Epidemiological Outcomes ####
#### 06.1 Cohort trace #####
matplot(m_M_td, type = 'l',
ylab = "Probability of state occupancy",
xlab = "Cycle",
main = "Cohort Trace")              # create a plot of the data
legend("right", v_n, col = c("black", "red", "green"), lty = 1:3, bty = "n")  # add a legend to the graph
#### 06.2 Overall Survival (OS) #####
v_os <- 1 - m_M_td[, "Dead"]    # calculate the overall survival (OS) probability
v_os <- rowSums(m_M_td[, 1:2])  # alternative way of calculating the OS probability
plot(v_os, type = 'l',
ylim = c(0, 1),
ylab = "Survival probability",
xlab = "Cycle",
main = "Overall Survival")             # create a simple plot showing the OS
grid(nx = n_t, ny = 10, col = "lightgray", lty = "dotted", lwd = par("lwd"), equilogs = TRUE) # add grid
#### 06.2.1 Life Expectancy (LE) #####
v_le <- sum(v_os)                             # summing probablity of OS over time  (i.e. life expectancy)
#### 06.3 Disease prevalence #####
v_prev <- m_M_td[, "Sick"]/v_os
plot(v_prev,
ylim = c(0, 1),
ylab = "Prevalence",
xlab = "Cycle",
main = "Disease prevalence")
#### 07 Compute Cost-Effectiveness Outcomes ####
#### 07.1 Mean Costs and QALYs ####
# per cycle
v_tc <- m_M_td %*% c(c_H, c_S, c_D)  # calculate expected costs by multiplying m_M with the cost vector for the different health states
v_tu <- m_M_td %*% c(u_H, u_S, u_D)  # calculate expected QALYs by multiplying m_M with the utilities for the different health states
#### 07.2 Discounted Mean Costs and QALYs ####
v_tc_d <-  t(v_tc) %*% v_dwc   # Discount costs  by multiplying the cost vector with discount weights (v_dw)
v_te_d <-  t(v_tu) %*% v_dwe   # Discount QALYS  by multiplying the QALYs vector with discount weights (v_dw)
results <- data.frame("Total Discounted Cost" = v_tc_d,
"Life Expectancy" = v_le,
"Total Discounted QALYs" = v_te_d,
check.names = F)
results
v_prev <- m_M[, "Sick"]/v_os
rm(list = ls())      # clear memory (removes all the variables from the workspace)
# no packages required
# no functions required
# Strategy names
v_names_str <- c("Base Case")
# Number of strategies
n_str <- length(v_names_str)
# Markov model parameters
v_n  <- c("Healthy", "Sick", "Dead")    # state names
n_s  <- length(v_n)                     # number of states
n_t  <- 60                              # number of cycles
# Tunnels
tunnel_size <- n_t
# Sick state
Sick_tunnel <- paste("Sick_", seq(1, tunnel_size), "Yr", sep = "")
# Create variables for time-dependent model
v_n_td  <- c("Healthy", Sick_tunnel, "Dead")   # state names
n_s_td  <- length(v_n_td)                      # number of states
p_HD <- seq(0.003, 0.01, length.out = n_t)  # probability to die when sick (age-dependent)
p_HS <- 0.05                                # probability to become sick when healthy
p_SD <- 0.1                                 # probability to die when sick
# Weibull parameters
l <- 0.08
g <- 1.1
p_SD <- l*g*(1:tunnel_size)^{g-1}       # probability to die when sick (time-dependent)
# Costs and utilities
c_H  <- 400                             # cost of remaining one cycle healthy
c_S  <- 1000                            # cost of remaining one cycle sick
c_D  <- 0                               # cost of remaining one cycle dead
u_H  <- 0.8                             # utility when healthy
u_S  <- 0.5                             # utility when sick
u_D  <- 0                               # utility when dead
d_e <- d_c <- 0.03                      # equal discount of costs and QALYs by 3%
# calculate discount weights for costs for each cycle based on discount rate d_c
v_dwc <- 1 / (1 + d_e) ^ (0:n_t)
# calculate discount weights for effectiveness for each cycle based on discount rate d_e
v_dwe <- 1 / (1 + d_c) ^ (0:n_t)
m_M <- matrix(NA,
nrow = n_t + 1,  # create Markov trace (n_t + 1 because R doesn't understand
# Cycle 0)
ncol = n_s_td,
dimnames = list(0:n_t, v_n_td))
# The cohort starts as healthy
# initialize first cycle of Markov trace accounting for the tunnels
m_M[1, ] <- c(1, rep(0, tunnel_size), 0)
# create the transition probability array
a_P <- array(0,                                          # Create 3-D array
dim = c(n_s_td, n_s_td, n_t),
dimnames = list(v_n_td, v_n_td, 0:(n_t-1)))
# from Healthy
a_P["Healthy", "Healthy", ]  <- 1 - p_HD - p_HS
a_P["Healthy", "Sick_1Yr", ] <- p_HS
a_P["Healthy", "Dead", ]     <- p_HD
# from Sick
for(i in 1:(tunnel_size - 1)){
a_P[Sick_tunnel[i], Sick_tunnel[i + 1], ] <- 1 - p_SD[i]
a_P[Sick_tunnel[i], "Dead", ] <- p_SD[i]
}
a_P[Sick_tunnel[tunnel_size], Sick_tunnel[tunnel_size], ] <- 1 - p_SD[tunnel_size]
a_P[Sick_tunnel[tunnel_size], "Dead", ] <- p_SD[tunnel_size]
# from Dead
a_P["Dead", "Dead", ] <- 1
# Check if transition matrix is valid (i.e., each row should add up to 1)
valid <- apply(a_P, 3, function(x) sum(rowSums(x))==n_s_td)
if (!isTRUE(all.equal(as.numeric(sum(valid)), as.numeric(n_t)))) {
stop("This is not a valid transition Matrix")
}
for (t in 1:n_t) {                         # loop through the number of cycles
m_M[t + 1, ] <- m_M[t, ] %*% a_P[, , t]  # estimate the Markov trace for cycle t + 1
# using the t-th matrix from the
#probability array
}
head(m_M, n = 30)
m_M_td <- cbind(Healthy = m_M[, "Healthy"],
Sick = rowSums(m_M[, 2:(tunnel_size +1)]),
Dead = m_M[, "Dead"])
head(m_M_td)
# create a plot of the data
matplot(m_M, type = 'l',
ylab = "Probability of state occupancy",
xlab = "Cycle",
main = "Cohort Trace", lwd = 2)
# add a legend to the graph
legend("right", v_n, col = c("black", "red", "green"), lty = 1:3, bty = "n")
v_os <- 1 - m_M_td[, "Dead"]    # calculate the overall survival (OS) probability
v_os <- rowSums(m_M_td[, 1:2])  # alternative way of calculating the OS probability
# create a simple plot showing the OS
plot(v_os, type = 'l',
ylim = c(0, 1),
ylab = "Survival probability",
xlab = "Cycle",
main = "Overall Survival")
# add grid
grid(nx = n_t, ny = 10, col = "lightgray", lty = "dotted", lwd = par("lwd"), equilogs = TRUE)
v_le <- sum(v_os)           # summing probablity of OS over time  (i.e. life expectancy)
v_prev <- m_M[, "Sick"]/v_os
rm(list = ls())      # clear memory (removes all the variables from the workspace)
# no packages required
# no functions required
# Strategy names
v_names_str <- c("Base Case")
# Number of strategies
n_str <- length(v_names_str)
# Markov model parameters
v_n  <- c("Healthy", "Sick", "Dead")    # state names
n_s  <- length(v_n)                     # number of states
n_t  <- 60                              # number of cycles
# Tunnels
tunnel_size <- n_t
# Sick state
Sick_tunnel <- paste("Sick_", seq(1, tunnel_size), "Yr", sep = "")
# Create variables for time-dependent model
v_n_td  <- c("Healthy", Sick_tunnel, "Dead")   # state names
n_s_td  <- length(v_n_td)                      # number of states
p_HD <- seq(0.003, 0.01, length.out = n_t)  # probability to die when sick (age-dependent)
p_HS <- 0.05                                # probability to become sick when healthy
p_SD <- 0.1                                 # probability to die when sick
# Weibull parameters
l <- 0.08
g <- 1.1
p_SD <- l*g*(1:tunnel_size)^{g-1}       # probability to die when sick (time-dependent)
# Costs and utilities
c_H  <- 400                             # cost of remaining one cycle healthy
c_S  <- 1000                            # cost of remaining one cycle sick
c_D  <- 0                               # cost of remaining one cycle dead
u_H  <- 0.8                             # utility when healthy
u_S  <- 0.5                             # utility when sick
u_D  <- 0                               # utility when dead
d_e <- d_c <- 0.03                      # equal discount of costs and QALYs by 3%
# calculate discount weights for costs for each cycle based on discount rate d_c
v_dwc <- 1 / (1 + d_e) ^ (0:n_t)
# calculate discount weights for effectiveness for each cycle based on discount rate d_e
v_dwe <- 1 / (1 + d_c) ^ (0:n_t)
m_M <- matrix(NA,
nrow = n_t + 1,  # create Markov trace (n_t + 1 because R doesn't understand
# Cycle 0)
ncol = n_s_td,
dimnames = list(0:n_t, v_n_td))
# The cohort starts as healthy
# initialize first cycle of Markov trace accounting for the tunnels
m_M[1, ] <- c(1, rep(0, tunnel_size), 0)
# create the transition probability array
a_P <- array(0,                                          # Create 3-D array
dim = c(n_s_td, n_s_td, n_t),
dimnames = list(v_n_td, v_n_td, 0:(n_t-1)))
# from Healthy
a_P["Healthy", "Healthy", ]  <- 1 - p_HD - p_HS
a_P["Healthy", "Sick_1Yr", ] <- p_HS
a_P["Healthy", "Dead", ]     <- p_HD
# from Sick
for(i in 1:(tunnel_size - 1)){
a_P[Sick_tunnel[i], Sick_tunnel[i + 1], ] <- 1 - p_SD[i]
a_P[Sick_tunnel[i], "Dead", ] <- p_SD[i]
}
a_P[Sick_tunnel[tunnel_size], Sick_tunnel[tunnel_size], ] <- 1 - p_SD[tunnel_size]
a_P[Sick_tunnel[tunnel_size], "Dead", ] <- p_SD[tunnel_size]
# from Dead
a_P["Dead", "Dead", ] <- 1
# Check if transition matrix is valid (i.e., each row should add up to 1)
valid <- apply(a_P, 3, function(x) sum(rowSums(x))==n_s_td)
if (!isTRUE(all.equal(as.numeric(sum(valid)), as.numeric(n_t)))) {
stop("This is not a valid transition Matrix")
}
for (t in 1:n_t) {                         # loop through the number of cycles
m_M[t + 1, ] <- m_M[t, ] %*% a_P[, , t]  # estimate the Markov trace for cycle t + 1
# using the t-th matrix from the
#probability array
}
head(m_M, n = 30)
m_M_td <- cbind(Healthy = m_M[, "Healthy"],
Sick = rowSums(m_M[, 2:(tunnel_size +1)]),
Dead = m_M[, "Dead"])
head(m_M_td)
# create a plot of the data
matplot(m_M, type = 'l',
ylab = "Probability of state occupancy",
xlab = "Cycle",
main = "Cohort Trace", lwd = 2)
# add a legend to the graph
legend("right", v_n, col = c("black", "red", "green"), lty = 1:3, bty = "n")
v_os <- 1 - m_M_td[, "Dead"]    # calculate the overall survival (OS) probability
v_os <- rowSums(m_M_td[, 1:2])  # alternative way of calculating the OS probability
# create a simple plot showing the OS
plot(v_os, type = 'l',
ylim = c(0, 1),
ylab = "Survival probability",
xlab = "Cycle",
main = "Overall Survival")
# add grid
grid(nx = n_t, ny = 10, col = "lightgray", lty = "dotted", lwd = par("lwd"), equilogs = TRUE)
v_le <- sum(v_os)           # summing probablity of OS over time  (i.e. life expectancy)
v_prev <- m_M[, "Sick"]/v_os
