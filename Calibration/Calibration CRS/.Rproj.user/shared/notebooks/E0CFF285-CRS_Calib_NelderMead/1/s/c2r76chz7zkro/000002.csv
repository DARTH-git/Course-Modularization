"0","# record start time of calibration"
"0","t_init <- Sys.time()"
"0",""
"0","###  Sample multiple random starting values for Nelder-Mead  ###"
"0","v_params_init <- matrix(nrow=n_init, ncol=n_param)"
"0","for (i in 1:n_param){"
"0","  v_params_init[,i] <- runif(n_init,min=lb[i],max=ub[i])"
"0","}"
"0","colnames(v_params_init) <- v_param_names"
"0",""
"0","###  Run Nelder-Mead for each starting point  ###"
"0","m_calib_res <- matrix(nrow = n_init, ncol = n_param+1)"
"0","colnames(m_calib_res) <- c(v_param_names, ""Overall_fit"")"
"0","for (j in 1:n_init){"
"0","  "
"0","  ### use optim() as Nelder-Mead ###"
"0","  fit_nm <- optim(v_params_init[j,], f_gof,"
"0","                 control = list(fnscale = -1, # switches from minimization to maximization"
"0","                                maxit = 1000), hessian = T)"
"0","  m_calib_res[j,] <- c(fit_nm$par,fit_nm$value)"
"0","  "
"0","  ### to use a simulated annealing instead ###"
"0","  # fit_sa <- optim(v_params_init[j,], f_gof,"
"0","  #                method = c(""SANN""),  # switches to using simulated annealing"
"0","  #                control = list(temp = 10, tmax = 10, # algorithm tuning parameters"
"0","  #                               fnscale = -1, maxit = 1000),"
"0","  #                hessian = T)"
"0","  # m_calib_res[j,] = c(fit_sa$par,fit_sa$value)"
"0","  "
"0","  ### to use a genetic algorithm instead ###"
"0","  # library(DEoptim)"
"0","  # f_fitness <- function(params){"
"0","  #   names(params) = v_param_names"
"0","  #   return(-f_gof(params))}"
"0","  # fit_ga = DEoptim(f_fitness, lower=lb, upper=ub)"
"0","  # m_calib_res[j,] = c(fit_ga$optim$bestmem,-1*fit_ga$optim$bestval)"
"0",""
"0","  }"
"0",""
"0","# Calculate computation time"
"0","comp_time <- Sys.time() - t_init"
