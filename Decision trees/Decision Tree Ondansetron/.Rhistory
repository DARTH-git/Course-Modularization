# Credits for the example: Buxton and O' Brien 1992
# Economic evaluation of ondansetron: preliminary analysis using
# clinical trial data prior to price setting.
# Strategies: Ondansetron, Metoclopramide
################################################################################
rm(list = ls())   # clear memory (removes all the variables from the workspace)
#### 01 Load packages ####
#### 02 Load Functions ####
#### 03 Input Model Parameters ####
Strategies   <- c( "Metoclopramide", "Ondansetron")     # Names of strategies to be studied
#### input values - Ondansetron  ######
l.On <- list(
H     = 4,                      # Height of the decision tree
G     = 10,                     # number of terminal nodes, or paths
p.sem            = 0.25,        # Prob. of significant emesis
p.semAde         = 0.26,        # Prob. of ADE after emesis
p.semAdeTrt      = 0.60,        # Prob. of treatment after ADE with emesis
p.semAdeTrtRes   = 0.66,        # Prob. of resolution of treated ADE with emesis
p.semAdeNotrtRes = 1,           # Prob. of resolution after ADE that did not require treament
p.nosemAde         = 0.11,      # Prob. of ADE without emesis
p.nosemAdeTrt      = 0.17,      # Prob. of treatment after ADE without emesis
p.nosemAdeTrtRes   = 1,         # Prob. of resolution of treated ADE without emesis
p.nosemAdeNotrtRes = 1,         # Prob. of resolution of non treated ADE without emesis
c.trt               = 10,       # cost of treatment
c.sem               = 30,       # cost of episode of emesis
c.ade               = 20,       # cost of ADE
c.adeTrt            =  5,       # cost of treating an ADE
e.fail              = 0,        # effect when failed treatment
e.success           = 1         # effect when succesfull treatment
)
#### input values - Metoclopramide  ######
l.Met <- list(
H     = 4,                    # Height of the decision tree
G     = 10,                   # number of terminal nodes, or paths
p.sem            = 0.58,      # Prob. of significant emesis
p.semAde         = 0.34,      # Prob. of ADE after emesis
p.semAdeTrt      = 0.60,      # Prob. of treatment after ADE with emesis
p.semAdeTrtRes   = 0.78,      # Prob. of resolution of treated ADE with emesis
p.semAdeNotrtRes = 1,         # Prob. of trresolution after ADE that did not require treament
p.nosemAde         = 0.12,    # Prob. of ADE without emesis
p.nosemAdeTrt      = 0.50,    # Prob. of treatment after ADE without  emesis
p.nosemAdeTrtRes   = 1,       # Prob. of resolution of treated ADE without emesis
p.nosemAdeNotrtRes = 1,       # Prob. of resolution of non treated ADE without emesis
c.trt               = 10,     # cost of treatment
c.sem               = 30,     # cost of episode of emesis
c.ade               = 20,     # cost of ADE
c.adeTrt            =  5,     # cost of treating an ADE
e.fail              = 0,      # effect when failed treatment
e.success           = 1       # effect when succesfull treatment
)
Costs <- function(input){
with(input,    # Vector of Costs per Path. the cost of treatement is applied in all paths
# with is a generic function that evaluates expr in a local environment constructed from data. The environment has the caller's environment as its parent. This is useful for simplifying calls to modeling functions.
{
c(c.trt + c.sem,
c.trt + c.sem + c.ade + c.adeTrt,
c.trt + c.sem + c.ade + c.adeTrt,
c.trt + c.sem + c.ade,
c.trt + c.sem + c.ade,
c.trt,
c.trt + c.ade + c.adeTrt,
c.trt + c.ade + c.adeTrt,
c.trt + c.ade,
c.trt + c.ade)
}
)
}
Effs <-  function(input){
with(input,{
c(0,   # vector of health outcomes for both therapies for each path
e.fail,
e.fail,
e.fail,
e.fail,
e.success,
e.fail,
e.fail,
e.fail,
e.fail)
})
}
#### 04 Estimation of the Decision Tree ####
DecisionTree <- function(input){
with(input,
{
v.weights <- c( p.sem *   (1 - p.semAde),                                                   #  emesis with no ADEs
p.sem *        p.semAde *      p.semAdeTrt    *      p.semAdeTrtRes,      # ADE after emesis that was treated and resolved
p.sem *        p.semAde *      p.semAdeTrt    * (1 - p.semAdeTrtRes),     # ADE after emesis that was treated and did not resolve
p.sem *        p.semAde * (1 - p.semAdeTrt)   *      p.semAdeNotrtRes,    # ADE after emesis that was not treated and resolved
p.sem *        p.semAde * (1 - p.semAdeTrt)   * (1 - p.semAdeNotrtRes),   # ADE after emesis that was not treated and did not resolve
(1 - p.sem) * (1 - p.nosemAde),                                                 # no emesis with no ADEs
(1 - p.sem) *      p.nosemAde *      p.nosemAdeTrt  *      p.nosemAdeTrtRes,    # ADE after no emesis that was treated and resolved
(1 - p.sem) *      p.nosemAde *      p.nosemAdeTrt  * (1 - p.nosemAdeTrtRes),   # ADE after no emesis that was treated and did not resolve
(1 - p.sem) *      p.nosemAde * (1 - p.nosemAdeTrt) *      p.nosemAdeNotrtRes,  # ADE after no emesis that was not treated and resolved
(1 - p.sem) *      p.nosemAde * (1 - p.nosemAdeTrt) * (1 - p.nosemAdeNotrtRes)) # ADE after no emesis that was not treated and did not resolve
tc        <-   Costs(input) %*% v.weights
te        <-    Effs(input) %*% v.weights
return(data.frame(TC = tc,TE = te, weights =v.weights))
}
)
}
#### 04.1 output ####
#### 04.1.1 alternative to calculate output ####
v.res.On  <- DecisionTree(l.On)
v.res.Met <- DecisionTree(l.Met)
#### 05 Cost-effectiveness analysis ####
delta.c  <- v.res.Met$TC - v.res.On$TC   # incremental costs
delta.e  <- v.res.Met$TE - v.res.On$TE   # incremental effectiveness
icer     <- delta.c / delta.e    # incremental cost-effectiveness ratio
table.res           <- data.frame(cbind(rbind(v.res.On, v.res.Met), c(NaN,delta.c), c(NaN, delta.e), c(NaN, icer)))
colnames(table.res) <-  c("Cost", "Effectiveness", "Incremental Costs", "Incremental Effects", "ICER")
rownames(table.res) <- Strategies
table.res$ICER[table.res$"Incremental Costs" < 0 &
table.res$"Incremental Effects" > 0] ="Dominant"
table.res$ICER[table.res$"Incremental Costs" > 0 &
table.res$"Incremental Effects" < 0] ="Dominated"
table.res
setwd("C:/Users/Alan Yang/Google Drive/DARTH/Courses/2019 CE16/Assignments/Day 1")
#########                  Decision Tree  model                 ################
#########           including HMD mortality rates               ################
#########             for the CE16 NIHES course                 ################
# Developed by:
# the Decision Analysis in R for Technologies in Health (DARTH) group
# Fernando Alarid-Escudero, PhD (1)
# Eva A. Enns, MS, PhD (1)
# M.G. Myriam Hunink, MD, PhD (2,3)
# Hawre J. Jalal, MD, PhD (4)
# Eline M. Krijkamp, MSc (2)
# Petros Pechlivanoglou, PhD (5)
# In collaboration of:
# 1 University of Minnesota School of Public Health, Minneapolis, MN, USA
# 2 Erasmus MC, Rotterdam, The Netherlands
# 3 Harvard T.H. Chan School of Public Health, Boston, USA
# 4 University of Pittsburgh Graduate School of Public Health, Pittsburgh, PA, USA
# 5 The Hospital for Sick Children, Toronto and University of Toronto, Toronto ON, Canada
################################################################################
# Please cite our publications when using this code
# darthworkgroup.com
## Jalal H, et al. An Overview of R in Health Decision Sciences.
# Med. Decis. Making. 2017; 37(3): 735-746.
## Krijkamp EM, et al. Microsimulation modeling for health decision sciences
# using R: a tutorial. Med. Decis. Making. 2018; 38(3): 400-422.
################################################################################
# Copyright 2017,
# THE HOSPITAL FOR SICK CHILDREN AND THE COLLABORATING INSTITUTIONS.
# All rights reserved in Canada, the United States and worldwide.
# Copyright, trademarks, trade names and any and all associated intellectual
# property are exclusively owned by THE HOSPITAL FOR SICK CHILDREN and the
# collaborating institutions and may not be used, reproduced, modified,
# distributed or adapted in any way without written permission
################################################################################
# Credits for the example: Buxton and O' Brien 1992
# Economic evaluation of ondansetron: preliminary analysis using
# clinical trial data prior to price setting.
# Strategies: Ondansetron, Metoclopramide
################################################################################
rm(list = ls())   # clear memory (removes all the variables from the workspace)
#### 01 Load packages ####
#### 02 Load Functions ####
#### 03 Input Model Parameters ####
Strategies   <- c( "Metoclopramide", "Ondansetron")     # Names of strategies to be studied
#### input values - Ondansetron  ######
l.On <- list(
H     = 4,                      # Height of the decision tree
G     = 10,                     # number of terminal nodes, or paths
p.sem            = 0.25,        # Prob. of significant emesis
p.semAde         = 0.26,        # Prob. of ADE after emesis
p.semAdeTrt      = 0.60,        # Prob. of treatment after ADE with emesis
p.semAdeTrtRes   = 0.66,        # Prob. of resolution of treated ADE with emesis
p.semAdeNotrtRes = 1,           # Prob. of resolution after ADE that did not require treament
p.nosemAde         = 0.11,      # Prob. of ADE without emesis
p.nosemAdeTrt      = 0.17,      # Prob. of treatment after ADE without emesis
p.nosemAdeTrtRes   = 1,         # Prob. of resolution of treated ADE without emesis
p.nosemAdeNotrtRes = 1,         # Prob. of resolution of non treated ADE without emesis
c.trt               = 10,       # cost of treatment
c.sem               = 30,       # cost of episode of emesis
c.ade               = 20,       # cost of ADE
c.adeTrt            =  5,       # cost of treating an ADE
e.fail              = 0,        # effect when failed treatment
e.success           = 1         # effect when succesfull treatment
)
#### input values - Metoclopramide  ######
l.Met <- list(
H     = 4,                    # Height of the decision tree
G     = 10,                   # number of terminal nodes, or paths
p.sem            = 0.58,      # Prob. of significant emesis
p.semAde         = 0.34,      # Prob. of ADE after emesis
p.semAdeTrt      = 0.60,      # Prob. of treatment after ADE with emesis
p.semAdeTrtRes   = 0.78,      # Prob. of resolution of treated ADE with emesis
p.semAdeNotrtRes = 1,         # Prob. of trresolution after ADE that did not require treament
p.nosemAde         = 0.12,    # Prob. of ADE without emesis
p.nosemAdeTrt      = 0.50,    # Prob. of treatment after ADE without  emesis
p.nosemAdeTrtRes   = 1,       # Prob. of resolution of treated ADE without emesis
p.nosemAdeNotrtRes = 1,       # Prob. of resolution of non treated ADE without emesis
c.trt               = 10,     # cost of treatment
c.sem               = 30,     # cost of episode of emesis
c.ade               = 20,     # cost of ADE
c.adeTrt            =  5,     # cost of treating an ADE
e.fail              = 0,      # effect when failed treatment
e.success           = 1       # effect when succesfull treatment
)
Costs <- function(input){
with(input,    # Vector of Costs per Path. the cost of treatement is applied in all paths
# with is a generic function that evaluates expr in a local environment constructed from data. The environment has the caller's environment as its parent. This is useful for simplifying calls to modeling functions.
{
c(c.trt + c.sem,
c.trt + c.sem + c.ade + c.adeTrt,
c.trt + c.sem + c.ade + c.adeTrt,
c.trt + c.sem + c.ade,
c.trt + c.sem + c.ade,
c.trt,
c.trt + c.ade + c.adeTrt,
c.trt + c.ade + c.adeTrt,
c.trt + c.ade,
c.trt + c.ade)
}
)
}
Effs <-  function(input){
with(input,{
c(0,   # vector of health outcomes for both therapies for each path
e.fail,
e.fail,
e.fail,
e.fail,
e.success,
e.fail,
e.fail,
e.fail,
e.fail)
})
}
#### 04 Estimation of the Decision Tree ####
DecisionTree <- function(input){
with(input,
{
v.weights <- c( p.sem *   (1 - p.semAde),                                                   #  emesis with no ADEs
p.sem *        p.semAde *      p.semAdeTrt    *      p.semAdeTrtRes,      # ADE after emesis that was treated and resolved
p.sem *        p.semAde *      p.semAdeTrt    * (1 - p.semAdeTrtRes),     # ADE after emesis that was treated and did not resolve
p.sem *        p.semAde * (1 - p.semAdeTrt)   *      p.semAdeNotrtRes,    # ADE after emesis that was not treated and resolved
p.sem *        p.semAde * (1 - p.semAdeTrt)   * (1 - p.semAdeNotrtRes),   # ADE after emesis that was not treated and did not resolve
(1 - p.sem) * (1 - p.nosemAde),                                                 # no emesis with no ADEs
(1 - p.sem) *      p.nosemAde *      p.nosemAdeTrt  *      p.nosemAdeTrtRes,    # ADE after no emesis that was treated and resolved
(1 - p.sem) *      p.nosemAde *      p.nosemAdeTrt  * (1 - p.nosemAdeTrtRes),   # ADE after no emesis that was treated and did not resolve
(1 - p.sem) *      p.nosemAde * (1 - p.nosemAdeTrt) *      p.nosemAdeNotrtRes,  # ADE after no emesis that was not treated and resolved
(1 - p.sem) *      p.nosemAde * (1 - p.nosemAdeTrt) * (1 - p.nosemAdeNotrtRes)) # ADE after no emesis that was not treated and did not resolve
tc        <-   Costs(input) %*% v.weights
te        <-    Effs(input) %*% v.weights
return(data.frame(TC = tc,TE = te, weights =v.weights))
}
)
}
#### 04.1 output ####
#### 04.1.1 alternative to calculate output ####
v.res.On  <- DecisionTree(l.On)
v.res.Met <- DecisionTree(l.Met)
#### 05 Cost-effectiveness analysis ####
delta.c  <- v.res.Met$TC - v.res.On$TC   # incremental costs
delta.e  <- v.res.Met$TE - v.res.On$TE   # incremental effectiveness
icer     <- delta.c / delta.e    # incremental cost-effectiveness ratio
table.res           <- data.frame(cbind(rbind(v.res.On, v.res.Met), c(NaN,delta.c), c(NaN, delta.e), c(NaN, icer)))
colnames(table.res) <-  c("Cost", "Effectiveness", "Incremental Costs", "Incremental Effects", "ICER")
rownames(table.res) <- Strategies
table.res$ICER[table.res$"Incremental Costs" < 0 &
table.res$"Incremental Effects" > 0] ="Dominant"
table.res$ICER[table.res$"Incremental Costs" > 0 &
table.res$"Incremental Effects" < 0] ="Dominated"
table.res
#########                  Decision Tree  model                 ################
#########             for the CE16 NIHES course                 ################
# Developed by:
# the Decision Analysis in R for Technologies in Health (DARTH) group
# Fernando Alarid-Escudero, PhD (1)
# Eva A. Enns, MS, PhD (1)
# M.G. Myriam Hunink, MD, PhD (2,3)
# Hawre J. Jalal, MD, PhD (4)
# Eline M. Krijkamp, MSc (2)
# Petros Pechlivanoglou, PhD (5)
# In collaboration of:
# 1 University of Minnesota School of Public Health, Minneapolis, MN, USA
# 2 Erasmus MC, Rotterdam, The Netherlands
# 3 Harvard T.H. Chan School of Public Health, Boston, USA
# 4 University of Pittsburgh Graduate School of Public Health, Pittsburgh, PA, USA
# 5 The Hospital for Sick Children, Toronto and University of Toronto, Toronto ON, Canada
################################################################################
# Please cite our publications when using this code
# darthworkgroup.com
## Jalal H, et al. An Overview of R in Health Decision Sciences.
# Med. Decis. Making. 2017; 37(3): 735-746.
## Krijkamp EM, et al. Microsimulation modeling for health decision sciences
# using R: a tutorial. Med. Decis. Making. 2018; 38(3): 400-422.
################################################################################
# Copyright 2017,
# THE HOSPITAL FOR SICK CHILDREN AND THE COLLABORATING INSTITUTIONS.
# All rights reserved in Canada, the United States and worldwide.
# Copyright, trademarks, trade names and any and all associated intellectual
# property are exclusively owned by THE HOSPITAL FOR SICK CHILDREN and the
# collaborating institutions and may not be used, reproduced, modified,
# distributed or adapted in any way without written permission
################################################################################
# Credits for the example: Buxton and O'Brien 1992
# Economic evaluation of ondansetron: preliminary analysis using
# clinical trial data prior to price setting.
# Strategies: Ondansetron, Metoclopramide
################################################################################
rm(list = ls())   # clear memory (removes all the variables from the workspace)
####################### INPUT PARAMETERS   #####################################
Strategies   <- c("Metoclopramide", "Ondansetron") # Names of strategies to be studied
#### input values - Ondansetron  ######
p.semOn            <- 0.25         # Prob. of significant emesis
p.semAdeOn         <- 0.26         # Prob. of ADE after emesis
p.semAdeTrtOn      <- 0.60         # Prob. of treatment after ADE with emesis
p.semAdeTrtResOn   <- 0.66         # Prob. of resolution of treated ADE with emesis
p.semAdeNotrtResOn <- 1            # Prob. of resolution after ADE that did not require treament
p.nosemAdeOn         <- 0.11        # Prob. of ADE without emesis
p.nosemAdeTrtOn      <- 0.17        # Prob. of treatment after ADE without  emesis
p.nosemAdeTrtResOn   <- 1           # Prob. of resolution of treated ADE without emesis
p.nosemAdeNotrtResOn <- 1           # Prob. of resolution of non treated ADE without emesis
c.trtOn               <- 10         # cost of treatment
c.semOn               <- 30         # cost of episode of emesis
c.adeOn               <- 20         # cost of ADE
c.adeTrtOn            <-  5         # cost of treating an ADE
#### input values - Metoclopramide  ######
p.semMet            <- 0.58      # Prob. of significant emesis
p.semAdeMet         <- 0.34      # Prob. of ADE after emesis
p.semAdeTrtMet      <- 0.60      # Prob. of treatment after ADE with emesis
p.semAdeTrtResMet   <- 0.78      # Prob. of resolution of treated ADE with emesis
p.semAdeNotrtResMet <- 1         # Prob. of resolution after ADE that did not require treament
<-
p.nosemAdeMet         <- 0.12    # Prob. of ADE without emesis
p.nosemAdeTrtMet      <- 0.50    # Prob. of treatment after ADE without  emesis
p.nosemAdeTrtResMet   <- 1       # Prob. of resolution of treated ADE without emesis
p.nosemAdeNotrtResMet <- 1       # Prob. of resolution of non treated ADE without emesis
c.trtMet               <- 10     # cost of treatment
c.semMet               <- 30     # cost of episode of emesis
c.adeMet               <- 20     # cost of ADE
c.adeTrtMet            <-  5     # cost of treating an ADE
####################  DECISION TREE ESTIMATION ########################################
v.w.On <-c(   p.semOn *   (1 - p.semAdeOn),                                                     #  emesis with no ADEs
p.semOn *        p.semAdeOn   *      p.semAdeTrtOn    *      p.semAdeTrtResOn,    # ADE after emesis that was treated and resolved
p.semOn *        p.semAdeOn   *      p.semAdeTrtOn    * (1 - p.semAdeTrtResOn),   # ADE after emesis that was treated and did not resolve
p.semOn *        p.semAdeOn   * (1 - p.semAdeTrtOn)   *      p.semAdeNotrtResOn,  # ADE after emesis that was not treated and resolved
p.semOn *        p.semAdeOn   * (1 - p.semAdeTrtOn)   * (1 - p.semAdeNotrtResOn), # ADE after emesis that was not treated and did not resolve
(1 - p.semOn) * (1 - p.nosemAdeOn),                                                     # no emesis with no ADEs
(1 - p.semOn) *      p.nosemAdeOn *      p.nosemAdeTrtOn  *      p.nosemAdeTrtResOn,    # ADE after no emesis that was treated and resolved
(1 - p.semOn) *      p.nosemAdeOn *      p.nosemAdeTrtOn  * (1 - p.nosemAdeTrtResOn),   # ADE after no emesis that was treated and did not resolve
(1 - p.semOn) *      p.nosemAdeOn * (1 - p.nosemAdeTrtOn) *      p.nosemAdeNotrtResOn,  # ADE after no emesis that was not treated and resolved
(1 - p.semOn) *      p.nosemAdeOn * (1 - p.nosemAdeTrtOn) * (1 - p.nosemAdeNotrtResOn)) # ADE after no emesis that was not treated and did not resolve
v.w.Met <-c(p.semMet *   (1 - p.semAdeMet),                                                       #  emesis with no ADEs
p.semMet *        p.semAdeMet   *      p.semAdeTrtMet    *      p.semAdeTrtResMet,    # ADE after emesis that was treated and resolved
p.semMet *        p.semAdeMet   *      p.semAdeTrtMet    * (1 - p.semAdeTrtResMet),   # ADE after emesis that was treated and did not resolve
p.semMet *        p.semAdeMet   * (1 - p.semAdeTrtMet)   *      p.semAdeNotrtResMet,  # ADE after emesis that was not treated and resolved
p.semMet *        p.semAdeMet   * (1 - p.semAdeTrtMet)   * (1 - p.semAdeNotrtResMet), # ADE after emesis that was not treated and did not resolve
(1 - p.semMet) * (1 - p.nosemAdeMet),                                                     # no emesis with no ADEs
(1 - p.semMet) *      p.nosemAdeMet *      p.nosemAdeTrtMet  *      p.nosemAdeTrtResMet,  # ADE after no emesis that was treated and resolved
(1 - p.semMet) *      p.nosemAdeMet *      p.nosemAdeTrtMet  * (1 - p.nosemAdeTrtResMet), # ADE after no emesis that was treated and did not resolve
(1 - p.semMet) *      p.nosemAdeMet * (1 - p.nosemAdeTrtMet) *      p.nosemAdeNotrtResMet,  # ADE after no emesis that was not treated and resolved
(1 - p.semMet) *      p.nosemAdeMet * (1 - p.nosemAdeTrtMet) * (1 - p.nosemAdeNotrtResMet)) # ADE after no emesis that was not treated and did not resolve
v.c.On <-                                           # Estimating cost per path for the ondasentron arm
c(c.trtOn + c.semOn,
c.trtOn + c.semOn + c.adeOn + c.adeTrtOn,
c.trtOn + c.semOn + c.adeOn + c.adeTrtOn,
c.trtOn + c.semOn + c.adeOn,
c.trtOn + c.semOn + c.adeOn,
c.trtOn,
c.trtOn + c.adeOn + c.adeTrtOn,
c.trtOn + c.adeOn + c.adeTrtOn,
c.trtOn + c.adeOn,
c.trtOn + c.adeOn)
v.c.Met <-                                          # Estimating cost per path for the metoclopramide arm
c(c.trtMet + c.semMet,
c.trtMet + c.semMet + c.adeMet + c.adeTrtMet,
c.trtMet + c.semMet + c.adeMet + c.adeTrtMet,
c.trtMet + c.semMet + c.adeMet,
c.trtMet + c.semMet + c.adeMet,
c.trtMet,
c.trtMet + c.adeMet + c.adeTrtMet,
c.trtMet + c.adeMet + c.adeTrtMet,
c.trtMet + c.adeMet,
c.trtMet + c.adeMet)
v.e.On <- v.e.Met <-  c(0,  # vector of health outcomes for both therapies for each path
0,
0,
0,
0,
1,
0,
0,
0,
0)
##################OUTPUT #######################
ev.c.On  <- sum(v.w.On * v.c.On)    # expected   costs - Ondansetron
ev.e.On  <- sum(v.w.On * v.e.On)    # expected effects - Ondansetron
ev.c.Met  <- sum(v.w.Met * v.c.Met)    # expected   costs - Ondansetron
ev.e.Met  <- sum(v.w.Met * v.e.Met)    # expected effects - Ondansetron
delta.c  <- ev.c.On - ev.c.Met   # incremental costs
delta.e  <- ev.e.On - ev.e.Met   # incremental effectiveness
icer     <- delta.c / delta.e    # incremental cost-effectiveness ratio
table.res <- matrix(c(ev.c.Met, ev.e.Met, NA, NA, NA,
ev.c.On, ev.e.On, delta.c, delta.e, icer ),
nrow = 2, byrow = T,
dimnames = list(Strategies, c("Cost", "Effectiveness", "Incremental Costs", "Incremental Effects", "ICER")))
table.res <- as.data.frame(table.res)
table.res <- round( table.res, 3)
table.res$ICER[table.res$"Incremental Costs" < 0 &
table.res$"Incremental Effects" > 0] ="Dominant"
table.res
verbose
c(c_H, c_S, c_D)
# Strategy names
v_names_str <- c("Base Case")
# Number of strategies
n_str <- length(v_names_str)
# Markov model parameters
v_n  <- c("Healthy", "Sick", "Dead")    # state names
n_s  <- length(v_n)                     # number of states
n_t  <- 60                              # number of cycles
# Tunnels
tunnel_size <- n_t
# Sick state
Sick_tunnel <- paste("Sick_", seq(1, tunnel_size), "Yr", sep = "")
Sick_tunnel
tunnel_size
p_SD[i]
p_SD
p_SD
# Weibull parameters
l <- 0.08
g <- 1.1
p_SD <- l*g*(1:tunnel_size)^{g-1}       # probability to die when sick (time-dependent)
tunnel_size
Sick_tunnel[2]
for(i in 1:(tunnel_size )){
a_P[Sick_tunnel[i], Sick_tunnel[i + 1], ] <- 1 - p_SD[i]
a_P[Sick_tunnel[i], "Dead", ] <- p_SD[i]
}
# from Healthy
a_P["Healthy", "Healthy", ]  <- 1 - p_HD - p_HS
# Strategy names
v_names_str <- c("Base Case")
# Number of strategies
n_str <- length(v_names_str)
# Markov model parameters
v_n  <- c("Healthy", "Sick", "Dead")    # state names
n_s  <- length(v_n)                     # number of states
n_t  <- 60                              # number of cycles
# Tunnels
tunnel_size <- n_t
# Sick state
Sick_tunnel <- paste("Sick_", seq(1, tunnel_size), "Yr", sep = "")
# Create variables for time-dependent model
v_n_td  <- c("Healthy", Sick_tunnel, "Dead")   # state names
n_s_td  <- length(v_n_td)                      # number of states
p_HD <- seq(0.003, 0.01, length.out = n_t)  # probability to die when sick (age-dependent) - this is a sequence - officially v_HD
p_HS <- 0.05                                # probability to become sick when healthy
p_SD <- 0.1                                 # probability to die when sick
# Weibull parameters
l <- 0.08
g <- 1.1
p_SD <- l*g*(1:tunnel_size)^{g-1}       # probability to die when sick (time-dependent)
# Costs and utilities
c_H  <- 400                             # cost of remaining one cycle healthy
c_S  <- 1000                            # cost of remaining one cycle sick
c_D  <- 0                               # cost of remaining one cycle dead
u_H  <- 0.8                             # utility when healthy
u_S  <- 0.5                             # utility when sick
u_D  <- 0                               # utility when dead
d_e <- d_c <- 0.03                      # equal discount of costs and QALYs by 3%
# calculate discount weights for costs for each cycle based on discount rate d_c
v_dwc <- 1 / (1 + d_e) ^ (0:n_t)
# calculate discount weights for effectiveness for each cycle based on discount rate d_e
v_dwe <- 1 / (1 + d_c) ^ (0:n_t)
m_M <- matrix(NA,
nrow = n_t + 1,  # create Markov trace (n_t + 1 because R doesn't understand
# Cycle 0)
ncol = n_s_td,
dimnames = list(0:n_t, v_n_td))
# The cohort starts as healthy
# initialize first cycle of Markov trace accounting for the tunnels
m_M[1, ] <- c(1, rep(0, tunnel_size), 0)
# create the transition probability array
a_P <- array(0,                                          # Create 3-D array
dim = c(n_s_td, n_s_td, n_t),
dimnames = list(v_n_td, v_n_td, 0:(n_t-1)))
# from Healthy
a_P["Healthy", "Healthy", ]  <- 1 - p_HD - p_HS
a_P["Healthy", "Sick_1Yr", ] <- p_HS
a_P["Healthy", "Dead", ]     <- p_HD
# from Sick
for(i in 1:(tunnel_size - 1)){
a_P[Sick_tunnel[i], Sick_tunnel[i + 1], ] <- 1 - p_SD[i]
a_P[Sick_tunnel[i], "Dead", ] <- p_SD[i]
}
a_P[Sick_tunnel[tunnel_size], Sick_tunnel[tunnel_size], ] <- 1 - p_SD[tunnel_size]
a_P[Sick_tunnel[tunnel_size], "Dead", ] <- p_SD[tunnel_size]
# from Dead
a_P["Dead", "Dead", ] <- 1
# Check if transition matrix is valid (i.e., each row should add up to 1)
valid <- apply(a_P, 3, function(x) sum(rowSums(x))==n_s_td)
if (!isTRUE(all.equal(as.numeric(sum(valid)), as.numeric(n_t)))) {
stop("This is not a valid transition Matrix")
}
for (t in 1:n_t) {                         # loop through the number of cycles
m_M[t + 1, ] <- m_M[t, ] %*% a_P[, , t]  # estimate the Markov trace for cycle t + 1
# using the t-th matrix from the
# probability array
}
head(m_M, n = 30)
m_M_td <- cbind(Healthy = m_M[, "Healthy"],
Sick = rowSums(m_M[, 2:(tunnel_size +1)]),
Dead = m_M[, "Dead"])
head(m_M_td)
