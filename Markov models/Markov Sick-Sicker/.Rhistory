# Dataframe of effectiveness
df_e <- as.data.frame(matrix(0,
nrow = n_sim,
ncol = n_str))
colnames(df_e) <- v_names_str
df_psa
df_psa
# Function to generate PSA input dataset
generate_psa_params <- function(n_sim = 1000, seed = 071818){
set.seed(seed) # set a seed to be able to reproduce the same results
df_psa <- data.frame(
# Transition probabilities (per cycle)
p_HS1   = rbeta(n_sim, 30, 170),  # probability to become sick when healthy
p_S1H   = rbeta(n_sim, 60, 60) ,  # probability to become healthy when sick
p_S1S2  = rbeta(n_sim, 84, 716),  # probability to become sicker when sick
p_HD    = rbeta(n_sim, 10, 1990), # probability to die when healthy
hr_S1   = rlnorm(n_sim, log(3),  0.01), # rate ratio of death in S1 vs healthy
hr_S2   = rlnorm(n_sim, log(10), 0.02), # rate ratio of death in S2 vs healthy
# State rewards
# Costs
c_H   = rgamma(n_sim, shape = 100, scale = 20)    , # cost of remaining one cycle in state H
c_S1  = rgamma(n_sim, shape = 177.8, scale = 22.5), # cost of remaining one cycle in state S1
c_S2  = rgamma(n_sim, shape = 225, scale = 66.7)  , # cost of remaining one cycle in state S2
c_Trt = rgamma(n_sim, shape = 73.5, scale = 163.3), # cost of treatment (per cycle)
c_D   = 0                                         , # cost of being in the death state
# Utilities
u_H   = rtruncnorm(n_sim, mean =    1, sd = 0.01, b = 1), # utility when healthy
u_S1  = rtruncnorm(n_sim, mean = 0.75, sd = 0.02, b = 1), # utility when sick
u_S2  = rtruncnorm(n_sim, mean = 0.50, sd = 0.03, b = 1), # utility when sicker
u_D   = 0                                               , # utility when dead
u_Trt = rtruncnorm(n_sim, mean = 0.95, sd = 0.02, b = 1), # utility when being treated
d_e   = 0.03,  # discount factor for effectiveness
d_c   = 0.03   # discount factor for costs
)
return(df_psa)
}
# Try it
generate_psa_params(10)
# Number of simulations
n_sim <- 1000
# Generate PSA input dataset
df_psa_input <- generate_psa_params(n_sim = n_sim)
# First six observations
head(df_psa_input)
# Histogram of parameters
ggplot(melt(df_psa_input, variable.name = "Parameter"), aes(x = value)) +
facet_wrap(~Parameter, scales = "free") +
geom_histogram(aes(y = ..density..)) +
theme_bw(base_size = 16)
# Initialize dataframes with PSA output
# Dataframe of costs
df_c <- as.data.frame(matrix(0,
nrow = n_sim,
ncol = n_str))
colnames(df_c) <- v_names_str
# Dataframe of effectiveness
df_e <- as.data.frame(matrix(0,
nrow = n_sim,
ncol = n_str))
colnames(df_e) <- v_names_str
generate_psa_params(10)
generate_psa_params(10)
# Generate PSA input dataset
df_psa_input <- generate_psa_params(n_sim = n_sim)
df_psa_input
df_psa_input
# Histogram of parameters
ggplot(melt(df_psa_input, variable.name = "Parameter"), aes(x = value)) +
facet_wrap(~Parameter, scales = "free") +
geom_histogram(aes(y = ..density..)) +
theme_bw(base_size = 16)
theme_bw(base_size = 16)
ggplot(melt(df_psa_input, variable.name = "Parameter"), aes(x = value)) +
facet_wrap(~Parameter, scales = "free") +
geom_histogram(aes(y = ..density..)) +
theme_bw(base_size = 16)
?ceac
ceac_obj <- ceac(wtp = v_wtp, psa = l_psa)
plot(df_cea_psa)
# Compute expected costs and effects for each strategy from the PSA
df_out_ce_psa <- summary(l_psa)
v_wtp <- seq(0, 200000, by = 10000)
load(file = here("output", "markov_sick-sicker_PSA_dataset.RData"))
plot(l_psa)
# Compute expected costs and effects for each strategy from the PSA
df_out_ce_psa <- summary(l_psa)
# Calculate incremental cost-effectiveness ratios (ICERs)
df_cea_psa <- calculate_icers(cost       = df_out_ce_psa$meanCost,
effect     = df_out_ce_psa$meanEffect,
strategies = df_out_ce_psa$Strategy)
df_cea_psa
# Save CEA table with ICERs
# As .RData
save(df_cea_psa,
file = here("tables", "markov_sick-sicker_probabilistic_CEA_results.RData"))
# As .csv
write.csv(df_cea_psa,
file = here("tables", "markov_sick-sicker_probabilistic_CEA_results.csv"))
plot(df_cea_psa)
ceac_obj <- ceac(wtp = v_wtp, psa = l_psa)
# Regions of highest probability of cost-effectiveness for each strategy
summary(ceac_obj)
# CEAC & CEAF plot
plot(ceac_obj)
elc_obj <- calc_exp_loss(wtp = v_wtp, psa = l_psa)
elc_obj
# ELC plot
plot(elc_obj, log_y = FALSE)
evpi <- calc_evpi(wtp = v_wtp, psa = l_psa)
# EVPI plot
plot(evpi, effect_units = "QALY")
source("VOI_Functions.R")
source("GA_functions.R")
# Load simulation file
# Read the `.csv` simulation file into `R`.
toy   <- read.csv("PSA.csv", header = TRUE)[, -1]
n_sim <- nrow(toy)
# Display first five observations of the data fram using the command `head`
head(toy)
# Net Monetary Benefit (NMB)
# Create NMB matrix
nmb <- toy[, 5:7]
head(nmb)
# Number of Strategies
n_strategies <- ncol(nmb)
n_strategies
# Assign name of strategies
strategies    <- c("Strategy A", "Strategy B", "Strategy C")
colnames(nmb) <- strategies
head(nmb)
head
head(nmb)
# Format data frame suitably for plotting
nmb_gg <- melt(nmb,
variable.name = "Strategy",
value.name = "NMB")
nmb_gg
# Plot NMB for different strategies
# Faceted plot by Strategy
ggplot(nmb_gg, aes(x = NMB/1000)) +
geom_histogram(aes(y =..density..), col="black", fill = "gray") +
geom_density(color = "red") +
facet_wrap(~ Strategy, scales = "free_y") +
xlab("Net Monetary Benefit (NMB) x10^3") +
scale_x_continuous(breaks = number_ticks(5), labels = dollar) +
scale_y_continuous(breaks = number_ticks(5)) +
theme_bw()
# Calculate INMB of B vs A
# Only B vs A but we could have plotted all combinations
inmb <- data.frame(Simulation = 1:n_sim,
`Strategy B vs Strategy A` = nmb$`Strategy B` - nmb$`Strategy A`)
## Format data frame suitably for plotting
inmb_gg <- melt(inmb, id.vars = "Simulation",
variable.name = "Comparison",
value.name = "INMB")
## Format data frame suitably for plotting
inmb_gg <- melt(inmb, id.vars = "Simulation",
variable.name = "Comparison",
value.name = "INMB")
txtsize <- 16
## Plot INMB
ggplot(inmb_gg, aes(x = INMB/1000)) +
geom_histogram(aes(y =..density..), col="black", fill = "gray") +
geom_density(color = "red") +
geom_vline(xintercept = 0, col = 4, size = 1.5, linetype = "dashed") +
facet_wrap(~ Comparison, scales = "free_y") +
xlab("Incremental Net Monetary Benefit (INMB) in thousand $") +
scale_x_continuous(breaks = number_ticks(5), limits = c(-100, 100)) +
scale_y_continuous(breaks = number_ticks(5)) +
theme_bw(base_size = 14)
# Find optimal strategy (d*) based on the highest expected NMB
d_star <- which.max(colMeans(nmb))
d_star
# Compute Loss matrix iterating over all strategies
# Initialize loss matrix of dimension: number of simulation by number of strategies
loss <- matrix(0, n_sim, n_strategies)
for (d in 1:n_strategies){ # d <- 1
loss[, d] <- nmb[, d] - nmb[, d_star]
}
head(loss)
# Or without iterating (much faster!)
loss <- as.matrix(nmb - nmb[, d_star])
head(loss)
# Find optimal strategy (d*) based on the highest expected NMB
d_star <- which.max(colMeans(nmb))
nmb
# Find optimal strategy (d*) based on the highest expected NMB
d_star <- which.max(colMeans(nmb))
d_star
# Compute Loss matrix iterating over all strategies
# Initialize loss matrix of dimension: number of simulation by number of strategies
loss <- matrix(0, n_sim, n_strategies)
for (d in 1:n_strategies){ # d <- 1
loss[, d] <- nmb[, d] - nmb[, d_star]
}
head(loss)
# Or without iterating (much faster!)
loss <- as.matrix(nmb - nmb[, d_star])
head(loss)
# Find maximum loss overall strategies at each state of the world
# (i.e., PSA sample)
max_loss_i <- rowMaxs(loss)
head(max_loss_i)
# Find maximum loss overall strategies at each state of the world
# (i.e., PSA sample)
max_loss_i <- rowMaxs(loss)
# Find maximum loss overall strategies at each state of the world
# (i.e., PSA sample)
max_loss_i <- rowMaxs(loss)
if (!require('pacman')) install.packages('pacman'); library(pacman) # use this package to conveniently install other packages
# load (install if required) packages from CRAN
p_load("here", "dplyr", "devtools", "matrixStats", "scales", "ggplot2", "grid", "mgcv", "gridExtra", "gdata",
"reshape2", "knitr")
# load (install if required) packages from GitHub
# install_github("DARTH-git/dampack", force = TRUE) Uncomment if there is a newer version
p_load_gh("DARTH-git/dampack")
source("VOI_Functions.R")
source("GA_functions.R")
# Find maximum loss overall strategies at each state of the world
# (i.e., PSA sample)
max_loss_i <- rowMaxs(loss)
head(max_loss_i)
## Average across all states of the world
evpi <- mean(max_loss_i)
evpi
head(max_loss_i)
## Average across all states of the world
evpi <- mean(max_loss_i)
evpi
############  Microsimulation Sick-Sicker model with time dependency  ##########
# Includes:
# individual characteristics: age
# age dependent mortality probabilities
# time dependency for the sick (S1) state
# increasing change of death in the first 6 year of sickness (tunnel)
# Probabilistic Sensitivity Analysis (PSA)
################################################################################
# Developed by the Decision Analysis in R for Technologies in Health (DARTH) group
# Fernando Alarid-Escudero, PhD (1)
# Eva A. Enns, MS, PhD (1)
# M.G. Myriam Hunink, MD, PhD (2,3)
# Hawre J. Jalal, MD, PhD (4)
# Eline M. Krijkamp, MSc (2)
# Petros Pechlivanoglou, PhD (5)
# In collaboration of:
# 1 University of Minnesota School of Public Health, Minneapolis, MN, USA
# 2 Erasmus MC, Rotterdam, The Netherlands
# 3 Harvard T.H. Chan School of Public Health, Boston, USA
# 4 University of Pittsburgh Graduate School of Public Health, Pittsburgh, PA, USA
# 5 The Hospital for Sick Children, Toronto and University of Toronto, Toronto ON, Canada
################################################################################
# Please cite our publications when using this code:
# darthworkgroup.com
# Krijkamp EM, Alarid-Escudero F, Enns EA, Jalal HJ, Hunink MGM, Pechlivanoglou P.
# Microsimulation modeling for health decision sciences using R: A tutorial.
# Med Decis Making. 2018;38(3):400-422.
# See GitHub for more information or code updates
# https://github.com/DARTH-git/Microsimulation-tutorial
################################################################################
# Copyright 2017,
# THE HOSPITAL FOR SICK CHILDREN AND THE COLLABORATING INSTITUTIONS.
# All rights reserved in Canada, the United States and worldwide.
# Copyright, trademarks, trade names and any and all associated intellectual property
# are exclusively owned by THE HOSPITAL FOR SICK CHILDREN and the collaborating
# institutions and may not be used, reproduced, modified, distributed or adapted
# in any way without appropriate citation.
################################################################################
rm(list = ls()) # clear memory (removes all the variables from the workspace)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # set working directory to the folder where the file is saved
#### 01 Load packages ####
library(dplyr) # load plyr including the useful join function
library(dampack) # for CEA, PSA, and visualization
library(reshape2)
#### 02 Load Functions ####
source("Functions.R")
#### 03 Input Model Parameters ####
set.seed(1)                    # set the seed
# Model structure
n_t   <- 30                       # time horizon, 30 cycles
n_i   <- 100000                   # number of simulated individuals
v_n   <- c("H", "S1", "S2", "D")  # the model states names
n_s   <- length(v_n)              # the number of health states
d_r   <- 0.03                     # discount rate of 3% per cycle
v_dwe <- v_dwc <- 1 / ((1 + d_r) ^ (0:n_t))              # discount weight
v_names_str <- c("no treatment", "treatment")            # strategy names
n_str <- length(v_names_str)      # number of strategies
### Event probabilities (per cycle)
# Annual transition probabilities
p_HS1   <- 0.15                # probability of becoming sick when healthy
p_S1H   <- 0.5                 # probability of recovering to healthy when sick
p_S1S2  <- 0.105               # probability of becoming sicker when sick
# Annual probabilities of death
p_mort   <- read.csv("mortProb_age.csv")                 # load age dependent probability
dist_Age <- read.csv("MyPopulation-AgeDistribution.csv") # load age distribution
p_S1D    <- c(0.0149, 0.018, 0.021, 0.026, 0.031, rep(0.037, n_t - 5)) # probability to die in S1 by cycle
p_S2D    <- 0.048           # probability to die in S2
# Cost inputs
c_H     <- 2000             # cost of one cycle in the healthy state
c_S1    <- 4000             # cost of one cycle in the sick state
c_S2    <- 15000            # cost of one cycle in the sicker state
c_D     <- 0                # cost of one cycle in the dead state
c_Trt   <- 12000            # cost of treatment (per cycle)
# Utility inputs
u_H     <- 1                # utility when healthy
u_S1    <- 0.75             # utility when sick
u_S2    <- 0.5              # utility when sicker
u_D     <- 0                # utility when dead
u_Trt   <- 0.95             # utility when sick(er) and being treated
#### 04 Sample individual level characteristics ####
#### 04.1 Static characteristics ####
v_x      <- runif(n_i, min = 0.95, max = 1.05) # treatment effect modifier at baseline
v_age0   <- sample(x = dist_Age$age, prob = dist_Age$prop, size = n_i, replace = TRUE) # sample from age distribution an initial age for every individual
df_X     <- data.frame(ID = 1:n_i, x = v_x, Age = v_age0)
#### 04.2 Dynamic characteristics
# Specify the initial health state of the individuals
# everyone begins in the healthy state (in this example)
v_M_init  <- rep("H", n_i)       # a vector with the initial health state for all individuals
v_Ts_init <- rep(0, n_i)         # a vector with the time of being sick at the start of the model
#### 05 Define Simulation Functions ####
#### 05.1 Probability function ####
# The Probs function that updates the transition probabilities of every cycle is shown below.
Probs <- function(M_it, df_X, v_Ts, t) {
# Arguments:
# M_it: health state occupied by individual i at cycle t (character variable)
# v_Ts: time an individual is sick
# t:     current cycle
# Returns:
#   transition probabilities for that cycle
m_p_it           <- matrix(0, nrow = n_s, ncol = n_i)  # create matrix of state transition probabilities
rownames(m_p_it) <-  v_n                               # give the state names to the rows
# lookup baseline probability and rate of dying based on individual characteristics
p_HD_all <- inner_join(df_X, p_mort, by = c("Age"))
p_HD     <- p_HD_all[M_it == "H","p_HD"]
# update the v_p with the appropriate probabilities
m_p_it[, M_it == "H"]  <- rbind(1 - p_HS1 - p_HD, p_HS1, 0, p_HD)                              # transition probabilities when healthy
m_p_it[, M_it == "S1"] <- rbind(p_S1H, 1 - p_S1H - p_S1S2 - p_S1D[v_Ts], p_S1S2, p_S1D[v_Ts])  # transition probabilities when sick
m_p_it[, M_it == "S2"] <- c(0, 0, 1 - p_S2D, p_S2D)                                            # transition probabilities when sicker
m_p_it[, M_it == "D"]  <- c(0, 0, 0, 1)                                                        # transition probabilities when dead
return(t(m_p_it))
}
#### 05.2 Cost function ####
# The Costs function estimates the costs at every cycle.
Costs <- function (M_it, Trt = FALSE) {
# M_it: health state occupied by individual i at cycle t (character variable)
# Trt:  is the individual being treated? (default is FALSE)
c_it <- 0                                  # by default the cost for everyone is zero
c_it[M_it == "H"]  <- c_H                  # update the cost if healthy
c_it[M_it == "S1"] <- c_S1 + c_Trt * Trt   # update the cost if sick conditional on treatment
c_it[M_it == "S2"] <- c_S2 + c_Trt * Trt   # update the cost if sicker conditional on treatment
c_it[M_it == "D"]  <- c_D                  # update the cost if dead
return(c_it)        		                   # return the costs
}
#### 05.3 Health outcome function ####
# The Effs function to update the utilities at every cycle.
Effs <- function (M_it, df_X, Trt = FALSE, cl = 1) {
# M_it: health state occupied by individual i at cycle t (character variable)
# df_Pop: individual characteristics including Age, Sex and the effect modifier of the treatment effect
# Trt:  is the individual treated? (default is FALSE)
# cl:   cycle length (default is 1)
u_it <- 0                                        # by default the utility for everyone is zero
u_it[M_it == "H"]  <- u_H                        # update the utility if healthy
u_it[M_it == "S1" & Trt == FALSE] <- u_S1        # update the utility if sick
u_it[M_it == "S1" & Trt == TRUE]  <- u_Trt * df_X$x[M_it == "S1"]  # update the utility if sick but on treatment (adjust for individual effect modifier)
u_it[M_it == "S2"] <- u_S2                       # update the utility if sicker
u_it[M_it == "D"]  <- u_D                        # update the utility if dead
QALYs <-  u_it * cl            # calculate the QALYs during cycle t
return(QALYs)                  # return the QALYs
}
#### 06 Run Microsimulation ####
MicroSim <- function(n_i, df_X , Trt = FALSE, seed = 1) {
# Arguments:
# n_i:     number of individuals
# df_X     data frame with individual data
# Age      age of the individuals
# Sex      sex of the individuals
# x        effect modifier
# Trt:     is this the individual receiving treatment? (default is FALSE)
# seed:    default is 1
set.seed(seed) # set the seed
n_s <- length(v_n) # the number of health states
# create three matrices called m_M, m_C and m_E
# number of rows is equal to the n_i, the number of columns is equal to n_t  (the initial state and all the n_t cycles)
# m_M is used to store the health state information over time for every individual
# m_C is used to store the costs information over time for every individual
# m_E is used to store the effects information over time for every individual
m_M <- m_C <- m_E <- m_Ts <-  matrix(nrow = n_i, ncol = n_t + 1,
dimnames = list(paste("ind"  , 1:n_i, sep = " "),
paste("cycle", 0:n_t, sep = " ")))
m_M [, 1] <- v_M_init    # initial health state at cycle 0 for individual i
v_Ts      <- v_Ts_init   # initialize time since illnes onset for individual i
m_C[, 1]  <- Costs(m_M[, 1], Trt)         # calculate costs per individual during cycle 0
m_E[, 1]  <- Effs (m_M[, 1], df_X, Trt)   # calculate QALYs per individual during cycle 0
# open a loop for time running cycles 1 to n_t
for (t in 1:n_t) {
v_p <- Probs(m_M[, t], df_X, v_Ts, t)             # calculate the transition probabilities for the cycle based on  health state t
m_M[, t + 1]  <- samplev(v_p, 1)                  # sample the current health state and store that state in matrix m_M
m_C[, t + 1]  <- Costs(m_M[, t + 1], Trt)         # calculate costs per individual during cycle t + 1
m_E[, t + 1]  <- Effs(m_M[, t + 1], df_X, Trt)    # calculate QALYs per individual during cycle t + 1
v_Ts <- ifelse(m_M[, t + 1] == "S1", v_Ts + 1, 0) # update time since illness onset for t + 1
df_X$Age[m_M[, t + 1] != "D"]  <- df_X$Age[m_M[, t + 1] != "D"] + 1
# Display simulation progress
if(t/(n_t/10) == round(t/(n_t/10), 0)) { # display progress every 10%
cat('\r', paste(t/n_t * 100, "% done", sep = " "))
}
} # close the loop for the time points
# calculate
tc <- m_C %*% v_dwc    # total (discounted) cost per individual
te <- m_E %*% v_dwe    # total (discounted) QALYs per individual
tc_hat <- mean(tc)     # average (discounted) cost
te_hat <- mean(te)     # average (discounted) QALYs
# store the results from the simulation in a list
results <- list(m_M = m_M, m_C = m_C, m_E = m_E, tc = tc , te = te, tc_hat = tc_hat, te_hat = te_hat)
return(results)  # return the results
} # end of the MicroSim function
# By specifying all the arguments in the `MicroSim()` the simulation can be started
# In this example the outcomes are of the simulation are stored in the variables `outcomes_no_tr` and `outcomes_trt`.
### Run the simulation for both no treatment and treatment options
outcomes_no_trt  <- MicroSim(n_i, df_X, Trt = FALSE, seed = 1)
outcomes_trt     <- MicroSim(n_i, df_X, Trt = TRUE, seed = 1)
#### 07 Visualize results ####
options(scipen = 999)
### No treatment
plot(density(outcomes_no_trt$tc), main = paste("Total cost per person"), xlab = "Cost ($)")
plot(density(outcomes_no_trt$te), main = paste("Total QALYs per person"), xlab = "QALYs")
plot_m_TR(outcomes_no_trt$m_M)    # health state trace
# ggsave("figs/microoutcomes_sick_sicker/microoutcomes_sick_sicker_eff_density_trt.png", plot = plot_te(outcomes_trt$te), width = 8, height = 6)
### Treatment
plot(density(outcomes_trt$tc), main = paste("Total cost per person"), xlab = "Cost ($)")
plot(density(outcomes_trt$te), main = paste("Total QALYs per person"), xlab = "QALYs")
plot_m_TR(outcomes_trt$m_M)    # health state trace
#### 08 Cost Effectiveness Analysis ####
# store the mean costs of each strategy in a new variable C (vector of costs)
v_C <- c(outcomes_no_trt$tc_hat, outcomes_trt$tc_hat)
# store the mean QALYs of each strategy in a new variable E (vector of effects)
v_E <- c(outcomes_no_trt$te_hat, outcomes_trt$te_hat)
# use dampack to calculate the ICER
calculate_icers(cost       = v_C,
effect     = v_E,
strategies = v_names_str)
#### 09 Probabilistic Sensitivity Analysis (PSA) ####
### Function that generates random sample for PSA
gen_psa <- function(n_sim = 1000, seed = 071818){
set.seed(seed) # set a seed to be able to reproduce the same results
df_psa <- data.frame(
# Transition probabilities (per cycle)
p_HS1   = rbeta(n_sim, 30, 170),                             # probability to become sick when healthy
p_S1H   = rbeta(n_sim, 60, 60) ,                             # probability to become healthy when sick
p_S1S2  = rbeta(n_sim, 84, 716),                             # probability to become sicker when sick
p_S2D   = rbeta(n_sim, 22, 434),                             # probability to die in S2
# Cost vectors with length n_sim
c_H     = rgamma(n_sim, shape = 100, scale = 20)    ,        # cost of remaining one cycle in state H
c_S1    = rgamma(n_sim, shape = 177.8, scale = 22.5),        # cost of remaining one cycle in state S1
c_S2    = rgamma(n_sim, shape = 225, scale = 66.7)  ,        # cost of remaining one cycle in state S2
c_trt   = rgamma(n_sim, shape = 73.5, scale = 163.3),        # cost of treatment (per cycle)
c_D     = 0                                         ,        # cost of being in the death state
# Utility vectors with length n_sim
u_H     = rbeta(n_sim, 9, 0.009)                          ,  # utility when healthy
u_S1    = rbeta(n_sim ,351, 117)                          ,  # utility when sick
u_S2    = rbeta(n_sim, 138, 138)                          ,  # utility when sicker
u_D     = 0                                               ,  # utility when dead
u_trt   = rbeta(n_sim, 112, 6)                               # utility when being treated
)
return(df_psa)
}
###### AY: changed the utiliity distributions from truncnorm to beta, using betaPar, also double checked results
# Try it
gen_psa(10)
### Decrease number of individuals since PSA takes a lot of time
n_i <- 1000
### update Sample individual level characteristics
# Static characteristics
v_x      <- runif(n_i, min = 0.95, max = 1.05) # treatment effect modifier at baseline
v_age0   <- sample(x = dist_Age$age, prob = dist_Age$prop, size = n_i, replace = TRUE) # sample from age distribution an initial age for every individual
df_X     <- data.frame(ID = 1:n_i, x = v_x, Age = v_age0)
# Dynamic characteristics
# Specify the initial health state of the individuals
# everyone begins in the healthy state (in this example)
v_M_init  <- rep("H", n_i)       # a vector with the initial health state for all individuals
v_Ts_init <- rep(0, n_i)         # a vector with the time of being sick at the start of the model
### Number of simulations
n_sim <- 500
### Generate PSA input dataset
df_psa_input <- gen_psa(n_sim = n_sim)
## First six observations
head(df_psa_input)
## Histogram of parameters
ggplot(melt(df_psa_input, variable.name = "Parameter"), aes(x = value)) +
facet_wrap(~Parameter, scales = "free") +
geom_histogram(aes(y = ..density..)) +
theme_bw(base_size = 16)
### Initialize dataframes with PSA output
# Dataframe of costs
df_c <- as.data.frame(matrix(0,
nrow = n_sim,
ncol = n_str))
colnames(df_c) <- v_names_str
df_c
# Dataframe of effectiveness
df_e <- as.data.frame(matrix(0,
nrow = n_sim,
ncol = n_str))
colnames(df_e) <- v_names_str
calculate_ce_out
# load (install if required) packages from CRAN
p_load("here", "dplyr", "devtools", "scales", "ellipse", "ggplot2", "lazyeval", "igraph", "truncnorm", "ggraph", "reshape2", "knitr", "stringr")
if (!require('pacman')) install.packages('pacman'); library(pacman) # use this package to conveniently install other packages
# load (install if required) packages from CRAN
p_load("here", "dplyr", "devtools", "scales", "ellipse", "ggplot2", "lazyeval", "igraph", "truncnorm", "ggraph", "reshape2", "knitr", "stringr")
# load (install if required) packages from GitHub
# install_github("DARTH-git/dampack", force = TRUE) Uncomment if there is a newer version
# install_github("DARTH-git/dectree", force = TRUE) Uncomment if there is a newer version
p_load_gh("DARTH-git/dampack", "DARTH-git/dectree")
