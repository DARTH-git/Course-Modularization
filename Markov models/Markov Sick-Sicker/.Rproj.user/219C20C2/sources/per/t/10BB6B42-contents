---
output:
  pdf_document: default
  html_document: default
---
# Cohort state-transition models {#cohort-stm}

```{r, include = FALSE}
#install.packages(c("kableExtra", "scales", "tensorA", "diagram"))
library(knitr)
library(kableExtra) # https://haozhu233.github.io/kableExtra/awesome_table_in_html.html
library(dplyr)
library(reshape2)
library(ggplot2)
library(scales)  # for dollar signs and commas
library(tensorA) # to use tensor algebra
library(diagram) # functions for visualising simple graphs (networks)
age     <- 25          # age at baseline
ageMax <- 110          # maximum age of follow up
n.t <- ageMax - age    # time horizon, number of cycles
# v.r.mu <- seq(0.001, 0.01, length.out = 100)
lt.usa.2005 <- read.csv("data/LifeTable_USA_Mx_2015.csv")
v.r.mu <- lt.usa.2005 %>% 
  # filter(Age >= age & Age <= ageMax) %>%
  select(Total) %>%
  as.matrix()
```

Cohort state-transition models (cSTMs) are commonly used in medical decision making. In this chapter, we provide guidance on how to conceptualize cSTMs in R and we provide illustrative examples that help the reader understand how to practically address complexities such as time dependency. Since cSTMs are predominantly used in cost-effectiveness analysis, we also present how to calculate economic outcomes and conduct a cost-effectiveness with a cSTM using R. 

Conceptually a cSTM is simple enough that there is no need for additional packages to be installed beyond what is included in R base. However, in this chapter we will rely on a number of packages that either make presentation of the results more appealing or allow for a more convenient model setup. In particular, we will be using the packages `scales`, `tensorA` and `diagram`. [@R-scales; @R-tensorA; @R-diagram].

## Basic introduction to state transition cohort models

cSTMs are deterministic mathematical models that simulate hypothetical cohorts and their trajectories across $n_s$ health states over time [@Iskandar2018a]. These health states are assumed to be mutually exclusive and collectively exhaustive. The proportion of the cohort occupying any given health state is assumed to be homogeneous. That is, all persons residing in a particular health state are indistinguishable from another.

The cohort can transition between these health states with defined probabilities, called *transition probabilities*. A transition probability represents the chance that individuals residing in a state transition, at a given point in time, to another state or remain in the same state. Transition probabilities only depend on the current health state at any given point in time and cannot depend on the history prior to that time point, which is often referred to as the "Markovian assumption" [@Kuntz2001; @Sonnenberg1993; @Beck1983]. If the decision problem can be described with a reasonable number of health states, a cSTM could be chosen because of its "transparency, efficiency, ease of debugging and ability to conduct specific value-of-information analyses" [@Siebert2012c]. cSTMs have been used to evaluate screening programs, diagnostic procedures, disease management programs, and risk factor interventions.

cSTMs can address decision problems where the intensity of transition between states is either homogeneous over time or time-varying. Time-homogeneous cSTMs have constant transition probabilities, while time-dependent cSTMs have transition probabilities that vary over time. Most problems in health care require a time-dependent modelling approach, which can address age-specific background mortality as the cohort ages and dependency on the amount of time spent in a given state (state residence). In this chapter, we will describe how cSTMs can address both types. Time can have an effect on other components of a cSTM, such as the payoffs or the discount rate. Although we do not explicitly offer an example with time dependent payoffs, similar principles as those outlined when addressing the transition probabilities apply. 

cSTMs can be evaluated in either discrete or continuous time. In discrete-time models, the cohort transitions at fixed time intervals (cycles), while continuous-time models assume that the cohort transitions between health states continuously over time according to some transition intensity. This chapter focuses only on the discrete-time implementation of cSTMs.

In the next sections, we will illustrate the conceptualization and implementation of a cSTM to conduct a CEA using an illustrative example. The reader can easily then customize this application to their own needs. 

## Case study: Sick-Sicker model {#case-study Sick-Sicker cSTM}

We illustrate the implementation of a cSTM in the context of an economic evaluation using a previously published 4-state model [@Enns2015e]. The model is used to quantify the expected costs and quality-adjusted life years (QALYs) for individuals with a hypothetical disease with two different disease states, "Sick" and "Sicker". This "Sick-Sicker" model is subsequently used to evaluate the cost-effectiveness of a hypothetical treatment that increases quality of life (QoL) in one of the disease states [@Krijkamp2018]. We use the Sick-Sicker model to illustrate both time-homogeneous and time-dependent cSTMs.

In the Sick-Sicker model, we simulate a hypothetical cohort of 25-year-old individuals over a lifetime (or reaching age 110 years old) that all start in the "Healthy" health state (denoted "H"). That is, the total number of cycles, $n_t$ represented with `n.t` is `r n.t`. Healthy individuals are at risk of developing the disease, at which point they would transition to the initial disease state (the "Sick" health state, denoted "S1"). Individuals that become sick incur a one-time utility decrement of 0.01 (`du.HS1`, disutility of transitioning from H to S1) and a one-time cost of \$1,000 (`ic.HS1`) that reflects the acute impact of developing the disease. Sick individuals are at risk of further progressing to a more severe health state (the "Sicker" health state, denoted "S2").There is a chance that individuals in the Sick state eventually recover and return back to the Healthy state. However, once an individual reaches the Sicker health state, they cannot recover; that is, the probability of transitioning to the Sick or Healthy  states from the Sicker state is zero. Individuals in the Healthy state face the risk of moving to a "Dead" state from non-disease related causes. Sick and Sicker individuals face an increased mortality in the form of a hazard ratio (HR) of 3 (`hr.S1`) and 10 (`hr.S2`) times, respectively, of the background mortality rate. Sick and Sicker individuals also experience increased health care costs and reduced QoL compared to healthy individuals. when individuals transition to the Dead state, they incur a one-time cost of \$2,000 (`ic.D`) that reflects the acute care that might be received immediately preceding death. The state-transition diagram of the Sick-Sicker model is shown in Figure \@ref(fig:STD-Sick-Sicker). The evolution of the cohort is simulated in one-year discrete-time cycles. Both costs and QALYs are discounted at an annual rate of 3% (`d.c/ d.e`).

```{r STD-Sick-Sicker, echo = FALSE, fig.cap = "State-transition diagram of the Sick-Sicker state-transition model with the name of the states, state rewards (utilities and costs) and transition probabilities."}
v.n <- c("Healthy (H)", "Sick (S1)", "Sicker (S2)", "Dead (D)")
n.s <- length(v.n)
connect <- matrix(0, n.s, n.s, dimnames = list(v.n, v.n))
connect["Healthy (H)", "Sick (S1)"]   <- "" 
connect["Healthy (H)", "Dead (D)"]    <- "" 
connect["Sick (S1)"  , "Sicker (S2)"] <- ""
connect["Sick (S1)"  , "Healthy (H)"] <- ""
connect["Sick (S1)"  , "Dead (D)"]    <- ""
connect["Sicker (S2)", "Dead (D)"]    <- ""
connect["Dead (D)"   , "Dead (D)"]    <- ""
connect["Sick (S1)"  , "Sick (S1)"]   <- ""
connect["Sicker (S2)", "Sicker (S2)"] <- ""
connect["Healthy (H)", "Healthy (H)"] <- ""

diagram::plotmat(t(connect), c(1,2,1),self.cex = 0.5, curve = 0, 
                 self.shiftx = c(0.08,-0.08,0.08,-0.08), arr.pos = 0.7,  
                 latex=T, arr.type = "curved", relsize = 0.85, 
                 cex = 0.8, box.cex = 0.8, lwd = 1)
#knitr::include_graphics("../Diagrams/Markov-Diagram-Sick-Sicker.pdf") 
```

We are interested in evaluating the cost-effectiveness of a hypothetical new treatment for individuals affected with the disease compared to usual care (the status quo). The treatment costs \$12,000 per year (`c.Trt`). The effect of this new treatment is an increase in the QoL of individuals in the Sick state from a utility of 0.75 (without treatment, `u.S1`) to a utility of 0.95 (`u.Trt`). It does not have any impact on the QoL of individuals in the Sicker state, nor does it change the risk of becoming sick or progressing through the sick states. However, we assume that, for the treatment purposes, it is not possible to distinguish between Sick and Sicker patients; therefore, individuals in both sick states receive the treatment until they either recover to the Healthy state or die. Note that the cSTM for the new treatment is structurally identical to that of the usual-care strategy and the only difference is the added cost of the treatment for those in the Sick or Sicker state and the increase in QoL for those in the Sick state. After comparing the two strategies in terms of QALYs and costs, we calculate the incremental cost per QALY gained of treatment compared to usual care. 

All the parameters of the Sick-Sicker model and the corresponding R variable names are presented in Table \@ref(tab:param-table).

Table: (\#tab:param-table) Description of parameters with their R name and value.

|           **Parameter**            |  **R name** |   **Value**   |
|:-----------------------------------|:------------|:-------------:|
| Time horizon ($n_t$)               | `n.t`       | `r n.t` years |
| Names of health states ($n$)       | `v.n`       | H, S1, S2, D  |
| Annual discount rate (costs/QALYs) | `d.c`/`d.e` |  3%           |
| Annual transition probabilities    |             |               |
| - Disease onset (H to S1)          | `p.HS1`     |  0.15         |
| - Recovery (S1 to H)               | `p.S1H`     |  0.5          |
| - Disease progression (S1 to S2)  in the time-homogeneous model   | `p.S1S2`    |  0.105        |
| - Time-dependent disease progression (S1 to S2) | `p.S1S2Tunnels` | |
|   &nbsp;&nbsp;&nbsp;&nbsp;Weibull parameters |         |               |
|   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scale ($\lambda$)             | `l`         |  0.08       |
|   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shape ($\gamma$)              | `g`         |  1.10       |
| Annual mortality                   |             |               |
| - All-cause mortality (H to D)     | `p.HD`      |  0.002 or age-specific |
| - Hazard ratio of death in S1 vs H | `hr.S1`     |  3            |
| - Hazard ratio of death in S2 vs H | `hr.S2`     |  10           |
| Annual costs                       |             |               |
| - Healthy individuals              | `c.H`       |  $2,000       |
| - Sick individuals in S1           | `c.S1`      |  $4,000       |
| - Sick individuals in S2           | `c.S2`      |  $15,000      |
| - Dead individuals                 | `c.D`       |  $0           |
| - Additional costs of sick individuals treated in S1 or S2           | `c.Trt`     |  $12,000      |
| Utility weights                    |             |               |
| - Healthy individuals              | `u.H`       |  1.00         |
| - Sick individuals in S1           | `u.S1`      |  0.75         |
| - Sick individuals in S2           | `u.S2`      |  0.50         |
| - Dead individuals                 | `u.D`       |  0.00         |
| Intervention effect                |             |               |
| - Utility for treated individuals in S1 | `u.Trt` |  0.95        |
| Transition rewards                 |             |               |
| - Utility decrement of healthy individuals | `du.HS1`|  0.01       |
|   when transitioning to S1         |             |               |
| - Cost of healthy individuals      | `ic.HS1` |  $1,000       |
|   when transitioning to S1         |             |               |
| - Cost of dying                    | `ic.D`      |  $2,000       |

Below, we present one  approach to inputting the parameters in  R (For the most up to date code, please visit https://github.com/DARTH-git/). We use the prefixes "`m.`" or "`v.`" to represent a matrix or a vector, respectively, consistent with our previous tutorial [@Krijkamp2018]. 

```{r Model-Params, eval=TRUE}
## General setup
age     <- 25    # age at baseline
ageMax <- 110    # maximum age of follow up
n.t     <- ageMax - age     # time horizon, number of cycles
# the 4 health states of the model:
# Healthy (H), Sick (S1), Sicker (S2), Dead (D)
v.n     <- c("H", "S1", "S2", "D")  
# store the strategy names
v.str <- c("Usual care", "New treatment") 

n.s <- length(v.n) # number of health states 
d.c <- d.e <- 0.03 # equal discount of costs and QALYs by 3%

## Transition probabilities (per cycle)
# constant probability of dying when Healthy 
# (all-cause mortality)
p.HD    <- 0.002 
p.HS1   <- 0.15  # probability to become Sick when Healthy
p.S1H   <- 0.5   # probability to become Healthy when Sick
p.S1S2  <- 0.105 # probability to become Sicker when Sick
hr.S1   <- 3     # hazard ratio of death in Sick vs Healthy
hr.S2   <- 10    # hazard ratio of death in Sicker vs Healthy 

## Cost and utility inputs 
# State rewards
c.H   <- 2000  # cost of remaining one cycle Healthy 
c.S1  <- 4000  # cost of remaining one cycle Sick 
c.S2  <- 15000 # cost of remaining one cycle Sicker 
c.D   <- 0     # cost of being dead (per cycle)
c.Trt <- 12000 # cost of treatment (per cycle) 

u.H   <- 1     # utility when Healthy 
u.S1  <- 0.75  # utility when Sick 
u.S2  <- 0.5   # utility when Sicker
u.D   <- 0     # utility when Dead 
u.Trt <- 0.95  # utility when being treated

# Transition rewards
# disutility when transitioning from Healthy to Sick
du.HS1 <- 0.01 
 # increase in cost when transitioning from Healthy to Sick
ic.HS1 <- 1000 
# increase in cost when dying
ic.D   <- 2000  
```

To compute the mortality risks from the Sick and Sicker states, we transform `p.HD` to a rate assuming a constant exponential rate, `-log(1 - p.HD)`, multiply it by the hazard ratios `hr.S1` and `hr.S2`, respectively, and then convert them back to a probability. See the  R code below for more details on the calculations.

```{r Sick-Sicker-Params, eval=TRUE}
# probability of dying in Sick
p.S1D  <- 1 - exp(log(1 - p.HD) * hr.S1)
 # probability of dying in Sicker
p.S2D  <- 1 - exp(log(1 - p.HD) * hr.S2)
```

## Constructing a time-homogeneous cSTM

There are multiple approaches to construct a cSTM. The most common approaches are via a set of difference equations [@Grimmett2014; @Axler2005] or a representation of these equations through a matrix formulation [@Grimmett2014; @Axler2005; @Sonnenberg1993; @Beck1983]. In this book, we will only focus on the matrix formulation.

In general, a matrix formulation of cSTM consists of three core components: (1) a state vector, $\mathbf{m}_t$, that stores the distribution of the cohort across all health states in cycle $t$ where $t = 0,\ldots, n_t$, (2) the cohort trace matrix, $\mathbf{M}$, that *traces* the distribution of the cohort over time and is simply the collection of $\mathbf{m}_t$ for all $t$, and (3) a transition probability matrix $\mathbf{P}$, which captures the probabilities of transition across the modeled states.[@Iskandar2018a] If the cSTM is comprised of $n_s$ discrete health states, $\mathbf{m}_t$ is a $1 \times n_s$ vector and $\mathbf{P}$ is a $n_s \times n_s$ matrix. The $i^{th}$ element of $\mathbf{m}_t$ represents the proportion of the cohort in the $i^{th}$ health state in cycle $t$, referred to as $m_{it}$. Elements in the matrix $\mathbf{P}$ capture the probability of transitioning from state $i$ to state $j$, $p_{ij}$, where $\{i, j\} \in 1 \ldots n_s$. The transition probability matrix $\mathbf{P}$ can also be a function of time  where $\mathbf{P} = \mathbf{P}_t$ for $t = 1, \ldots, n_t$. 

$$
\mathbf{P} =  
\begin{bmatrix}
p_{[1,1]}   & p_{[1,2]}   & \cdots & p_{[1,n_s]} \\
p_{[2,1]}   & p_{[2,2]}   & \cdots & p_{[2,n_s]} \\
\vdots    & \vdots    & \ddots & \vdots   \\
p_{[n_s,1]} & p_{[n_s,2]} & \cdots & p_{[n_s,n_s]} \\
\end{bmatrix} 
$$

Note that all rows of the transition probability matrix  must sum to one, $\sum_{j=1}^{n_s}{p_{i,j}} = 1$ for all $i = 1,\ldots,n_s$. The state vector at cycle $t+1$, $\mathbf{m}_{t+1}$, is then calculated by the inner product of the state vector at cycle $t$, $\mathbf{m}_{t}$, and the transition probability matrix, $\mathbf{P}$. Formally,

$$\mathbf{m}_{t+1} = \mathbf{m}_{t} \mathbf{P} \text{ for } t = 0,\ldots, n_t - 1$$
 
For $\mathbf{m_t}$ to be calculated in this process for all $t$ we need to specify the initial state vector $\mathbf{m}_0$. This vector captures the distribution of the cohort across all health states at the initial cycle $0$. The cohort trace or state occupancy matrix, $\mathbf{M}$,  a matrix of dimensions $(n_t+1) \times n_s$ which is constructed by collating the state vectors $\mathbf{m}_t \text{ for } t = 0 \ldots, n_t$

$$
\mathbf{M} = 
  \begin{bmatrix}
      - \mathbf{m}_0 -      \\
      - \mathbf{m}_1 -      \\
          \vdots   \\
       - \mathbf{m}_{n_t} - \\
 \end{bmatrix}.
$$
             
$\mathbf{M}$ is the principal output of cSTMs, as it is used in the estimation of epidemiological outcomes, such as prevalence and survival, and economic outcomes, such as cumulative resource use and costs. Note that we consider that the initial cycle corresponds to $t=0$, which is stored on the first row of $\mathbf{M}$. Table \@ref(tab:cSTM-components-table) shows a description of each of the core components of a time homogeneous cSTM and their suggested name in R code. 

Table: (\#tab:cSTM-components-table) Components of cSTM with their R name.

  | Element | Description               |  R name |   |
  |---------|---------------------------|:------:|---|
  | $\mathbf{m}_t$   | State vector in cycle $t$ | `v.mt` |   |
  | $\mathbf{m}_0$   | Initial state vector      | `v.m0`   |   |
  | $\mathbf{M}$     | Cohort trace or state occupancy matrix       | `m.M`  |   |
  | $\mathbf{P}$     | Time-homogeneous transition matrix| `m.P` |   |
  <!-- | $P_t$   | Time-dependent transition array| `a.P` |   | -->
  <!-- | $A$     | Transition array          | `a.A` |   | -->
 
For the Sick-Sicker model, the entire cohort starts in the Healthy state. Therefore, we create the initial state vector `v.m0` with all of the cohort assigned to the Healthy state:
```{r Sick-Sicker-s0}
 v.m0 <- c(H = 1, S1 = 0, S2 = 0, D = 0) # initial state vector
 v.m0
```

and use it to initialize $\mathbf{M}$ represented by `m.M`
 
```{r Sick-Sicker-M}
 # Initialize cohort trace
 m.M <- matrix(0, 
               nrow = (n.t + 1), ncol = n.s, 
               dimnames = list(0:n.t, v.n))
m.M[1, ] <- v.m0
```
 
Note that the initial state vector, `v.m0`, can be modified to account for a non-zero prevalence of the disease at the start of the simulation.

Since the Sick-Sicker model consists of `r n.s` states, we create a `r n.s` $\times$ `r n.s` transition probability matrix, `m.P`. We initialize the matrix with default values of zero for all transition probabilities and then populate each of its elements with the corresponding non-zero transition probabilities To access an element of `m.P`, we specify first the row name (or number) and then the column name (or number) separated by a comma. For example, the transition probability of going from state Healthy (H) to state Sick (S1) could be accessed as `m.P["H", "S1"]` or by using the corresponding row/column state names as characters `m.P[1, 2]`.

```{r Sick-Sicker-P2}
# Initialize matrix
m.P <- matrix(0, 
             nrow = n.s, ncol = n.s, 
             dimnames = list(v.n, v.n))
# Fill in matrix
# From H
m.P["H", "H"]   <- 1 - (p.HS1 + p.HD)
m.P["H", "S1"]  <- p.HS1
m.P["H", "D"]   <- p.HD
# From S1
m.P["S1", "H"]  <- p.S1H
m.P["S1", "S1"] <- 1 - (p.S1H + p.S1S2 + p.S1D)
m.P["S1", "S2"] <- p.S1S2
m.P["S1", "D"]  <- p.S1D
# From S2
m.P["S2", "S2"] <- 1 - p.S2D
m.P["S2", "D"]  <- p.S2D
# From D
m.P["D", "D"]   <- 1
```

Next, to obtain the cohort distribution across the `r n.s` states over `r n.t` cycles using a time-homogeneous cSTM, we iteratively compute the inner product between `m.M` and `m.P`. To achieve that in R we use a combination of the `for` loop over `n.t` cycles and the inner product `%*%` operator. 
                    
```{r Sick-Sicker-TimeHomogeneous-Solution}
# Iterative solution of time-homogeneous cSTM
for(t in 1:n.t){
 m.M[t + 1, ] <- m.M[t, ] %*% m.P
}
```

Table \@ref(tab:Trace) shows the cohort trace matrix of the Sick-Sicker model for the first six cycles. The whole cohort starts in the Healthy state and transitions to the rest of the health states over time. Given that the Dead state is an absorbing state, the proportion in this state increases over time. A graphical representation of the cohort trace for all the cycles is shown in Figure \@ref(fig:Sick-Sicker-Trace-TimeHom). 
                    
```{r Trace, echo = FALSE, message = FALSE, warning = FALSE}
kable(head(round(m.M, 3)), 
      #format = ifelse(doc.type == "docx", "markdown", "latex"),  
      booktabs = TRUE,
      caption = "First six cycles of the cohort trace of time-homogeneous Sick-Sicker model",
      align = c("c", "c", "c", "c")) %>%
  
  kable_styling(latex_options = "hold_position")
```

```{r Sick-Sicker-Trace-TimeHom, echo = FALSE, fig.cap = 'Cohort trace of time-homogeneous cSTM', message = FALSE, warning = FALSE, out.width='100%'} 
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2, linetype = Var2)) +
  geom_line(size = 1.3) +
  scale_color_discrete(l = 50, name = "Health state") +
  scale_linetype_discrete(name = "Health state") +
  xlab("Cycle") +
  ylab("Proportion of the cohort") +
  theme_bw(base_size = 16) +
  theme()
#matplot(m.M, pch = v.n)
```

## Time-dependent cSTM
Just as the name suggests, time-dependent cSTMs have model characteristics (e.g. transition probabilities, outcomes) that vary over time. Time-dependency in the transition probabilities of cSTMs is a frequently encountered scenario and it can occur in at least two forms: (1)  dependence on the time since model start (e.g., age-specific background mortality) and (2) dependence on the duration spent in a state (i.e., state-residence). In the next sections, we describe these two types of time-dependency and provide a description of their implementation in R.

### Time dependency since model start
Transition probabilities that depend on the duration since model start can be straightforwardly accounted for by allowing the transition probability matrix to be a function of time, i.e. $\mathbf{P}_t$ for  $t = 1, \ldots, n_t$. 

$$
\mathbf{P}_t = 
 \begin{bmatrix}
p_{[1,1,t]} & p_{[1,2,t]} & \cdots & p_{[1,n_s,t]} \\
p_{[2,1,t]} & p_{[2,2,t]} & \cdots & p_{[2,n_s,t]} \\
\vdots    & \vdots  & \ddots & \vdots   \\ 
p_{[n_s,1,t]} & p_{[n_s,2,t]} & \cdots & p_{[n_s,n_s,t]} \\
\end{bmatrix}
$$

To illustrate the implementation of time-dependency since model start in the Sick-Sicker cSTM, we assume that the probability of death when healthy (`p.HD`) is a function of age. As the model progresses through the cycles, the cohort ages and therefore is exposed to a time-dependent risk of death. It is common to obtain input for this transition probability from  life tables in the form of age-specific mortality rates, $\mu(a)$, where $a$ refers to the age index. For this example, we create a vector `v.r.mu` of length $n_t$ with the age-specific background mortality rates obtained from the 2015 US life-tables[@Arias2017], corresponding to the age of the cohort at each time step. To compute the transition probability from Healthy to Dead for the Sick-Sicker model, we need to transform $\mu(a)$ to a transition probability assuming constant exponential rate within each year of age

$$
 p_{HDt} = 1 - \exp\left\{{-\mu(a_0 + t)}\right\},
$$ 

where $a_0 = 25$ is the starting age of the cohort. We will run the Sick-Sicker model for `r n.t` cycles; therefore, we select the background mortality rates for ages 25 to 110 by correctly indexing the `v.r.mu`. Thus, the variable in R is constructed as

```{r}
v.p.HDAge  <- 1 - exp(-v.r.mu[(age + 1) + 0:(n.t - 1)]) 
# age-specific probability of dying when Healthy 
# (all-cause mortality)
```

Because the risks of transitioning to death from the Sick and Sicker health states are defined relative to the mortality risk in the Healthy state `p.HD`, adding time-dependency on `p.HD` introduces time-dependency for all transition probabilities to death. To calculate time dependent probabilities of death for all cycles, we multiply the age-specific background mortality rate, `v.r.mu`, by the constant hazard ratios `hr.S1` and `hr.S2`, respectively, and then convert the resulting stage-specific mortality rates to probabilities as described previously. 

```{r}
# age-specific prob to die in Sick
v.p.S1DAge <- 1 - exp(-v.r.mu[(age + 1) + 0:(n.t - 1)] * hr.S1) 
# age-specific prob to die in Sicker
v.p.S2DAge <- 1 - exp(-v.r.mu[(age + 1) + 0:(n.t - 1)] * hr.S2) 
```

One way to incorporate the time-dependency of the above three probabilities into the model is to expand the dimensions of the matrix. We introduce the prefix "`a.`" to represent multidimensional arrays. Now we can create a transition probability array, `a.P`, with dimensions $n_s \times n_s \times n_t$, where the first two dimensions correspond to transitions between states and the third dimension to time. That is, the $t^{th}$ element in the third dimension corresponds to the transition probability matrix at cycle $t$. A visual representation of `a.P` is shown in Figure \@ref(fig:Array-Time-Dependent).

```{r Array-Time-Dependent, echo = FALSE, fig.cap = "3-dimensional array of the time-dependent Sick-Sicker model where transition probabilities depend on time since model start.", out.width= '100%'}
knitr::include_graphics("figs/3D-state-transition-array-sick-sicker-without-tunnels.png")
```

Filling `a.P` with the corresponding transition probabilities is done similarly to the `m.P` above, with the difference being that we now simultaneously specify the probabilities for all the cycles by leaving the index of the third dimension blank.  This operation will complete the corresponding positions of `a.P` with the $n_t + 1$ vector of probabilities (when the transition probability varies over time)or with $n_t + 1$ replications of the probability (when the probability is constant over time). In R, this  replication  can be automatically done when the assigned value does not match the dimensions of the element that it is assigned to.

```{r Sick-Sicker-TimeDep-P}
# Initialize array
a.P <- array(0, dim = c(n.s, n.s, n.t),
             dimnames = list(v.n, v.n, 0:(n.t - 1)))

# Fill in array
# From H
a.P["H", "H", ]   <- 1 - (p.HS1 + v.p.HDAge)
a.P["H", "S1", ]  <- p.HS1
a.P["H", "D", ]   <- v.p.HDAge
# From S1
a.P["S1", "H", ]  <- p.S1H
a.P["S1", "S1", ] <- 1 - (p.S1H + p.S1S2 + v.p.S1DAge)
a.P["S1", "S2", ] <- p.S1S2
a.P["S1", "D", ]  <- v.p.S1DAge
# From S2
a.P["S2", "S2", ] <- 1 - v.p.S2DAge
a.P["S2", "D", ]  <- v.p.S2DAge
# From D
a.P["D", "D", ]   <- 1
```

As mentioned before, each of the elements on the third dimension of `a.P` correspond to a transition matrix. For example, the transition matrix for 25-year-olds in the Sick-Sicker model is shown below

```{r Transition-Probability-Array-1}
a.P[, , 1] 
# print the transition probabilty matrix at cycle 0 
# (i.e. age = 25) stored in array a.P

```

To simulate the cohort over the $n_t$ cycles for the time-dependent cSTM, we update our cohort trace matrix `m.M`

```{r Init-Sick-Sicker-TimeDependent-Trace}
# Initialize cohort for time-dependent (td) cSTM
m.M <- matrix(0, 
               nrow = (n.t + 1), ncol = n.s, 
           dimnames = list(0:n.t, v.n))
m.M[1, ] <- v.m0 # store the initial state vector 
```

Calculation of the cohort's distribution across the health states is done similarly to the time-homogeneous model but we now also index the transition probability array `a.P` by $t$ to obtain the cycle-specific transition probability matrix, $P_t$.


```{r Sick-Sicker-TimeDependent-Solution}
# Iterative solution of time-dependent cSTM
for(t in 1:n.t){
m.M[t + 1, ] <- m.M[t, ] %*% a.P[, , t]
}
```

A graphical representation of the cohort trace for all cycles of the age-dependent cSTM is shown in Figure \@ref(fig:Sick-Sicker-Trace-TimeDep). We should note that a number of alternative approaches can be applied in the incorporation of age-dependency in cSTM. Other approaches involve the update of the time varying elements of the transition probability matrix $\mathbf{P}_t$ at each time point $t$. That would alleviate the need for the construction of the array `a.P`. This reduces computer memory requirements, but at the expense of increasing the number of operations in the update of $\mathbf{P}_t$ at every cycle. 

```{r Sick-Sicker-Trace-TimeDep, echo = FALSE, fig.cap = 'Cohort trace of the time-dependent cSTM.', message = FALSE, warning = FALSE} 
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2, linetype = Var2)) +
geom_line(size = 1.3) +
scale_color_discrete(l = 50, name = "Health state") +
scale_linetype_discrete(name = "Health state") +
xlab("Cycle") +
ylab("Proportion of the cohort") +
theme_bw(base_size = 16) +
theme()
```

### Time dependency based on state residence {#cSTM-state-residence}

Transition intensity between states or state rewards  can depend on the amount of time spent in a given state (state residence). A common example from cardiovascular disease is the mortality risk after stroke, where immediately after the event the risk is high, but as individuals survive post stroke, their risk of death drops. If time has an effect on the probability of transition from an initial state to any other state then the solution is similar to the section above. However, if probabilities depend on residence in any of the intermediate states, cSTM cannot easily account for such time dependency without a modification of the state space. One way to account for state residence dependency, is to expand the state space using transient states, referred to as *tunnel* states, where the cohort can only stay for a given number of cycles.

When addressing dependency on state residence with tunnel states, we need to create as many states as required for the temporal effect to be adequately captured in the model. For example, if dependency in a given state is assumed for $T$ cycles, then  $T$ new tunnel states need to be created. This will generate an expanded transition probability matrix (or array if time since model start matters too) of dimensions $n_{s_{T}} \times n_{s_{T}}$ (or $n_{s_{T}} \times n_{s_{T}} \times n_t$), where $n_{s_{T}}$ is the total number of health states after accounting for the expansion of a given state for $T$ tunnel states. Dependency to state residence could occur for as many as $n_t - 1$ cycles.

Figure \@ref(fig:STD-Sick-Sicker-tunnels) shows the state-transition diagram of the Sick-Sicker model that includes history dependence with tunnel states for S1.

```{r STD-Sick-Sicker-tunnels, echo = FALSE, fig.cap = "State-transition diagram of the Sick-Sicker model with tunnel states expanding the Sick state ($S1_1, S1_2,...,S1_{\tau}$).", out.width= '100%'}
                    knitr::include_graphics("figs/STD-Sick-Sicker-tunnels.png")
```
                    
To illustrate state residence dependency in the age-dependent Sick-Sicker model defined above, we assumed that the risk of progression from Sick to Sicker increases the longer a person has been sick. This increase follows a Weibull growth curve, calculated as 

$$
p_{S1_{\tau}S2} = \lambda \gamma \tau^{(\lambda-1)},
$$
where $\tau = 1, \ldots, T$ is the $\tau^{th}$ consecutive cycle (year) that a person has been in the Sick state, and $\lambda$ and $\gamma$ are the scale and shape parameters of the Weibull function, respectively. Since the whole cohort starts at the Healthy state, the earliest anyone can occupy the Sick state is at the second cycle. Therefore, we assume that state residence dependency can occur  from cycle 2 and through to the entire time horizon (i.e., $T=n_t - 1$). To implement this in R we create a supporting variable called `tunnelSize`, which accounts for the number of tunnel states needed (`n.t - 1`). Thus, the number of states will be `r n.t - 1` S1 tunnel states plus `n.s - 1` more states (H, S2, D) for a total of $n_{s_{T}}$ = `r (n.s - 1) + (n.t - 1)`. 

To implement the state residence dependency in the Sick-Sicker model using tunnels, we create one more variable `v.sickTunnel`, which  captures the tunnel names for the Sick state. Now we can accordingly update our variables `v.n` and `n.s`, the variables capturing the vector of state names and the number of states, to include the tunnel states.  

To implement the time-in-state dependency in Sick-Sicker model using tunnels, we create one more variable `v.sickTunnel`, which captures the tunnel names for the Sick state. Now we can accordingly update our variables `v.n` and `n.s`, the variables capturing the vector of state names and the number of states, to include the tunnel states.  


```{r}
tunnelSize <- n.t - 1 # Number of tunnels
# Name for tunnels states of Sick state
v.sickTunnel <- paste("S1_", seq(1, tunnelSize), "Yr", sep = "")
# Update variables for model with tunnels
v.n  <- c("H", v.sickTunnel, "S2", "D") # state names
n.s  <- length(v.n)                      # number of states
# Initialize first cycle of Markov trace 
# accounting for the tunnels
v.m0 <- c(1, rep(0, tunnelSize), 0, 0) 
```
                  
Based on the updated parameters, the time-dependent transition probability from Sick to Sicker based on a Weibull function, `p.S1S2Tunnels`, is defined
```{r}
# Weibull parameters
l <- 0.08 # scale
g <- 1.1  # shape
# Weibull probability function
p.S1S2Tunnels <- l * g * (1:tunnelSize) ^ {g - 1}
```

To implement the transition probability array for the age- and history-dependent Sick-Sicker model, we update the 3-dimensional array,`a.P`,  this time accounting for tunnels hence its dimensions are $n_{s_T} \times n_{s_T} \times n_t$. A visual representation of the  `a.P` of the Sick-Sicker model with tunnel states expanding the Sick state is shown in Figure \@ref(fig:Array-Time-Dependent-Tunnels)
                    
```{r Array-Time-Dependent-Tunnels, echo = FALSE, fig.cap = "3-dimensional array of the time-dependent Sick-Sicker model where time-varying transition probabilities affect the whole cohort with tunnel states expanding the Sick state.", out.width = '100%'}
knitr::include_graphics("figs/3D-state-transition-array-sick-sicker-tunnels.png")
```

```{r Init-Sick-Sicker-TimeDep-P-tunnels}
# Initialize array
a.P <- array(0, dim = c(n.s, n.s, n.t),
dimnames = list(v.n, v.n, 0:(n.t - 1)))
```
                    
Filling `a.P` with the corresponding transition probabilities is similar to above, with the difference being that we now fill the transition probabilities from all the tunnel states of the Sick state by iterating through all the tunnel states and assigning the corresponding disease progression transition probability. 

```{r Sick-Sicker-TimeDep-P-tunnels}
# Fill in array
# From H
a.P["H", "H", ]              <- 1 - (p.HS1 + v.p.HDAge)
a.P["H", v.sickTunnel[1], ]  <- p.HS1
a.P["H", "D", ]              <- v.p.HDAge
# From S1
for(i in 1:(tunnelSize - 1)){
a.P[v.sickTunnel[i], "H", ] <- p.S1H
a.P[v.sickTunnel[i], 
v.sickTunnel[i + 1], ]<-1-(p.S1H+p.S1S2Tunnels[i]+v.p.S1DAge)
a.P[v.sickTunnel[i], "S2", ] <- p.S1S2Tunnels[i]
a.P[v.sickTunnel[i], "D", ]  <- v.p.S1DAge
}
# From S2
a.P["S2", "S2", ] <- 1 - v.p.S2DAge
a.P["S2", "D", ]  <- v.p.S2DAge
# From D
a.P["D", "D", ] <- 1
```

To calculate state occupancy of the cohort over the $n_t$ cycles for the time-dependent cSTM with tunnels, we utilize a cohort trace matrix `m.M` with dimensions $n_t \times n_{S_T}$

```{r Init-Sick-Sicker-TimeDependent-Tunnels-Trace}
# Initialize cohort for time-dependent (td) cSTM
m.M <- matrix(0, 
nrow = (n.t + 1), ncol = n.s, 
dimnames = list(0:n.t, v.n))

m.M[1, ] <- v.m0
```

and then calculate the inner product as with the time-dependent model

```{r Sick-Sicker-TimeDependent-Tunnels-Solution}
# Iterative solution of time-dependent cSTM
for(t in 1:n.t){
m.M[t + 1, ] <- m.M[t, ] %*% a.P[, , t]
}
```

We can compute a cohort trace matrix that aggregates state occupancy across the tunnel Sick states for all cycles

```{r}
# Create aggregated trace
m.MTunnelsSum <- cbind(H = m.M[, "H"], 
S1 = rowSums(m.M[, 2:(tunnelSize + 1)]), 
S2 = m.M[, "S2"],
D  = m.M[, "D"])
```

## Epidemiological and economic outputs

cSTMs can be used to predict different epidemiological and economic outputs. In CEA, the final outcomes are typically the total QALYs and costs accrued in the cohort over the chosen time horizon. However,  epidemiological or other outcomes are often used for different purposes such as model calibration and validation. The most common epidemiological outcomes are survival, prevalence, incidence, average number of events and lifetime risk events.[@Siebert2012c] Below, we provide the epidemiological definition of these outcomes and how they can be calculated from an cSTM using the Sick-Sicker model as an example cSTM.[@Krijkamp2019]

## Survival probability

The survival function, $S(t) =  Pr(T>t)$ can be defined in a cSTM context as the proportion of the population that has not experienced the event of interest until some cycle $t$. To estimate $S(t)$ from the simulated cohort of the age-dependent Sick-Sicker model, we sum the proportion of the cohort that is one of the non-death states for all $n_t$ cycles in `m.M`.

```{r Sick-Sicker-TimeDependent-Surv}
v.surv <- 1 - m.M[,'D'] # vector with survival probability

```

and is shown in Figure \@ref(fig:Sick-Sicker-Surv-TimeDep).

```{r Sick-Sicker-Surv-TimeDep, echo = FALSE, fig.cap = 'Survival curve of time-dependent cSTM', message = FALSE, warning = FALSE} 
ggplot(data.frame(Cycle = 0:n.t, Survival = v.surv), 
aes(x = Cycle, y = Survival)) +
geom_line(size = 1.3) +
xlab("Cycle") +
ylab("Proportion alive") +
theme_bw(base_size = 16) +
theme()
```

## Prevalence
Point prevalence, the proportion of the living population in a given state at a given point in time[@Rothman2008h] can be calculated from the model for each time point $t$. To calculate $\text{prev}(t)_i$, we compute the ratio between the proportion of the cohort in state $i$ and the proportion alive at that cycle, given by the survival probability $S(t)$ defined above. The individual prevalence of the S1 and S2 health states, and the overall prevalence of sick individuals (i.e., S1 and S2) of the time-dependent Sick-Sicker cSTM at each time $t$ is computed as follows

```{r Sick-Sicker-TimeDependent-Prevalence}
 # vector with prevalence of Sick
v.prevS1   <- rowSums(m.M[, 2:(tunnelSize + 1)])/ v.surv  
# vector with prevalence of Sicker
v.prevS2   <- m.M[, "S2"] / v.surv 
# vector with prevalence of Sick and Sicker
v.prevS1S2 <- v.prevS1 + v.prevS2  
```
and are shown in Figure \@ref(fig:Sick-Sicker-Prev-TimeDep).

```{r Sick-Sicker-Prev-TimeDep, echo=FALSE, fig.cap='Prevalence of sick states of time-dependent STCM', message=FALSE, warning=FALSE, fig.pos="H"} 
ggplot(data.frame(Cycle = 0:n.t, 
                  States  = rep(c("S1", "S2", "S1 and S2"), each = (n.t + 1)), 
                  Prevalence = c(v.prevS1, v.prevS2, v.prevS1S2)), 
       aes(x = Cycle, y = Prevalence, color = States, linetype = States)) +
  geom_line(size = 1.3) +
  scale_y_continuous(labels = scales::percent) + 
  scale_color_discrete(name = "Health States", l = 50) +
  scale_linetype(name = "Health States") +
  xlab("Cycle") +
  ylab("Prevalence (%)") +
  theme_bw(base_size = 16) +
  theme()
```

## Life expectancy
Life expectancy (LE) refers to the expected number of years lived over a lifetime. LE is simply the area under the survival probability $S(t)$. In discrete time, is calculated as

$$
  LE = \sum_{t=0}^{n_t}{S(t)}.
$$

For example, in the time-dependent Sick-Sicker model, where we simulated a cohort over `r n.t` cycles, life expectancy `le`  calculated as follows:

```{r Life-expectancy, eval=FALSE}
le.td <- sum(v.S.td) # life expectancy

```

## State rewards
A state reward refers to a value assigned to individuals for being in a given state. In a cost-utility context, these could be either utilities or costs associated with remaining in a certain health state for a given period of time. The total expected reward of an outcome of interest at each cycle could be stored in the vector $\mathbf{o}$ of size $(n_t + 1)$. To calculate $\mathbf{o}$, we simply multiply the cohort trace matrix times a column *vector* of state rewards $r$ of the same dimension as the number of states ($n_s$)
$$
  \mathbf{o} = \mathbf{M}\mathbf{r}.
$$
To get the total outcome of interest over the $n_t$ cycles, we sum aross the elements of $\mathbf{o}$. 

For the Sick-Sicker model, we need to create a vector of utilities and costs under usual care, `v.u.UC` and `v.c.UC`, respectively. Each of these vectors contain the utilities and costs corresponding with being in each of the four health states shown in Table \@ref(tab:param-table).

```{r State-rewards-UC}
## Vector of state utilities under usual care
v.u.UC <- c( u.H, rep(u.S1, tunnelSize ), u.S2, u.D)

## Vector of state costs under usual care
v.c.UC <- c( c.H, rep( c.S1, tunnelSize ), c.S2, c.D)

```

To create the state-reward vectors under the new treatment, we account for the benefits and costs of the new treatment. For the vector of utilities under new treatment, `v.u.Trt`, we substitute the utility of being in state S1 under usual care, `u.S1`, with the utility associated to the benefit of the treatment in being in that state, `u.Trt`.

```{r State-rewards-U-Tr}
## Vector of state utilities under new treatment
v.u.Trt <- c(u.H, rep(u.Trt, tunnelSize ), u.S2, u.D)

```

To create the vector of state costs under the new treatment, `v.c.Trt`, we add the cost of treatment, `c.Trt`, to the state costs of S1 and S2.

```{r State-rewards-C-Tr}
## Vector of state costs under new treatment
v.c.Trt <- c( c.H, rep( c.S1 + c.Trt, tunnelSize), c.S2, c.D)
```

To compute the expected QALYs and costs for the time-dependent Sick-Sicker model under usual care and new treatment for all cycles, we multiply the cohort trace matrix $M$  with the rewards vectors

```{r Expected-outcomes-each-cycle}
## Vector of QALYs under usual care
v.qaly.UC <- m.M %*% v.u.UC
## Vector of costs under usual care
v.cost.UC <- m.M %*% v.c.UC
## Vector of QALYs under new treatment
v.qaly.Trt <- m.M %*% v.u.Trt
## Vector of costs under new treatment
v.cost.Trt <- m.M %*% v.c.Trt
```

To account for discounting, $\mathbf{o}$ is multiplied by a discounting vector $\mathbf{w}$ of size $n_t+1$ where each of its $t^{th}$ entry represents the discounting weight for the time period $t$ 

$$
  \mathbf{w} = \left[0, (1+d)^{-1}, (1+d)^{-2}, \cdots, (1+d)^{-n_t}\right],
$$

where $d$ is the cycle-length discount rate. Therefore, the total discounted outcomes $O_d$ are computed as

$$
 \mathbf{O}_d = \mathbf{o}^T\mathbf{w}
$$

The discount vectors for costs and QALYs for the Sick-Sicker model, `v.dwc` and `v.dwe`, respectively, are 

```{r Discount vectors}
# Discount weight 
# (equal discounting is assumed for costs and effects)
v.dwe <- v.dwc <- 1 / ((1 + d.e) ^ (0:(n.t)))  
```

The total expected discounted QALYs and costs under usual care and the new treatment are

```{r Expected-outcomes-all-cycles}
# Expected QALYs under usual care
qaly.UC <- t(v.qaly.UC) %*% v.dwe
# Expected costs under usual care
cost.UC <- t(v.cost.UC) %*% v.dwc
# Expected QALYs under new treatment
qaly.Trt <- t(v.qaly.Trt) %*% v.dwe
# Expected costs under new treatment
cost.Trt <- t(v.cost.Trt) %*% v.dwc
```

```{r Expected-outcomes, echo=FALSE, message=FALSE, warning=FALSE}
m.outcomes <- matrix(c(round(c(qaly.UC, qaly.Trt), 3),
                     c(dollar(c(cost.UC, cost.Trt)))),
                     ncol = 2, nrow = 2, 
                     dimnames = list(c("Usual care", "New treatment"),
                                     c("QALYs", "Costs")))
kable(m.outcomes, 
     # format = ifelse(doc.type == "docx", "markdown", "latex"),  
      booktabs = TRUE,
      caption = "Total expected discounted QALYs and costs of the age-dependent Sick-Sicker model under usual care and the new treatment", 
      align = c("l", "c", "c")) %>%
  kable_styling(latex_options = "hold_position")
```

The total expected QALYs and costs for the Sick-Sicker model under usual care and the new treatment are shown in Table \@ref(tab:Expected-outcomes). The total expected QALYs for usual care and the new treatment are `r round(qaly.UC, 3)` and `r round(qaly.Trt, 3)`, respectively. The total expected Costs for usual care and the new treatment are `r dollar(cost.UC)` and `r dollar(cost.Trt)`, respectively.
