# Discount QALYS by multiplying the QALYs vector with discount weights (v_dw)
v_te_d <-  t(v_tu) %*% v_dwe
results <- data.frame( "Total Discounted Cost" = v_tc_d,
"Life Expectancy" = v_le,
"Total Discounted QALYs" = v_te_d,
check.names = F)
results
rm(list = ls())      # clear memory (removes all the variables from the workspace)
# no packages required
source("Functions.R")
# Strategy names
v_names_str <- c("Base Case")
# Number of strategies
n_str <- length(v_names_str)
# Markov model parameters
v_n  <- c("Healthy", "Sick", "Dead")    # state names
n_states <- length(v_n)                 # number of states
n_t  <- 60                              # number of cycles
p_HD <- seq(0.003, 0.01, length.out = n_t)  # probabilities of dying when sick (age-dependent) - this is now a sequence of numbers, officially v_HD
p_HS <- 0.05                                # probability of becoming sick when healthy, conditioned on not dying
p_SD <- 0.1                                 # probability of dying when sick
# Costs and utilities
c_H  <- 400                             # cost of one cycle in healthy state
c_S  <- 1000                            # cost of one cycle in sick state
c_D  <- 0                               # cost of one cycle in dead state
u_H  <- 0.8                             # utility when healthy
u_S  <- 0.5                             # utility when sick
u_D  <- 0                               # utility when dead
d_e <- d_c <- 0.03                      # equal discount of costs and QALYs by 3%
# calculate discount weights for costs for each cycle based on discount rate d_c
v_dwc <- 1 / (1 + d_e) ^ (0:n_t)
# calculate discount weights for effectiveness for each cycle based on discount rate d_e
v_dwe <- 1 / (1 + d_c) ^ (0:n_t)
# Strategy names
v_names_str <- c("Base Case")
# Number of strategies
n_str <- length(v_names_str)
# Markov model parameters
v_n  <- c("Healthy", "Sick", "Dead")    # state names
n_states <- length(v_n)                 # number of states
n_t  <- 60                              # number of cycles
p_HD <- seq(0.003, 0.01, length.out = n_t)  # probabilities of dying when sick (age-dependent) - this is now a sequence of numbers, officially v_HD
p_HS <- 0.05                                # probability of becoming sick when healthy, conditioned on not dying
p_SD <- 0.1                                 # probability of dying when sick
# Costs and utilities
c_H  <- 400                             # cost of one cycle in healthy state
c_S  <- 1000                            # cost of one cycle in sick state
c_D  <- 0                               # cost of one cycle in dead state
u_H  <- 0.8                             # utility when healthy
u_S  <- 0.5                             # utility when sick
u_D  <- 0                               # utility when dead
d_e <- d_c <- 0.03                      # equal discount of costs and QALYs by 3%
# calculate discount weights for costs for each cycle based on discount rate d_c
v_dwc <- 1 / (1 + d_e) ^ (0:n_t)
# calculate discount weights for effectiveness for each cycle based on discount rate d_e
v_dwe <- 1 / (1 + d_c) ^ (0:n_t)
# create the cohort trace
m_M <- matrix(NA,
nrow = n_t + 1 ,  # create Markov trace (n.t + 1 because R doesn't
# understand cycle 0)
ncol = n_states,
dimnames = list(0:n_t, v_n))
m_M[1, ] <- c(1, 0, 0)          # initialize first cycle of Markov trace
# create the transition probability array
a_P <- array(0,                                    # Create 3-D array
dim = c(n_states, n_states, n_t),
dimnames = list(v_n, v_n, 0:(n_t - 1))) # name the dimensions of the array
# create the transition probability array
a_P <- array(0,                                      # Create 3-D array
dim = c(n_states, n_states, n_t),
dimnames = list(v_n, v_n, 0:(n_t - 1))) # name the dimensions of the array
# from Healthy
a_P["Healthy", "Healthy", ] <- (1 - p_HD) * (1 - p_HS)
a_P["Healthy", "Sick", ]    <- (1 - p_HD) * p_HS
a_P["Healthy", "Dead", ]    <- p_HD
# from Sick
a_P["Sick", "Sick", ] <- 1 - p_SD
a_P["Sick", "Dead", ] <- p_SD
# from Dead
a_P["Dead", "Dead", ] <- 1
# create the cohort trace
m_M <- matrix(NA,
nrow = n_t + 1 ,  # create Markov trace (n.t + 1 because R doesn't
# understand cycle 0)
ncol = n_states,
dimnames = list(0:n_t, v_n))
m_M[1, ] <- c(1, 0, 0)          # initialize first cycle of Markov trace
# create the transition probability array
a_P <- array(0,                                      # Create 3-D array
dim = c(n_states, n_states, n_t),
dimnames = list(v_n, v_n, 0:(n_t - 1))) # name the dimensions of the array
# from Healthy
a_P["Healthy", "Healthy", ] <- (1 - p_HD) * (1 - p_HS)
a_P["Healthy", "Sick", ]    <- (1 - p_HD) * p_HS
a_P["Healthy", "Dead", ]    <- p_HD
# from Sick
a_P["Sick", "Sick", ] <- 1 - p_SD
a_P["Sick", "Dead", ] <- p_SD
# from Dead
a_P["Dead", "Dead", ] <- 1
# Check that transition probabilities are [0, 1]
check_transition_probability(a_P, verbose = TRUE)
# Check that all rows sum to 1
check_sum_of_transition_array(a_P, n_states = n_states, n_t = n_t, verbose = TRUE)
for (t in 1:n_t){ # t<-1                  # loop through the number of cycles
m_M[t + 1, ] <- m_M[t, ] %*% a_P[, , t] # estimate the Markov trace for cycle t + 1
# using the t-th matrix from the
# probability array
}
head(m_M)  # print the first lines of the matrix
rm(list = ls())      # clear memory (removes all the variables from the workspace)
# no packages required
source("Functions.R")
# Strategy names
v_names_str <- c("Base Case")
# Number of strategies
n_str <- length(v_names_str)
# Markov model parameters
v_n  <- c("Healthy", "Sick", "Dead")    # state names
n_states <- length(v_n)                 # number of states
n_t  <- 60                              # number of cycles
p_HD <- seq(0.003, 0.01, length.out = n_t)  # probabilities of dying when sick (age-dependent) - this is now a sequence of numbers, officially v_HD
p_HS <- 0.05                                # probability of becoming sick when healthy, conditioned on not dying
p_SD <- 0.1                                 # probability of dying when sick
# Costs and utilities
c_H  <- 400                             # cost of one cycle in healthy state
c_S  <- 1000                            # cost of one cycle in sick state
c_D  <- 0                               # cost of one cycle in dead state
u_H  <- 0.8                             # utility when healthy
u_S  <- 0.5                             # utility when sick
u_D  <- 0                               # utility when dead
d_e <- d_c <- 0.03                      # equal discount of costs and QALYs by 3%
# calculate discount weights for costs for each cycle based on discount rate d_c
v_dwc <- 1 / (1 + d_e) ^ (0:n_t)
# calculate discount weights for effectiveness for each cycle based on discount rate d_e
v_dwe <- 1 / (1 + d_c) ^ (0:n_t)
# create the cohort trace
m_M <- matrix(NA,
nrow = n_t + 1 ,  # create Markov trace (n.t + 1 because R doesn't
# understand cycle 0)
ncol = n_states,
dimnames = list(0:n_t, v_n))
m_M[1, ] <- c(1, 0, 0)          # initialize first cycle of Markov trace
# create the transition probability array
a_P <- array(0,                                      # Create 3-D array
dim = c(n_states, n_states, n_t),
dimnames = list(v_n, v_n, 0:(n_t - 1))) # name the dimensions of the array
# from Healthy
a_P["Healthy", "Healthy", ] <- (1 - p_HD) * (1 - p_HS)
a_P["Healthy", "Sick", ]    <- (1 - p_HD) * p_HS
a_P["Healthy", "Dead", ]    <- p_HD
# from Sick
a_P["Sick", "Sick", ] <- 1 - p_SD
a_P["Sick", "Dead", ] <- p_SD
# from Dead
a_P["Dead", "Dead", ] <- 1
# Check that transition probabilities are [0, 1]
check_transition_probability(a_P, verbose = TRUE)
# Check that all rows sum to 1
check_sum_of_transition_array(a_P, n_states = n_states, n_t = n_t, verbose = TRUE)
for (t in 1:n_t){ # t<-1                  # loop through the number of cycles
m_M[t + 1, ] <- m_M[t, ] %*% a_P[, , t] # estimate the Markov trace for cycle t + 1
# using the t-th matrix from the
# probability array
}
head(m_M)  # print the first lines of the matrix
# create a plot of the data
matplot(m_M, type = 'l',
ylab = "Probability of state occupancy",
xlab = "Cycle",
main = "Cohort Trace", lwd = 2)
# add a legend to the graph
legend("right", v_n, col = c("black", "red", "green"), lty = 1:3, bty = "n")
v_os <- 1 - m_M[, "Dead"]                  # calculate the overall survival (OS) probability
v_os <- rowSums(m_M[, 1:2])                # alternative way of calculating the OS probability
# create a simple plot showing the OS
plot(v_os, type = 'l',
ylim = c(0, 1),
ylab = "Survival probability",
xlab = "Cycle",
main = "Overall Survival")
# add grid
grid(nx = n_t, ny = 10,
col = "lightgray", lty = "dotted", lwd = par("lwd"),
equilogs = TRUE)
v_le <- sum(v_os)           # summing probablity of OS over time  (i.e. life expectancy)
v_prev <- m_M[, "Sick"]/v_os
plot(v_prev,
ylim = c(0, 1),
ylab = "Prevalence",
xlab = "Cycle",
main = "Disease prevalence")
# per cycle
# calculate expected costs by multiplying m_M with the cost vector for the different
# health states
v_tc <- m_M %*% c(c_H, c_S, c_D)
# calculate expected QALYs by multiplying m_M with the utilities for the different
# health states
v_tu <- m_M %*% c(u_H, u_S, u_D)
# Discount costs by multiplying the cost vector with discount weights (v_dw)
v_tc_d <-  t(v_tc) %*% v_dwc
# Discount QALYS by multiplying the QALYs vector with discount weights (v_dw)
v_te_d <-  t(v_tu) %*% v_dwe
results <- data.frame( "Total Discounted Cost" = v_tc_d,
"Life Expectancy" = v_le,
"Total Discounted QALYs" = v_te_d,
check.names = F)
results
# Strategy names
v_names_str <- c("Base Case")
# Number of strategies
n_str <- length(v_names_str)
# Markov model parameters
v_n  <- c("Healthy", "Sick", "Dead")  # state names
n_states  <- length(v_n)              # number of states
n_t  <- 60                            # number of cycles
# Tunnels
n_tunnel_size <- n_t
# Sick state
v_Sick_tunnels <- paste("Sick_", seq(1, n_tunnel_size), "Yr", sep = "")
# Create variables for time-dependent model
v_n_tunnels  <- c("Healthy", v_Sick_tunnels, "Dead")  # state names
n_states_tunnels  <- length(v_n_tunnels)              # number of states
p_HD <- seq(0.003, 0.01, length.out = n_t)  # probability of dying when sick (age-dependent) - this is a sequence - officially v_HD
p_HS <- 0.05                                # probability of becoming sick when healthy, conditioned on not dying
p_SD <- 0.1                                 # probability of dying when sick
# Weibull parameters
l <- 0.08
g <- 1.1
p_SD <- l*g*(1:n_tunnel_size)^{g-1}         # probability of dying when sick (time-in-state dependent)
# Costs and utilities
c_H  <- 400                                 # cost of one cycle in healthy state
c_S  <- 1000                                # cost of one cycle in sick state
c_D  <- 0                                   # cost of one cycle in dead state
u_H  <- 0.8                                 # utility when healthy
u_S  <- 0.5                                 # utility when sick
u_D  <- 0                                   # utility when dead
d_e <- d_c <- 0.03                          # equal discount of costs and QALYs by 3%
# calculate discount weights for costs for each cycle based on discount rate d_c
v_dwc <- 1 / (1 + d_e) ^ (0:n_t)
# calculate discount weights for effectiveness for each cycle based on discount rate d_e
v_dwe <- 1 / (1 + d_c) ^ (0:n_t)
m_M <- matrix(NA,
nrow = n_t + 1,  # create Markov trace (n_t + 1 because R doesn't understand
# Cycle 0)
ncol = n_states_tunnels,
dimnames = list(0:n_t, v_n_tunnels))
# The cohort starts as healthy
# initialize first cycle of Markov trace accounting for the tunnels
m_M[1, ] <- c(1, rep(0, n_tunnel_size), 0)
# create the transition probability array
a_P <- array(0,                                          # Create 3-D array
dim = c(n_states_tunnels, n_states_tunnels, n_t),
dimnames = list(v_n_tunnels, v_n_tunnels, 0:(n_t-1)))
# from Healthy
a_P["Healthy", "Healthy", ]  <- (1 - p_HD)* (1 - p_HS)
a_P["Healthy", "Sick_1Yr", ] <- (1 - p_HD) * p_HS
a_P["Healthy", "Dead", ]     <- p_HD
# from Sick
for(i in 1:(n_tunnel_size - 1)){
a_P[v_Sick_tunnels[i], v_Sick_tunnels[i + 1], ] <- 1 - p_SD[i]
a_P[v_Sick_tunnels[i], "Dead", ] <- p_SD[i]
}
a_P[v_Sick_tunnels[n_tunnel_size], v_Sick_tunnels[n_tunnel_size], ] <- 1 - p_SD[n_tunnel_size]
a_P[v_Sick_tunnels[n_tunnel_size], "Dead", ] <- p_SD[n_tunnel_size]
# from Dead
a_P["Dead", "Dead", ] <- 1
# Check that transition probabilities are [0, 1]
check_transition_probability(a_P, verbose = TRUE)
source("Functions.R")
# Check that transition probabilities are [0, 1]
check_transition_probability(a_P, verbose = TRUE)
# Check that all rows sum to 1
check_sum_of_transition_array(a_P, n_states = n_states_tunnels, n_t = n_t, verbose = TRUE)
for (t in 1:n_t) {                         # loop through the number of cycles
m_M[t + 1, ] <- m_M[t, ] %*% a_P[, , t]  # estimate the Markov trace for cycle t + 1
# using the t-th matrix from the
# probability array
}
head(m_M)
m_M_tunnels <- cbind(Healthy = m_M[, "Healthy"],
Sick = rowSums(m_M[, 2:(n_tunnel_size + 1)]),
Dead = m_M[, "Dead"])
head(m_M_tunnels) # show the first rows of the aggregated Markov trace
rm(list = ls())      # clear memory (removes all the variables from the workspace)
# no packages required
source("Functions.R")
# Strategy names
v_names_str <- c("Base Case")
# Number of strategies
n_str <- length(v_names_str)
# Markov model parameters
v_n  <- c("Healthy", "Sick", "Dead")  # state names
n_states  <- length(v_n)              # number of states
n_t  <- 60                            # number of cycles
# Tunnels
n_tunnel_size <- n_t
# Sick state
v_Sick_tunnels <- paste("Sick_", seq(1, n_tunnel_size), "Yr", sep = "")
# Create variables for time-dependent model
v_n_tunnels  <- c("Healthy", v_Sick_tunnels, "Dead")  # state names
n_states_tunnels  <- length(v_n_tunnels)              # number of states
p_HD <- seq(0.003, 0.01, length.out = n_t)  # probability of dying when sick (age-dependent) - this is a sequence - officially v_HD
p_HS <- 0.05                                # probability of becoming sick when healthy, conditioned on not dying
p_SD <- 0.1                                 # probability of dying when sick
# Weibull parameters
l <- 0.08
g <- 1.1
p_SD <- l*g*(1:n_tunnel_size)^{g-1}         # probability of dying when sick (time-in-state dependent)
# Costs and utilities
c_H  <- 400                                 # cost of one cycle in healthy state
c_S  <- 1000                                # cost of one cycle in sick state
c_D  <- 0                                   # cost of one cycle in dead state
u_H  <- 0.8                                 # utility when healthy
u_S  <- 0.5                                 # utility when sick
u_D  <- 0                                   # utility when dead
d_e <- d_c <- 0.03                          # equal discount of costs and QALYs by 3%
# calculate discount weights for costs for each cycle based on discount rate d_c
v_dwc <- 1 / (1 + d_e) ^ (0:n_t)
# calculate discount weights for effectiveness for each cycle based on discount rate d_e
v_dwe <- 1 / (1 + d_c) ^ (0:n_t)
m_M <- matrix(NA,
nrow = n_t + 1,  # create Markov trace (n_t + 1 because R doesn't understand
# Cycle 0)
ncol = n_states_tunnels,
dimnames = list(0:n_t, v_n_tunnels))
# The cohort starts as healthy
# initialize first cycle of Markov trace accounting for the tunnels
m_M[1, ] <- c(1, rep(0, n_tunnel_size), 0)
# create the transition probability array
a_P <- array(0,
dim = c(n_states_tunnels, n_states_tunnels, n_t),
dimnames = list(v_n_tunnels, v_n_tunnels, 0:(n_t-1)))
# from Healthy
a_P["Healthy", "Healthy", ]  <- (1 - p_HD)* (1 - p_HS)
a_P["Healthy", "Sick_1Yr", ] <- (1 - p_HD) * p_HS
a_P["Healthy", "Dead", ]     <- p_HD
# from Sick
for(i in 1:(n_tunnel_size - 1)){
a_P[v_Sick_tunnels[i], v_Sick_tunnels[i + 1], ] <- 1 - p_SD[i]
a_P[v_Sick_tunnels[i], "Dead", ] <- p_SD[i]
}
a_P[v_Sick_tunnels[n_tunnel_size], v_Sick_tunnels[n_tunnel_size], ] <- 1 - p_SD[n_tunnel_size]
a_P[v_Sick_tunnels[n_tunnel_size], "Dead", ] <- p_SD[n_tunnel_size]
# from Dead
a_P["Dead", "Dead", ] <- 1
# Check that transition probabilities are [0, 1]
check_transition_probability(a_P, verbose = TRUE)
# Check that all rows sum to 1
check_sum_of_transition_array(a_P, n_states = n_states_tunnels, n_t = n_t, verbose = TRUE)
for (t in 1:n_t) {                         # loop through the number of cycles
m_M[t + 1, ] <- m_M[t, ] %*% a_P[, , t]  # estimate the Markov trace for cycle t + 1
# using the t-th matrix from the
# probability array
}
head(m_M)
m_M_tunnels <- cbind(Healthy = m_M[, "Healthy"],
Sick = rowSums(m_M[, 2:(n_tunnel_size + 1)]),
Dead = m_M[, "Dead"])
head(m_M_tunnels) # show the first rows of the aggregated Markov trace
# create a plot of the data
matplot(m_M_tunnels, type = 'l',
ylab = "Probability of state occupancy",
xlab = "Cycle",
main = "Cohort Trace", lwd = 2)
# add a legend to the graph
legend("right", v_n, col = c("black", "red", "green"), lty = 1:3, bty = "n")
v_os <- 1 - m_M_tunnels[, "Dead"]    # calculate the overall survival (OS) probability
v_os <- rowSums(m_M_tunnels[, 1:2])  # alternative way of calculating the OS probability
# create a simple plot showing the OS
plot(v_os, type = 'l',
ylim = c(0, 1),
ylab = "Survival probability",
xlab = "Cycle",
main = "Overall Survival")
# add grid
grid(nx = n_t, ny = 10, col = "lightgray", lty = "dotted", lwd = par("lwd"), equilogs = TRUE)
v_le <- sum(v_os)           # summing probablity of OS over time  (i.e. life expectancy)
v_prev <- m_M_tunnels[, "Sick"]/v_os
plot(v_prev,
ylim = c(0, 1),
ylab = "Prevalence",
xlab = "Cycle",
main = "Disease prevalence")
# per cycle
# calculate expected costs by multiplying m_M with the cost vector for the different
# health states
v_tc <- m_M_tunnels %*% c(c_H, c_S, c_D)
# calculate expected QALYs by multiplying m_M with the utilities for the different
# health states
v_tu <- m_M_tunnels %*% c(u_H, u_S, u_D)
# Discount costs  by multiplying the cost vector with discount weights (v_dw)
v_tc_d <-  t(v_tc) %*% v_dwc
# Discount QALYS  by multiplying the QALYs vector with discount weights (v_dw)
v_te_d <-  t(v_tu) %*% v_dwe
results <- data.frame( "Total Discounted Cost" = v_tc_d,
"Life Expectancy" = v_le,
"Total Discounted QALYs" = v_te_d,
check.names = F)
results
rm(list = ls())      # clear memory (removes all the variables from the workspace)
if (!require('pacman')) install.packages('pacman'); library(pacman) # use this package to conveniently install other packages
# load (install if required) packages from CRAN
p_load("diagram")
source("Functions.R")
# Strategy names
v_names_str <- c("Base Case")
# Number of strategies
n_str <- length(v_names_str)
# Markov model parameters
v_n  <- c("Healthy", "Sick", "Dead")  # state names
n_states  <- length(v_n)              # number of states
n_t  <- 60                            # number of cycles
v_init <- c(1, 0, 0)                  # initial cohort distribution
p_HD <- 0.02                          # probability of dying when healthy
p_HS <- 0.05                          # probability of becoming sick when healthy, conditioned on not dying
p_SD <- 0.1                           # probability of dying when sick
# Costs and utilities
c_H  <- 400                           # cost of one cycle in healthy state
c_S  <- 1000                          # cost of one cycle in sick state
c_D  <- 0                             # cost of one cycle in dead state
u_H  <- 0.8                           # utility when healthy
u_S  <- 0.5                           # utility when sick
u_D  <- 0                             # utility when dead
d_e  <- d_c <- 0.03                   # discount rate per cycle equal discount of costs and QALYs by 3%
# calculate discount weights for costs for each cycle based on discount rate d_c
v_dwc <- 1 / (1 + d_e) ^ (0:n_t)
# calculate discount weights for effectiveness for each cycle based on discount rate d_e
v_dwe <- 1 / (1 + d_c) ^ (0:n_t)
m_P_diag <- matrix(0, nrow = n_states, ncol = n_states, dimnames = list(v_n, v_n))
m_P_diag["Healthy", "Sick" ]     = ""
m_P_diag["Healthy", "Dead" ]     = ""
m_P_diag["Healthy", "Healthy" ]  = ""
m_P_diag["Sick"   , "Dead" ]     = ""
m_P_diag["Sick"   , "Sick" ]     = ""
m_P_diag["Dead"   , "Dead" ]     = ""
layout.fig <- c(2, 1)
plotmat(t(m_P_diag), t(layout.fig), self.cex = 0.5, curve = 0, arr.pos = 0.8,
latex = T, arr.type = "curved", relsize = 0.85, box.prop = 0.8,
cex = 0.8, box.cex = 0.7, lwd = 1)
# create the cohort trace
m_M <- matrix(NA,
nrow = n_t + 1 ,  # create Markov trace (n.t + 1 because R doesn't
# understand Cycle 0)
ncol = n_states,
dimnames = list(0:n_t, v_n))
m_M[1, ] <- c(1, 0, 0)          # initialize first cycle of Markov trace
# create the transition probability matrix
m_P  <- matrix(0,
nrow = n_states, ncol = n_states,
dimnames = list(v_n, v_n)) # name the columns and rows of the transition
# probability matrix
m_P
# from Healthy
m_P["Healthy", "Healthy"] <- (1 - p_HD) * (1 - p_HS)
m_P["Healthy", "Sick"]    <- (1 - p_HD) * p_HS
m_P["Healthy", "Dead"]    <- p_HD
# from Sick
m_P["Sick", "Sick"] <- 1 - p_SD
m_P["Sick", "Dead"] <- p_SD
# from Dead
m_P["Dead", "Dead"] <- 1
# print matrix
m_P
## Check if transition probability matrices are valid
# Check that transition probabilities are [0, 1]
check_transition_probability(m_P, verbose = TRUE)
# Check that all rows sum to 1
check_sum_of_transition_array(m_P, n_states = n_states, n_t = n_t, verbose = TRUE)
for (t in 1:n_t){                   # loop through the number of cycles
m_M[t + 1, ] <- m_M[t, ] %*% m_P  # estimate the state vector for the next cycle (t + 1)
}
matplot(m_M, type = 'l',
ylab = "Probability of state occupancy",
xlab = "Cycle",
main = "Cohort Trace", lwd = 3)                 # create a plot of the data
legend("right", v_n, col = c("black", "red", "green"),
lty = 1:3, bty = "n")                            # add a legend to the graph
abline(v = which.max(m_M[, "Sick"]), col = "gray") # plot a vertical line that helps identifying at which cycle the prevalence of sick is highest.
v_os <- 1 - m_M[, "Dead"]             # calculate the overall survival (OS) probability
v_os <- rowSums(m_M[, 1:2])           # alternative way of calculating the OS probability
plot(v_os, type = 'l',
ylim = c(0, 1),
ylab = "Survival probability",
xlab = "Cycle",
main = "Overall Survival")       # create a simple plot showing the OS
# add grid
grid(nx = n_t, ny = 10, col = "lightgray", lty = "dotted", lwd = par("lwd"),
equilogs = TRUE)
v_le <- sum(v_os)           # summing probablity of OS over time  (i.e. life expectancy)
v_prev <- m_M[, "Sick"]/v_os
plot(v_prev,
ylim = c(0, 1),
ylab = "Prevalence",
xlab = "Cycle",
main = "Disease prevalence")
# per cycle
# calculate expected costs by multiplying m_M with the cost vector for the different
# health states
v_tc <- m_M %*% c(c_H, c_S, c_D)
# calculate expected QALYs by multiplying m_M with the utilities for the different
# health states
v_tu <- m_M %*% c(u_H, u_S, u_D)
# Discount costs by multiplying the cost vector with discount weights (v_dw)
v_tc_d <-  t(v_tc) %*% v_dwc
# Discount QALYS by multiplying the QALYs vector with discount weights (v_dw)
v_te_d <-  t(v_tu) %*% v_dwe
results <- data.frame( "Total Discounted Cost" = v_tc_d,
"Life Expectancy" = v_le,
"Total Discounted QALYs" = v_te_d,
check.names = F)
results
