p_HD     = 0.02,  # probability of dying when healthy
p_HS     = 0.05,  # probability of becoming sick when healthy, conditioned on not dying
p_HS_trt = 0.03,  # probability of becoming sick when healthy, conditioned on not dying
p_SD     = 0.1,   # probability of dying when sick
c_H      = 400,   # cost of one cycle in healthy state
c_S      = 1000,  # cost of one cycle in sick state
c_D      = 0,     # cost of one cycle in dead state
c_trt    = 500,   # cost of treatment (per cycle)
u_H      = 0.8,   # utility when healthy
u_S      = 0.5,   # utility when sick
u_D      = 0,     # utility when dead
d_e      = 0.03,  # discount factor for effectiveness
d_c      = 0.03   # discount factor for costs
))
# store the parameter names into a vector
v_names_params <- names(l_params_all)
source("Functions_markov_3state.R")
# Test function
calculate_ce_out(l_params_all)
l_params_all <- as.list(data.frame(
p_HD     = 0.02,  # probability of dying when healthy
p_HS     = 0.05,  # probability of becoming sick when healthy, conditioned on not dying
p_HS_trt = 0.03,  # probability of becoming sick when healthy, conditioned on not dying
p_SD     = 0.1,   # probability of dying when sick
c_H      = 400,   # cost of one cycle in healthy state
c_S      = 1000,  # cost of one cycle in sick state
c_D      = 0,     # cost of one cycle in dead state
c_trt    = 1500,  # cost of treatment (per cycle)
u_H      = 0.8,   # utility when healthy
u_S      = 0.5,   # utility when sick
u_D      = 0,     # utility when dead
d_e      = 0.03,  # discount factor for effectiveness
d_c      = 0.03   # discount factor for costs
))
# store the parameter names into a vector
v_names_params <- names(l_params_all)
source("Functions_markov_3state.R")
# Test function
calculate_ce_out(l_params_all)
options(scipen = 999) # disabling scientific notation in R
# dataframe containing all parameters, their base case values, and the min and
# max values of the parameters of interest
df_params_owsa <- data.frame(pars = c("c_trt", "c_S", "u_H"),
min  = c(500 , 500, 0.6),   # min parameter values
max  = c(3000, 2000, 1)     # max parameter values
)
owsa_nmb  <- run_owsa_det(params_range     = df_params_owsa,    # dataframe with parameters for OWSA
params_basecase  = l_params_all,      # list with all parameters
nsamp            = 100,               # number of parameter values
FUN              = calculate_ce_out,  # function to compute outputs
outcomes         = c("NMB"),          # output to do the OWSA on
strategies       = v_names_str,       # names of the strategies
n_wtp            = 10000)             # extra argument to pass to FUN
plot(owsa_nmb, txtsize = 10, n_x_ticks = 4,
facet_scales = "free") +
theme(legend.position = "bottom")
owsa_opt_strat(owsa = owsa_nmb, txtsize = 10)
owsa_tornado(owsa = owsa_nmb, txtsize = 12)
options(scipen = 999) # disabling scientific notation in R
# dataframe containing all parameters, their base case values, and the min and
# max values of the parameters of interest
df_params_owsa <- data.frame(pars = c("c_trt", "c_S", "u_H"),
min  = c(500 , 500, 0.6),   # min parameter values
max  = c(3000, 2000, 1)     # max parameter values
)
owsa_nmb  <- run_owsa_det(params_range     = df_params_owsa,    # dataframe with parameters for OWSA
params_basecase  = l_params_all,      # list with all parameters
nsamp            = 100,               # number of parameter values
FUN              = calculate_ce_out,  # function to compute outputs
outcomes         = c("NMB"),          # output to do the OWSA on
strategies       = v_names_str,       # names of the strategies
n_wtp            = 20000)             # extra argument to pass to FUN
plot(owsa_nmb, txtsize = 10, n_x_ticks = 4,
facet_scales = "free") +
theme(legend.position = "bottom")
owsa_opt_strat(owsa = owsa_nmb, txtsize = 10)
options(scipen = 999) # disabling scientific notation in R
# dataframe containing all parameters, their base case values, and the min and
# max values of the parameters of interest
df_params_owsa <- data.frame(pars = c("c_trt", "c_S", "u_H"),
min  = c(500 , 500, 0.6),   # min parameter values
max  = c(3000, 2000, 1)     # max parameter values
)
owsa_nmb  <- run_owsa_det(params_range     = df_params_owsa,    # dataframe with parameters for OWSA
params_basecase  = l_params_all,      # list with all parameters
nsamp            = 100,               # number of parameter values
FUN              = calculate_ce_out,  # function to compute outputs
outcomes         = c("NMB"),          # output to do the OWSA on
strategies       = v_names_str,       # names of the strategies
n_wtp            = 2000)             # extra argument to pass to FUN
plot(owsa_nmb, txtsize = 10, n_x_ticks = 4,
facet_scales = "free") +
theme(legend.position = "bottom")
owsa_opt_strat(owsa = owsa_nmb, txtsize = 10)
rm(list = ls())      # clear memory (removes all the variables from the workspace)
if (!require('pacman')) install.packages('pacman'); library(pacman) # use this package to conveniently install other packages
# load (install if required) packages from CRAN
p_load("diagram")
source("Functions.R")
# Strategy names
v_names_str <- c("Standard of Care", "Treatment")
# Number of strategies
n_str <- length(v_names_str)
# Markov model parameters
v_n  <- c("Healthy", "Sick", "Dead")    # state names
n_states  <- length(v_n)                # number of states
n_t  <- 60                              # number of cycles
v_init <- c(1, 0, 0)                    # initial cohort distribution
# Transition probabilities
p_HD <- 0.02                            # probability of dying when healthy
p_HS <- 0.05                            # probability of becoming sick when healthy, conditioned on not dying
p_HS_trt <- 0.03                        # probability of becoming sick when healthy, conditioned on not dying, under treatment
p_SD <- 0.1                             # probability of dying when sick
# Costs and utilities
c_H   <- 400                            # cost of one cycle in healthy state
c_S   <- 1000                           # cost of one cycle in sick state
c_D   <- 0                              # cost of one cycle in dead state
c_trt <- 800                            # cost of treatment (per cycle)
u_H   <- 0.8                            # utility when healthy
u_S   <- 0.5                            # utility when sick
u_D   <- 0                              # utility when dead
d_e   <- d_c <- 0.03                    # discount rate per cycle equal discount of costs and QALYs by 3%
# calculate discount weights for costs for each cycle based on discount rate d_c
v_dwc <- 1 / (1 + d_e) ^ (0:n_t)
# calculate discount weights for effectiveness for each cycle based on discount rate d_e
v_dwe <- 1 / (1 + d_c) ^ (0:n_t)
m_P_diag <- matrix(0, nrow = n_states, ncol = n_states, dimnames = list(v_n, v_n))
m_P_diag["Healthy", "Sick" ]     = ""
m_P_diag["Healthy", "Dead" ]     = ""
m_P_diag["Healthy", "Healthy" ]  = ""
m_P_diag["Sick"   , "Dead" ]     = ""
m_P_diag["Sick"   , "Sick" ]     = ""
m_P_diag["Dead"   , "Dead" ]     = ""
layout.fig <- c(2, 1)
plotmat(t(m_P_diag), t(layout.fig), self.cex = 0.5, curve = 0, arr.pos = 0.8,
latex = T, arr.type = "curved", relsize = 0.85, box.prop = 0.8,
cex = 0.8, box.cex = 0.7, lwd = 1)
# create the cohort trace
m_M <- m_M_trt <-  matrix(NA,
nrow = n_t + 1 ,  # create Markov trace (n.t + 1 because R doesn't
# understand Cycle 0)
ncol = n_states,
dimnames = list(0:n_t, v_n))
m_M[1, ] <- m_M_trt[1, ] <- v_init         # initialize first cycle of Markov trace
# create the transition probability matrix
m_P  <- matrix(0,
nrow = n_states, ncol = n_states,
dimnames = list(v_n, v_n)) # name the columns and rows of the transition
# probability matrix
m_P
# from Healthy
m_P["Healthy", "Healthy"] <- (1 - p_HD) * (1 - p_HS)
m_P["Healthy", "Sick"]    <- (1 - p_HD) * p_HS
m_P["Healthy", "Dead"]    <- p_HD
# from Sick
m_P["Sick", "Sick"] <- 1 - p_SD
m_P["Sick", "Dead"] <- p_SD
# from Dead
m_P["Dead", "Dead"] <- 1
# Under treatment
m_P_trt <- m_P
m_P_trt["Healthy", "Healthy"] <- (1 - p_HD) * (1 - p_HS_trt)
m_P_trt["Healthy", "Sick"]    <- (1 - p_HD) * p_HS_trt
# Check that transition probabilities are in [0, 1]
check_transition_probability(m_P, verbose = TRUE)
check_transition_probability(m_P_trt, verbose = TRUE)
# Check that all rows sum to 1
check_sum_of_transition_array(m_P, n_states = n_states, n_t = n_t, verbose = TRUE)
check_transition_probability(m_P_trt, verbose = TRUE)
for (t in 1:n_t){                               # loop through the number of cycles
m_M[t + 1, ]     <- m_M[t, ]     %*% m_P      # estimate the state vector for the next cycle (t + 1)
m_M_trt[t + 1, ] <- m_M_trt[t, ] %*% m_P_trt  # for treatment
}
matplot(m_M, type = 'l',
ylab = "Probability of state occupancy",
xlab = "Cycle",
main = "Cohort Trace", lwd = 3)                 # create a plot of the data
legend("right", v_n, col = c("black", "red", "green"),
lty = 1:3, bty = "n")                            # add a legend to the graph
abline(v = which.max(m_M[, "Sick"]), col = "gray")      # plot a vertical line that helps identifying at which cycle the prevalence of sick is highest.
matplot(m_M_trt, type = 'l',
ylab = "Probability of state occupancy",
xlab = "Cycle",
main = "Cohort Trace", lwd = 3)                 # create a plot of the data
legend("right", v_n, col = c("black", "red", "green"),
lty = 1:3, bty = "n")                            # add a legend to the graph
abline(v = which.max(m_M[, "Sick"]), col = "gray")      # plot a vertical line that helps identifying at which cycle the prevalence of sick is highest.
v_os <- 1 - m_M[, "Dead"]             # calculate the overall survival (OS) probability
v_os <- rowSums(m_M[, 1:2])           # alternative way of calculating the OS probability
plot(v_os, type = 'l',
ylim = c(0, 1),
ylab = "Survival probability",
xlab = "Cycle",
main = "Overall Survival")       # create a simple plot showing the OS
# add grid
grid(nx = n_t, ny = 10, col = "lightgray", lty = "dotted", lwd = par("lwd"),
equilogs = TRUE)
v_os_trt <- 1 - m_M_trt[, "Dead"]     # calculate the overall survival (OS) probability
v_os_trt <- rowSums(m_M_trt[, 1:2])   # alternative way of calculating the OS probability
plot(v_os_trt, type = 'l',
ylim = c(0, 1),
ylab = "Survival probability",
xlab = "Cycle",
main = "Overall Survival")       # create a simple plot showing the OS
# add grid
grid(nx = n_t, ny = 10, col = "lightgray", lty = "dotted", lwd = par("lwd"),
equilogs = TRUE)
v_le     <- sum(v_os)      # summing probability of OS over time (i.e. life expectancy)
v_le_trt <- sum(v_os_trt)  # summing probability of OS over time (i.e. life expectancy), treatment
v_prev <- m_M[, "Sick"]/v_os
plot(v_prev,
ylim = c(0, 1),
ylab = "Prevalence",
xlab = "Cycle",
main = "Disease prevalence")
v_prev_trt <- m_M_trt[, "Sick"]/v_os_trt
plot(v_prev_trt,
ylim = c(0, 1),
ylab = "Prevalence",
xlab = "Cycle",
main = "Disease prevalence")
# per cycle
# calculate expected costs by multiplying m_M with the cost vector for the different
# health states
v_tc     <- m_M     %*% c(c_H, c_S, c_D)          # Standard of Care
v_tc_trt <- m_M_trt %*% c(c_H, c_S + c_trt, c_D)  # Treatment
# calculate expected QALYs  by multiplying m_M with the utilities for the different
# health states
v_tu     <- m_M     %*% c(u_H, u_S, u_D)          # Standard of Care
v_tu_trt <- m_M_trt %*% c(u_H, u_S, u_D)          # Treatment
# Discount costs by multiplying the cost vector with discount weights
tc_d     <-  t(v_tc)     %*% v_dwc      # Standard of Care
tc_d_trt <-  t(v_tc_trt) %*% v_dwc      # Treatment
# Discount QALYS by multiplying the QALYs vector with discount weights
tu_d     <-  t(v_tu)     %*% v_dwe      # Standard of Care
tu_d_trt <-  t(v_tu_trt) %*% v_dwe      # Treatment
# store them into a vector
v_tc_d   <- c(tc_d, tc_d_trt)
v_tu_d   <- c(tu_d, tu_d_trt)
# Dataframe with discounted costs and effectiveness
df_ce       <- data.frame(Strategy = v_names_str,
Cost     = v_tc_d,
Effect   = v_tu_d
)
df_ce
df_cea <- calculate_icers(cost       = df_ce$Cost,
effect     = df_ce$Effect,
strategies = df_ce$Strategy
)
df_cea
plot(df_cea, effect_units = "QALYs", xlim = c(10, 12))
l_params_all <- as.list(data.frame(
p_HD     = 0.02,  # probability of dying when healthy
p_HS     = 0.05,  # probability of becoming sick when healthy, conditioned on not dying
p_HS_trt = 0.03,  # probability of becoming sick when healthy, conditioned on not dying
p_SD     = 0.1,   # probability of dying when sick
c_H      = 400,   # cost of one cycle in healthy state
c_S      = 1000,  # cost of one cycle in sick state
c_D      = 0,     # cost of one cycle in dead state
c_trt    = 800,   # cost of treatment (per cycle)
u_H      = 0.8,   # utility when healthy
u_S      = 0.5,   # utility when sick
u_D      = 0,     # utility when dead
d_e      = 0.03,  # discount factor for effectiveness
d_c      = 0.03   # discount factor for costs
))
# store the parameter names into a vector
v_names_params <- names(l_params_all)
source("Functions_markov_3state.R")
# Test function
calculate_ce_out(l_params_all)
# Dataframe with discounted costs and effectiveness
df_ce       <- data.frame(Strategy = v_names_str,
Cost     = v_tc_d,
Effect   = v_tu_d
)
df_ce
rm(list = ls())      # clear memory (removes all the variables from the workspace)
if (!require('pacman')) install.packages('pacman'); library(pacman) # use this package to conveniently install other packages
# load (install if required) packages from CRAN
p_load("diagram")
source("Functions.R")
# Strategy names
v_names_str <- c("Standard of Care", "Treatment")
# Number of strategies
n_str <- length(v_names_str)
# Markov model parameters
v_n  <- c("Healthy", "Sick", "Dead")    # state names
n_states  <- length(v_n)                # number of states
n_t  <- 60                              # number of cycles
v_init <- c(1, 0, 0)                    # initial cohort distribution
# Transition probabilities
p_HD <- 0.02                            # probability of dying when healthy
p_HS <- 0.05                            # probability of becoming sick when healthy, conditioned on not dying
p_HS_trt <- 0.03                        # probability of becoming sick when healthy, conditioned on not dying, under treatment
p_SD <- 0.1                             # probability of dying when sick
# Costs and utilities
c_H   <- 400                            # cost of one cycle in healthy state
c_S   <- 1000                           # cost of one cycle in sick state
c_D   <- 0                              # cost of one cycle in dead state
c_trt <- 800                            # cost of treatment (per cycle)
u_H   <- 0.8                            # utility when healthy
u_S   <- 0.5                            # utility when sick
u_D   <- 0                              # utility when dead
d_e   <- d_c <- 0.03                    # discount rate per cycle equal discount of costs and QALYs by 3%
# calculate discount weights for costs for each cycle based on discount rate d_c
v_dwc <- 1 / (1 + d_e) ^ (0:n_t)
# calculate discount weights for effectiveness for each cycle based on discount rate d_e
v_dwe <- 1 / (1 + d_c) ^ (0:n_t)
m_P_diag <- matrix(0, nrow = n_states, ncol = n_states, dimnames = list(v_n, v_n))
m_P_diag["Healthy", "Sick" ]     = ""
m_P_diag["Healthy", "Dead" ]     = ""
m_P_diag["Healthy", "Healthy" ]  = ""
m_P_diag["Sick"   , "Dead" ]     = ""
m_P_diag["Sick"   , "Sick" ]     = ""
m_P_diag["Dead"   , "Dead" ]     = ""
layout.fig <- c(2, 1)
plotmat(t(m_P_diag), t(layout.fig), self.cex = 0.5, curve = 0, arr.pos = 0.8,
latex = T, arr.type = "curved", relsize = 0.85, box.prop = 0.8,
cex = 0.8, box.cex = 0.7, lwd = 1)
# create the cohort trace
m_M <- m_M_trt <-  matrix(NA,
nrow = n_t + 1 ,  # create Markov trace (n.t + 1 because R doesn't
# understand Cycle 0)
ncol = n_states,
dimnames = list(0:n_t, v_n))
m_M[1, ] <- m_M_trt[1, ] <- v_init         # initialize first cycle of Markov trace
# create the transition probability matrix
m_P  <- matrix(0,
nrow = n_states, ncol = n_states,
dimnames = list(v_n, v_n)) # name the columns and rows of the transition
# probability matrix
m_P
# from Healthy
m_P["Healthy", "Healthy"] <- (1 - p_HD) * (1 - p_HS)
m_P["Healthy", "Sick"]    <- (1 - p_HD) * p_HS
m_P["Healthy", "Dead"]    <- p_HD
# from Sick
m_P["Sick", "Sick"] <- 1 - p_SD
m_P["Sick", "Dead"] <- p_SD
# from Dead
m_P["Dead", "Dead"] <- 1
# Under treatment
m_P_trt <- m_P
m_P_trt["Healthy", "Healthy"] <- (1 - p_HD) * (1 - p_HS_trt)
m_P_trt["Healthy", "Sick"]    <- (1 - p_HD) * p_HS_trt
# Check that transition probabilities are in [0, 1]
check_transition_probability(m_P, verbose = TRUE)
check_transition_probability(m_P_trt, verbose = TRUE)
# Check that all rows sum to 1
check_sum_of_transition_array(m_P, n_states = n_states, n_t = n_t, verbose = TRUE)
check_transition_probability(m_P_trt, verbose = TRUE)
for (t in 1:n_t){                               # loop through the number of cycles
m_M[t + 1, ]     <- m_M[t, ]     %*% m_P      # estimate the state vector for the next cycle (t + 1)
m_M_trt[t + 1, ] <- m_M_trt[t, ] %*% m_P_trt  # for treatment
}
matplot(m_M, type = 'l',
ylab = "Probability of state occupancy",
xlab = "Cycle",
main = "Cohort Trace", lwd = 3)                 # create a plot of the data
legend("right", v_n, col = c("black", "red", "green"),
lty = 1:3, bty = "n")                            # add a legend to the graph
abline(v = which.max(m_M[, "Sick"]), col = "gray")      # plot a vertical line that helps identifying at which cycle the prevalence of sick is highest.
matplot(m_M_trt, type = 'l',
ylab = "Probability of state occupancy",
xlab = "Cycle",
main = "Cohort Trace", lwd = 3)                 # create a plot of the data
legend("right", v_n, col = c("black", "red", "green"),
lty = 1:3, bty = "n")                            # add a legend to the graph
abline(v = which.max(m_M[, "Sick"]), col = "gray")      # plot a vertical line that helps identifying at which cycle the prevalence of sick is highest.
v_os <- 1 - m_M[, "Dead"]             # calculate the overall survival (OS) probability
v_os <- rowSums(m_M[, 1:2])           # alternative way of calculating the OS probability
plot(v_os, type = 'l',
ylim = c(0, 1),
ylab = "Survival probability",
xlab = "Cycle",
main = "Overall Survival")       # create a simple plot showing the OS
# add grid
grid(nx = n_t, ny = 10, col = "lightgray", lty = "dotted", lwd = par("lwd"),
equilogs = TRUE)
v_os_trt <- 1 - m_M_trt[, "Dead"]     # calculate the overall survival (OS) probability
v_os_trt <- rowSums(m_M_trt[, 1:2])   # alternative way of calculating the OS probability
plot(v_os_trt, type = 'l',
ylim = c(0, 1),
ylab = "Survival probability",
xlab = "Cycle",
main = "Overall Survival")       # create a simple plot showing the OS
# add grid
grid(nx = n_t, ny = 10, col = "lightgray", lty = "dotted", lwd = par("lwd"),
equilogs = TRUE)
v_le     <- sum(v_os)      # summing probability of OS over time (i.e. life expectancy)
v_le_trt <- sum(v_os_trt)  # summing probability of OS over time (i.e. life expectancy), treatment
v_prev <- m_M[, "Sick"]/v_os
plot(v_prev,
ylim = c(0, 1),
ylab = "Prevalence",
xlab = "Cycle",
main = "Disease prevalence")
v_prev_trt <- m_M_trt[, "Sick"]/v_os_trt
plot(v_prev_trt,
ylim = c(0, 1),
ylab = "Prevalence",
xlab = "Cycle",
main = "Disease prevalence")
# per cycle
# calculate expected costs by multiplying m_M with the cost vector for the different
# health states
v_tc     <- m_M     %*% c(c_H, c_S, c_D)          # Standard of Care
v_tc_trt <- m_M_trt %*% c(c_H, c_S + c_trt, c_D)  # Treatment
# calculate expected QALYs  by multiplying m_M with the utilities for the different
# health states
v_tu     <- m_M     %*% c(u_H, u_S, u_D)          # Standard of Care
v_tu_trt <- m_M_trt %*% c(u_H, u_S, u_D)          # Treatment
# Discount costs by multiplying the cost vector with discount weights
tc_d     <-  t(v_tc)     %*% v_dwc      # Standard of Care
tc_d_trt <-  t(v_tc_trt) %*% v_dwc      # Treatment
# Discount QALYS by multiplying the QALYs vector with discount weights
tu_d     <-  t(v_tu)     %*% v_dwe      # Standard of Care
tu_d_trt <-  t(v_tu_trt) %*% v_dwe      # Treatment
# store them into a vector
v_tc_d   <- c(tc_d, tc_d_trt)
v_tu_d   <- c(tu_d, tu_d_trt)
# Dataframe with discounted costs and effectiveness
df_ce       <- data.frame(Strategy = v_names_str,
Cost     = v_tc_d,
Effect   = v_tu_d
)
df_ce
df_cea <- calculate_icers(cost       = df_ce$Cost,
effect     = df_ce$Effect,
strategies = df_ce$Strategy
)
df_cea
l_params_all <- as.list(data.frame(
p_HD     = 0.02,  # probability of dying when healthy
p_HS     = 0.05,  # probability of becoming sick when healthy, conditioned on not dying
p_HS_trt = 0.03,  # probability of becoming sick when healthy, conditioned on not dying
p_SD     = 0.1,   # probability of dying when sick
c_H      = 400,   # cost of one cycle in healthy state
c_S      = 1000,  # cost of one cycle in sick state
c_D      = 0,     # cost of one cycle in dead state
c_trt    = 800,   # cost of treatment (per cycle)
u_H      = 0.8,   # utility when healthy
u_S      = 0.5,   # utility when sick
u_D      = 0,     # utility when dead
d_e      = 0.03,  # discount factor for effectiveness
d_c      = 0.03   # discount factor for costs
))
# store the parameter names into a vector
v_names_params <- names(l_params_all)
source("Functions_markov_3state.R")
# Test function
calculate_ce_out(l_params_all)
options(scipen = 999) # disabling scientific notation in R
# dataframe containing all parameters, their base case values, and the min and
# max values of the parameters of interest
df_params_owsa <- data.frame(pars = c("c_trt", "c_S", "u_H"),
min  = c(300 , 500, 0.7),   # min parameter values
max  = c(1200, 2000, 0.9)     # max parameter values
)
owsa_nmb  <- run_owsa_det(params_range     = df_params_owsa,    # dataframe with parameters for OWSA
params_basecase  = l_params_all,      # list with all parameters
nsamp            = 100,               # number of parameter values
FUN              = calculate_ce_out,  # function to compute outputs
outcomes         = c("NMB"),          # output to do the OWSA on
strategies       = v_names_str,       # names of the strategies
n_wtp            = 2000)             # extra argument to pass to FUN
plot(owsa_nmb, txtsize = 10, n_x_ticks = 4,
facet_scales = "free") +
theme(legend.position = "bottom")
owsa_opt_strat(owsa = owsa_nmb, txtsize = 10)
owsa_tornado(owsa = owsa_nmb, txtsize = 12)
owsa_tornado(owsa = owsa_nmb, txtsize = 11)
owsa_tornado(owsa = owsa_nmb, txtsize = 10)
owsa_tornado(owsa = owsa_nmb, txtsize = 11)
# dataframe containing all parameters, their basecase values, and the min and
# max values of the parameters of interest
df_params_twsa <- data.frame(pars = c("c_trt", "u_H"),
min  = c(300, 0.7),  # min parameter values
max  = c(1200, 0.9)  # max parameter values
)
twsa_nmb <- run_twsa_det(params_range    = df_params_twsa,    # dataframe with parameters for TWSA
params_basecase = l_params_all,      # list with all parameters
nsamp           = 40,                # number of parameter values
FUN             = calculate_ce_out,  # function to compute outputs
outcomes        = c("NMB"),          # output to do the TWSA on
strategies      = v_names_str,       # names of the strategies
n_wtp           = 2000)              # extra argument to pass to FUN
plot(twsa_nmb)
beta_params(0.05, 0.01)
beta_params(0.05, 0.02)
sd(rbeta(n_sim, 24,450))
sd(rbeta(10000, 24,450))
beta_params(0.05, 0.01)
beta_params(0.03, 0.01)
sd(rbeta(10000, 9,271))
sd(rbeta(10000, 9,281))
mean(rbeta(10000, 9,281))
beta_params(800, 100)
beta_params(800, 100)
beta_params(800, 120)
gamma_params(800, 100)
rgamma(10000, 64, 12.5)
mean(rgamma(10000, 64, 12.5))
sd(rgamma(10000, 64, 12.5))
sd(rgamma(10000, shape=64, scale=12.5))
gamma_params(800, 100)
mean(rgamma(10000, shape=16, scale=25))
mean(rgamma(10000, shape=64, scale=13))
mean(rgamma(10000, shape=64, scale=12.5))
sd(rgamma(10000, shape=64, scale=12.5))
setwd("C:/Users/Alan Yang/Desktop/GitHub local/Course-Modularization/Microsimulation/Microsim 3-state")
