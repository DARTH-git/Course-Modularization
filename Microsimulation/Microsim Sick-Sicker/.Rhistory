p_HD     <- p_HD_all[M_t == "H","p_HD"]
M_t <- v_M_init
# lookup baseline probability and rate of dying based on individual characteristics
p_HD_all <- inner_join(df_X, p_mort, by = c("Age"))
p_HD     <- p_HD_all[M_t == "H","p_HD"]
# update the m_p with the appropriate probabilities
# transition probabilities when healthy
m_p_t[, M_t == "H"]  <- rbind(1 - p_HS1 - p_HD, p_HS1, 0, p_HD)
# transition probabilities when sick
m_p_t[, M_t == "S1"] <- rbind(p_S1H, 1 - p_S1H - p_S1S2 - p_S1D, p_S1S2, p_S1D)
# transition probabilities when sicker
m_p_t[, M_t == "S2"] <- rbind(0, 0, 1 - p_S2D, p_S2D)
# transition probabilities when dead
m_p_t[, M_t == "D"]  <- rbind(0, 0, 0, 1)
m_p_t
Probs <- function(M_t, df_X) {
# Arguments:
# M_t: health state occupied by individual i at cycle t (character variable)
# df_X:     data frame with individual characteristics data
# t:     current cycle
# Returns:
#   transition probabilities for that cycle
# create matrix of state transition probabilities
m_p_t           <- matrix(0, nrow = n_states, ncol = n_i)
rownames(m_p_t) <-  v_n  # give the state names to the rows
# lookup baseline probability and rate of dying based on individual characteristics
p_HD_all <- inner_join(df_X, p_mort, by = c("Age"))
p_HD     <- p_HD_all[M_t == "H","p_HD"]
# update the m_p with the appropriate probabilities
# transition probabilities when healthy
m_p_t[, M_t == "H"]  <- rbind(1 - p_HS1 - p_HD, p_HS1, 0, p_HD)
# transition probabilities when sick
m_p_t[, M_t == "S1"] <- rbind(p_S1H, 1 - p_S1H - p_S1S2 - p_S1D, p_S1S2, p_S1D)
# transition probabilities when sicker
m_p_t[, M_t == "S2"] <- rbind(0, 0, 1 - p_S2D, p_S2D)
# transition probabilities when dead
m_p_t[, M_t == "D"]  <- rbind(0, 0, 0, 1)
return(t(m_p_t))
}
# Run the simulation for both no treatment and treatment options
outcomes_no_trt  <- MicroSim(n_i, df_X, Trt = FALSE, seed = 1)
rm(list = ls())      # clear memory (removes all the variables from the workspace)
if (!require('pacman')) install.packages('pacman'); library(pacman) # use this package to conveniently install other packages
# load (install if required) packages from CRAN
p_load("here", "dplyr", "devtools", "scales", "ellipse", "ggplot2", "lazyeval", "igraph", "ggraph", "reshape2", "knitr")
# load (install if required) packages from GitHub
# install_github("DARTH-git/dampack", force = TRUE) Uncomment if there is a newer version
p_load_gh("DARTH-git/dampack")
source(here("functions", "Functions.R"))
set.seed(1)  # set the seed
# Model structure
n_t   <- 30                       # time horizon, 30 cycles
n_i   <- 100000                   # number of simulated individuals
v_n   <- c("H", "S1", "S2", "D")  # the model states names
n_states   <- length(v_n)         # the number of health states
d_r   <- 0.03                     # discount rate of 3% per cycle
v_dwe <- v_dwc <- 1 / ((1 + d_r) ^ (0:n_t))    # discount weight
v_names_str <- c("no treatment", "treatment")  # strategy names
n_str <- length(v_names_str)      # number of strategies
### Event probabilities (per cycle)
# Annual transition probabilities
p_HS1   <- 0.15                   # probability of becoming sick when healthy
p_S1H   <- 0.5                    # probability of recovering to healthy when sick
p_S1S2  <- 0.105                  # probability of becoming sicker when sick
# Annual probabilities of death
# load age dependent probability
p_mort   <- read.csv(here("data", "mortProb_age.csv"))
# load age distribution
dist_Age <- read.csv(here("data", "MyPopulation-AgeDistribution.csv"))
p_S1D    <- 0.0149          # probability to die in S1 by cycle
p_S2D    <- 0.048           # probability to die in S2
# Cost inputs
c_H     <- 2000             # cost of one cycle in the healthy state
c_S1    <- 4000             # cost of one cycle in the sick state
c_S2    <- 15000            # cost of one cycle in the sicker state
c_D     <- 0                # cost of one cycle in the dead state
c_Trt   <- 12000            # cost of treatment (per cycle)
# Utility inputs
u_H     <- 1                # utility when healthy
u_S1    <- 0.75             # utility when sick
u_S2    <- 0.5              # utility when sicker
u_D     <- 0                # utility when dead
u_Trt   <- 0.95             # utility when sick(er) and being treated
v_x     <- runif(n_i, min = 0.95, max = 1.05) # treatment effect modifier at baseline
# sample from age distribution an initial age for every individual
v_age0  <- sample(x = dist_Age$age, prob = dist_Age$prop, size = n_i, replace = TRUE)
df_X    <- data.frame(ID = 1:n_i, x = v_x, Age = v_age0)
# Specify the initial health state of the individuals
# everyone begins in the healthy state (in this example)
v_M_init  <- rep("H", n_i)   # a vector with the initial health state for all individuals
Probs <- function(M_t, df_X) {
# Arguments:
# M_t: health state occupied by individual i at cycle t (character variable)
# df_X:     data frame with individual characteristics data
# t:     current cycle
# Returns:
#   transition probabilities for that cycle
# create matrix of state transition probabilities
m_p_t           <- matrix(0, nrow = n_states, ncol = n_i)
rownames(m_p_t) <-  v_n  # give the state names to the rows
# lookup baseline probability and rate of dying based on individual characteristics
p_HD_all <- inner_join(df_X, p_mort, by = c("Age"))
p_HD     <- p_HD_all[M_t == "H","p_HD"]
# update the m_p with the appropriate probabilities
# transition probabilities when healthy
m_p_t[, M_t == "H"]  <- rbind(1 - p_HS1 - p_HD, p_HS1, 0, p_HD)
# transition probabilities when sick
m_p_t[, M_t == "S1"] <- rbind(p_S1H, 1 - p_S1H - p_S1S2 - p_S1D, p_S1S2, p_S1D)
# transition probabilities when sicker
m_p_t[, M_t == "S2"] <- rbind(0, 0, 1 - p_S2D, p_S2D)
# transition probabilities when dead
m_p_t[, M_t == "D"]  <- rbind(0, 0, 0, 1)
return(t(m_p_t))
}
Costs <- function (M_t, Trt = FALSE) {
# M_t: health state occupied by individual i at cycle t (character variable)
# Trt:  is the individual being treated? (default is FALSE)
c_t <- 0                                 # by default the cost for everyone is zero
c_t[M_t == "H"]  <- c_H                  # update the cost if healthy
c_t[M_t == "S1"] <- c_S1 + c_Trt * Trt   # update the cost if sick conditional on treatment
c_t[M_t == "S2"] <- c_S2 + c_Trt * Trt   # update the cost if sicker conditional on treatment
c_t[M_t == "D"]  <- c_D                  # update the cost if dead
return(c_t)        		                   # return the costs
}
Effs <- function (M_t, df_X, Trt = FALSE, cl = 1) {
# M_t: health state occupied by individual i at cycle t (character variable)
# df_X: data frame with individual characteristics data
# Trt:  is the individual treated? (default is FALSE)
# cl:   cycle length (default is 1)
u_t <- 0                                 # by default the utility for everyone is zero
u_t[M_t == "H"]  <- u_H                  # update the utility if healthy
u_t[M_t == "S1" & Trt == FALSE] <- u_S1  # update the utility if sick
# update the utility if sick but on treatment (adjust for individual effect modifier)
u_t[M_t == "S1" & Trt == TRUE]  <- u_Trt * df_X$x[M_t == "S1"]
u_t[M_t == "S2"] <- u_S2                 # update the utility if sicker
u_t[M_t == "D"]  <- u_D                  # update the utility if dead
QALYs <-  u_t * cl  # calculate the QALYs during cycle t
return(QALYs)       # return the QALYs
}
# Run the simulation for both no treatment and treatment options
outcomes_no_trt  <- MicroSim(n_i, df_X, Trt = FALSE, seed = 1)
MicroSim <- function(n_i, df_X, Trt = FALSE, seed = 1) {
# Arguments:
# n_i:     number of individuals
# df_X     data frame with individual characteristics data
# Trt:     is this the individual receiving treatment? (default is FALSE)
# seed:    default is 1
set.seed(seed) # set the seed
# create three matrices called m_M, m_C and m_E
# number of rows is equal to the n_i, the number of columns is equal to n_t
# (the initial state and all the n_t cycles)
# m_M is used to store the health state information over time for every individual
# m_C is used to store the costs information over time for every individual
# m_E is used to store the effects information over time for every individual
m_M <- m_C <- m_E <-  matrix(nrow = n_i, ncol = n_t + 1,
dimnames = list(paste("ind"  , 1:n_i, sep = " "),
paste("cycle", 0:n_t, sep = " ")))
# initial health state at cycle 0 for individual i
m_M [, 1] <- v_M_init
# calculate costs per individual during cycle 0
m_C[, 1]  <- Costs(m_M[, 1], Trt)
# calculate QALYs per individual during cycle 0
m_E[, 1]  <- Effs (m_M[, 1], df_X, Trt)
# open a loop for time running cycles 1 to n_t
for (t in 1:n_t) {
# calculate the transition probabilities for the cycle based on  health state t
m_P <- Probs(m_M[, t], df_X, t)
# sample the current health state and store that state in matrix m_M
m_M[, t + 1]  <- samplev(m_P, 1)
# calculate costs per individual during cycle t + 1
m_C[, t + 1]  <- Costs(m_M[, t + 1], Trt)
# calculate QALYs per individual during cycle t + 1
m_E[, t + 1]  <- Effs(m_M[, t + 1], df_X, Trt)
# update the age of individuals that are alive
df_X$Age[m_M[, t + 1] != "D"]  <- df_X$Age[m_M[, t + 1] != "D"] + 1
# Display simulation progress
if(t/(n_t/10) == round(t/(n_t/10), 0)) { # display progress every 10%
cat('\r', paste(t/n_t * 100, "% done", sep = " "))
}
} # close the loop for the time points
# calculate
tc <- m_C %*% v_dwc    # total (discounted) cost per individual
te <- m_E %*% v_dwe    # total (discounted) QALYs per individual
tc_hat <- mean(tc)     # average (discounted) cost
te_hat <- mean(te)     # average (discounted) QALYs
# store the results from the simulation in a list
results <- list(m_M = m_M, m_C = m_C, m_E = m_E, tc = tc , te = te, tc_hat = tc_hat,
te_hat = te_hat)
return(results)  # return the results
} # end of the MicroSim function
# By specifying all the arguments in the `MicroSim()` the simulation can be started
# In this example the outcomes are of the simulation are stored in the variables `outcomes_no_tr` and `outcomes_trt`.
# Run the simulation for both no treatment and treatment options
outcomes_no_trt  <- MicroSim(n_i, df_X, Trt = FALSE, seed = 1)
Effs <- function (M_t, df_X, Trt = FALSE, cl = 1) {
# M_t: health state occupied by individual i at cycle t (character variable)
# df_X: data frame with individual characteristics data
# Trt:  is the individual treated? (default is FALSE)
# cl:   cycle length (default is 1)
u_t <- 0                                 # by default the utility for everyone is zero
u_t[M_t == "H"]  <- u_H                  # update the utility if healthy
u_t[M_t == "S1" & Trt == FALSE] <- u_S1  # update the utility if sick
# update the utility if sick but on treatment (adjust for individual effect modifier)
u_t[M_t == "S1" & Trt == TRUE]  <- u_Trt * df_X$x[M_t == "S1"]
u_t[M_t == "S2"] <- u_S2                 # update the utility if sicker
u_t[M_t == "D"]  <- u_D                  # update the utility if dead
QALYs <-  u_t * cl  # calculate the QALYs during cycle t
return(QALYs)       # return the QALYs
}
Costs <- function (M_t, Trt = FALSE) {
# M_t: health state occupied by individual i at cycle t (character variable)
# Trt:  is the individual being treated? (default is FALSE)
c_t <- 0                                 # by default the cost for everyone is zero
c_t[M_t == "H"]  <- c_H                  # update the cost if healthy
c_t[M_t == "S1"] <- c_S1 + c_Trt * Trt   # update the cost if sick conditional on treatment
c_t[M_t == "S2"] <- c_S2 + c_Trt * Trt   # update the cost if sicker conditional on treatment
c_t[M_t == "D"]  <- c_D                  # update the cost if dead
return(c_t)        		                   # return the costs
}
# Run the simulation for both no treatment and treatment options
outcomes_no_trt  <- MicroSim(n_i, df_X, Trt = FALSE, seed = 1)
MicroSim <- function(n_i, df_X, Trt = FALSE, seed = 1) {
# Arguments:
# n_i:     number of individuals
# df_X     data frame with individual characteristics data
# Trt:     is this the individual receiving treatment? (default is FALSE)
# seed:    default is 1
set.seed(seed) # set the seed
# create three matrices called m_M, m_C and m_E
# number of rows is equal to the n_i, the number of columns is equal to n_t
# (the initial state and all the n_t cycles)
# m_M is used to store the health state information over time for every individual
# m_C is used to store the costs information over time for every individual
# m_E is used to store the effects information over time for every individual
m_M <- m_C <- m_E <-  matrix(nrow = n_i, ncol = n_t + 1,
dimnames = list(paste("ind"  , 1:n_i, sep = " "),
paste("cycle", 0:n_t, sep = " ")))
# initial health state at cycle 0 for individual i
m_M [, 1] <- v_M_init
# calculate costs per individual during cycle 0
m_C[, 1]  <- Costs(m_M[, 1], Trt)
# calculate QALYs per individual during cycle 0
m_E[, 1]  <- Effs (m_M[, 1], df_X, Trt)
# open a loop for time running cycles 1 to n_t
for (t in 1:n_t) {
# calculate the transition probabilities for the cycle based on  health state t
m_P <- Probs(m_M[, t], df_X)
# sample the current health state and store that state in matrix m_M
m_M[, t + 1]  <- samplev(m_P, 1)
# calculate costs per individual during cycle t + 1
m_C[, t + 1]  <- Costs(m_M[, t + 1], Trt)
# calculate QALYs per individual during cycle t + 1
m_E[, t + 1]  <- Effs(m_M[, t + 1], df_X, Trt)
# update the age of individuals that are alive
df_X$Age[m_M[, t + 1] != "D"]  <- df_X$Age[m_M[, t + 1] != "D"] + 1
# Display simulation progress
if(t/(n_t/10) == round(t/(n_t/10), 0)) { # display progress every 10%
cat('\r', paste(t/n_t * 100, "% done", sep = " "))
}
} # close the loop for the time points
# calculate
tc <- m_C %*% v_dwc    # total (discounted) cost per individual
te <- m_E %*% v_dwe    # total (discounted) QALYs per individual
tc_hat <- mean(tc)     # average (discounted) cost
te_hat <- mean(te)     # average (discounted) QALYs
# store the results from the simulation in a list
results <- list(m_M = m_M, m_C = m_C, m_E = m_E, tc = tc , te = te, tc_hat = tc_hat,
te_hat = te_hat)
return(results)  # return the results
} # end of the MicroSim function
# By specifying all the arguments in the `MicroSim()` the simulation can be started
# In this example the outcomes are of the simulation are stored in the variables `outcomes_no_tr` and `outcomes_trt`.
# Run the simulation for both no treatment and treatment options
outcomes_no_trt  <- MicroSim(n_i, df_X, Trt = FALSE, seed = 1)
outcomes_trt     <- MicroSim(n_i, df_X, Trt = TRUE,  seed = 1)
# Run the simulation for both no treatment and treatment options
outcomes_no_trt  <- MicroSim(n_i, df_X, Trt = FALSE, seed = 1)
outcomes_no_trt$te_hat
df_X
mean(df_X$Age)
# Run the simulation for both no treatment and treatment options
outcomes_no_trt  <- MicroSim(n_i, df_X, Trt = FALSE, seed = 1)
mean(df_X$Age)
MicroSim <- function(n_i, df_X, Trt = FALSE, seed = 1) {
# Arguments:
# n_i:     number of individuals
# df_X     data frame with individual characteristics data
# Trt:     is this the individual receiving treatment? (default is FALSE)
# seed:    default is 1
set.seed(seed) # set the seed
# create three matrices called m_M, m_C and m_E
# number of rows is equal to the n_i, the number of columns is equal to n_t
# (the initial state and all the n_t cycles)
# m_M is used to store the health state information over time for every individual
# m_C is used to store the costs information over time for every individual
# m_E is used to store the effects information over time for every individual
m_M <- m_C <- m_E <-  matrix(nrow = n_i, ncol = n_t + 1,
dimnames = list(paste("ind"  , 1:n_i, sep = " "),
paste("cycle", 0:n_t, sep = " ")))
# initial health state at cycle 0 for individual i
m_M [, 1] <- v_M_init
# calculate costs per individual during cycle 0
m_C[, 1]  <- Costs(m_M[, 1], Trt)
# calculate QALYs per individual during cycle 0
m_E[, 1]  <- Effs (m_M[, 1], df_X, Trt)
# open a loop for time running cycles 1 to n_t
for (t in 1:n_t) {
# calculate the transition probabilities for the cycle based on  health state t
m_P <- Probs(m_M[, t], df_X)
# sample the current health state and store that state in matrix m_M
m_M[, t + 1]  <- samplev(m_P, 1)
# calculate costs per individual during cycle t + 1
m_C[, t + 1]  <- Costs(m_M[, t + 1], Trt)
# calculate QALYs per individual during cycle t + 1
m_E[, t + 1]  <- Effs(m_M[, t + 1], df_X, Trt)
# update the age of individuals that are alive
df_X$Age[m_M[, t + 1] != "D"] <<- df_X$Age[m_M[, t + 1] != "D"] + 1
# Display simulation progress
if(t/(n_t/10) == round(t/(n_t/10), 0)) { # display progress every 10%
cat('\r', paste(t/n_t * 100, "% done", sep = " "))
}
} # close the loop for the time points
# calculate
tc <- m_C %*% v_dwc    # total (discounted) cost per individual
te <- m_E %*% v_dwe    # total (discounted) QALYs per individual
tc_hat <- mean(tc)     # average (discounted) cost
te_hat <- mean(te)     # average (discounted) QALYs
# store the results from the simulation in a list
results <- list(m_M = m_M, m_C = m_C, m_E = m_E, tc = tc , te = te, tc_hat = tc_hat,
te_hat = te_hat)
return(results)  # return the results
} # end of the MicroSim function
# By specifying all the arguments in the `MicroSim()` the simulation can be started
# In this example the outcomes are of the simulation are stored in the variables `outcomes_no_tr` and `outcomes_trt`.
# Run the simulation for both no treatment and treatment options
outcomes_no_trt  <- MicroSim(n_i, df_X, Trt = FALSE, seed = 1)
outcomes_trt     <- MicroSim(n_i, df_X, Trt = TRUE,  seed = 1)
outcomes_no_trt$te_hat
outcomes_trt$te
outcomes_trt$te_hat
outcomes_no_trt$te_hat
rm(list = ls())      # clear memory (removes all the variables from the workspace)
if (!require('pacman')) install.packages('pacman'); library(pacman) # use this package to conveniently install other packages
# load (install if required) packages from CRAN
p_load("here", "dplyr", "devtools", "scales", "ellipse", "ggplot2", "lazyeval", "igraph", "ggraph", "reshape2", "knitr")
# load (install if required) packages from GitHub
# install_github("DARTH-git/dampack", force = TRUE) Uncomment if there is a newer version
p_load_gh("DARTH-git/dampack")
source(here("functions", "Functions.R"))
set.seed(1)  # set the seed
# Model structure
n_t   <- 30                       # time horizon, 30 cycles
n_i   <- 100000                   # number of simulated individuals
v_n   <- c("H", "S1", "S2", "D")  # the model states names
n_states   <- length(v_n)         # the number of health states
d_r   <- 0.03                     # discount rate of 3% per cycle
v_dwe <- v_dwc <- 1 / ((1 + d_r) ^ (0:n_t))    # discount weight
v_names_str <- c("no treatment", "treatment")  # strategy names
n_str <- length(v_names_str)      # number of strategies
### Event probabilities (per cycle)
# Annual transition probabilities
p_HS1   <- 0.15                   # probability of becoming sick when healthy
p_S1H   <- 0.5                    # probability of recovering to healthy when sick
p_S1S2  <- 0.105                  # probability of becoming sicker when sick
# Annual probabilities of death
# load age dependent probability
p_mort   <- read.csv(here("data", "mortProb_age.csv"))
# load age distribution
dist_Age <- read.csv(here("data", "MyPopulation-AgeDistribution.csv"))
p_S1D    <- 0.0149          # probability to die in S1 by cycle
p_S2D    <- 0.048           # probability to die in S2
# Cost inputs
c_H     <- 2000             # cost of one cycle in the healthy state
c_S1    <- 4000             # cost of one cycle in the sick state
c_S2    <- 15000            # cost of one cycle in the sicker state
c_D     <- 0                # cost of one cycle in the dead state
c_Trt   <- 12000            # cost of treatment (per cycle)
# Utility inputs
u_H     <- 1                # utility when healthy
u_S1    <- 0.75             # utility when sick
u_S2    <- 0.5              # utility when sicker
u_D     <- 0                # utility when dead
u_Trt   <- 0.95             # utility when sick(er) and being treated
v_x     <- runif(n_i, min = 0.95, max = 1.05) # treatment effect modifier at baseline
# sample from age distribution an initial age for every individual
v_age0  <- sample(x = dist_Age$age, prob = dist_Age$prop, size = n_i, replace = TRUE)
df_X    <- data.frame(ID = 1:n_i, x = v_x, Age = v_age0)
# Specify the initial health state of the individuals
# everyone begins in the healthy state (in this example)
v_M_init  <- rep("H", n_i)   # a vector with the initial health state for all individuals
Probs <- function(M_t, df_X) {
# Arguments:
# M_t: health state occupied by individual i at cycle t (character variable)
# df_X:     data frame with individual characteristics data
# t:     current cycle
# Returns:
#   transition probabilities for that cycle
# create matrix of state transition probabilities
m_p_t           <- matrix(0, nrow = n_states, ncol = n_i)
rownames(m_p_t) <-  v_n  # give the state names to the rows
# lookup baseline probability and rate of dying based on individual characteristics
p_HD_all <- inner_join(df_X, p_mort, by = c("Age"))
p_HD     <- p_HD_all[M_t == "H","p_HD"]
# update the m_p with the appropriate probabilities
# transition probabilities when healthy
m_p_t[, M_t == "H"]  <- rbind(1 - p_HS1 - p_HD, p_HS1, 0, p_HD)
# transition probabilities when sick
m_p_t[, M_t == "S1"] <- rbind(p_S1H, 1 - p_S1H - p_S1S2 - p_S1D, p_S1S2, p_S1D)
# transition probabilities when sicker
m_p_t[, M_t == "S2"] <- rbind(0, 0, 1 - p_S2D, p_S2D)
# transition probabilities when dead
m_p_t[, M_t == "D"]  <- rbind(0, 0, 0, 1)
return(t(m_p_t))
}
Costs <- function (M_t, Trt = FALSE) {
# M_t: health state occupied by individual i at cycle t (character variable)
# Trt:  is the individual being treated? (default is FALSE)
c_t <- 0                                 # by default the cost for everyone is zero
c_t[M_t == "H"]  <- c_H                  # update the cost if healthy
c_t[M_t == "S1"] <- c_S1 + c_Trt * Trt   # update the cost if sick conditional on treatment
c_t[M_t == "S2"] <- c_S2 + c_Trt * Trt   # update the cost if sicker conditional on treatment
c_t[M_t == "D"]  <- c_D                  # update the cost if dead
return(c_t)        		                   # return the costs
}
Effs <- function (M_t, df_X, Trt = FALSE, cl = 1) {
# M_t: health state occupied by individual i at cycle t (character variable)
# df_X: data frame with individual characteristics data
# Trt:  is the individual treated? (default is FALSE)
# cl:   cycle length (default is 1)
u_t <- 0                                 # by default the utility for everyone is zero
u_t[M_t == "H"]  <- u_H                  # update the utility if healthy
u_t[M_t == "S1" & Trt == FALSE] <- u_S1  # update the utility if sick
# update the utility if sick but on treatment (adjust for individual effect modifier)
u_t[M_t == "S1" & Trt == TRUE]  <- u_Trt * df_X$x[M_t == "S1"]
u_t[M_t == "S2"] <- u_S2                 # update the utility if sicker
u_t[M_t == "D"]  <- u_D                  # update the utility if dead
QALYs <-  u_t * cl  # calculate the QALYs during cycle t
return(QALYs)       # return the QALYs
}
MicroSim <- function(n_i, df_X, Trt = FALSE, seed = 1) {
# Arguments:
# n_i:     number of individuals
# df_X     data frame with individual characteristics data
# Trt:     is this the individual receiving treatment? (default is FALSE)
# seed:    default is 1
set.seed(seed) # set the seed
# create three matrices called m_M, m_C and m_E
# number of rows is equal to the n_i, the number of columns is equal to n_t
# (the initial state and all the n_t cycles)
# m_M is used to store the health state information over time for every individual
# m_C is used to store the costs information over time for every individual
# m_E is used to store the effects information over time for every individual
m_M <- m_C <- m_E <-  matrix(nrow = n_i, ncol = n_t + 1,
dimnames = list(paste("ind"  , 1:n_i, sep = " "),
paste("cycle", 0:n_t, sep = " ")))
# initial health state at cycle 0 for individual i
m_M [, 1] <- v_M_init
# calculate costs per individual during cycle 0
m_C[, 1]  <- Costs(m_M[, 1], Trt)
# calculate QALYs per individual during cycle 0
m_E[, 1]  <- Effs (m_M[, 1], df_X, Trt)
# open a loop for time running cycles 1 to n_t
for (t in 1:n_t) {
# calculate the transition probabilities for the cycle based on  health state t
m_P <- Probs(m_M[, t], df_X)
# sample the current health state and store that state in matrix m_M
m_M[, t + 1]  <- samplev(m_P, 1)
# calculate costs per individual during cycle t + 1
m_C[, t + 1]  <- Costs(m_M[, t + 1], Trt)
# calculate QALYs per individual during cycle t + 1
m_E[, t + 1]  <- Effs(m_M[, t + 1], df_X, Trt)
# update the age of individuals that are alive
df_X$Age[m_M[, t + 1] != "D"] <- df_X$Age[m_M[, t + 1] != "D"] + 1
# Display simulation progress
if(t/(n_t/10) == round(t/(n_t/10), 0)) { # display progress every 10%
cat('\r', paste(t/n_t * 100, "% done", sep = " "))
}
} # close the loop for the time points
# calculate
tc <- m_C %*% v_dwc    # total (discounted) cost per individual
te <- m_E %*% v_dwe    # total (discounted) QALYs per individual
tc_hat <- mean(tc)     # average (discounted) cost
te_hat <- mean(te)     # average (discounted) QALYs
# store the results from the simulation in a list
results <- list(m_M = m_M, m_C = m_C, m_E = m_E, tc = tc , te = te, tc_hat = tc_hat,
te_hat = te_hat)
return(results)  # return the results
} # end of the MicroSim function
# By specifying all the arguments in the `MicroSim()` the simulation can be started
# In this example the outcomes are of the simulation are stored in the variables `outcomes_no_tr` and `outcomes_trt`.
# Run the simulation for both no treatment and treatment options
outcomes_no_trt  <- MicroSim(n_i, df_X, Trt = FALSE, seed = 1)
outcomes_trt     <- MicroSim(n_i, df_X, Trt = TRUE,  seed = 1)
options(scipen = 999)
options(scipen = 999)
# No treatment
plot(density(outcomes_no_trt$tc), main = paste("Total cost per person"), xlab = "Cost ($)")
plot(density(outcomes_no_trt$te), main = paste("Total QALYs per person"), xlab = "QALYs")
plot_m_TR(outcomes_no_trt$m_M)  # health state trace
# Treatment
plot(density(outcomes_trt$tc), main = paste("Total cost per person"), xlab = "Cost ($)")
plot(density(outcomes_trt$te), main = paste("Total QALYs per person"), xlab = "QALYs")
plot_m_TR(outcomes_trt$m_M)     # health state trace
# store the mean costs of each strategy in a new variable C (vector of costs)
v_C <- c(outcomes_no_trt$tc_hat, outcomes_trt$tc_hat)
# store the mean QALYs of each strategy in a new variable E (vector of effects)
v_E <- c(outcomes_no_trt$te_hat, outcomes_trt$te_hat)
# use dampack to calculate the ICER
calculate_icers(cost       = v_C,
effect     = v_E,
strategies = v_names_str)
p_S1D
