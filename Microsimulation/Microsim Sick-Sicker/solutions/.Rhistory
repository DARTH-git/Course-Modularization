# n_i:     number of individuals
# df_X     data frame with individual data
# seed: default is 1
set.seed(seed) # set the seed
# create three matrices called m_M, m_C and m_E
# number of rows is equal to the n_i, the number of columns is equal to n_t
# (the initial state and all the n_t cycles)
# m_M is used to store the health state information over time for every individual
# m_C is used to store the costs information over time for every individual
# m_E is used to store the effects information over time for every individual
m_M <- m_C <- m_E <-  matrix(nrow = n_i, ncol = n_t + 1,
dimnames = list(paste("ind"  , 1:n_i, sep = " "),
paste("cycle", 0:n_t, sep = " ")))
m_M[, 1] <- v_M_init          # initial health state
v_Ts     <- v_Ts_init         # initialize time since illnes onset
m_C[, 1] <- Costs(m_M[, 1])   # costs accrued  during cycle 0
m_E[, 1] <- Effs(m_M[, 1])    # QALYs accrued  during cycle 0
# open a loop for time running cycles 1 to n_t
for (t in 1:n_t) {
# calculate the transition probabilities for the cycle based on health state t
m_P <- Probs(m_M[, t], df_X, v_Ts)
# sample the current health state and store that state in matrix m_M
m_M[, t + 1]  <- samplev(m_P, 1)
# calculate costs per individual during cycle t + 1
m_C[, t + 1]  <- Costs(m_M[, t + 1])
# calculate QALYs per individual during cycle t + 1
m_E[, t + 1]  <- Effs (m_M[, t + 1])
# update time since illness onset for t + 1
v_Ts <- if_else(m_M[, t + 1] == "sick", v_Ts + 1, 0)
# Display simulation progress
if(t/(n_t/10) == round(t/(n_t/10), 0)) { # display progress every 10%
cat('\r', paste(t/n_t * 100, "% done", sep = " "))
}
} # close the loop for the time points
# calculate
tc <- m_C %*% v_dwc    # total (discounted) cost per individual
te <- m_E %*% v_dwe    # total (discounted) QALYs per individual
tc_hat <- mean(tc)     # average (discounted) cost
te_hat <- mean(te)     # average (discounted) QALYs
# store the results from the simulation in a list
results <- list(m_M = m_M, m_C = m_C, m_E = m_E, tc = tc , te = te, tc_hat = tc_hat,
te_hat = te_hat)
return(results)  # return the results
} # end of the MicroSim function
# By specifying all the arguments in the `MicroSim()` the simulation can be started
# Run the simulation model
outcomes <- MicroSim(n_i, df_X, seed = 1)
# Show results
results  <- data.frame("Total Cost" = outcomes$tc_hat, "Total QALYs" = outcomes$te_hat)
results
options(scipen = 999)
plot(density(outcomes$tc), main = paste("Total cost per person"), xlab = "Cost ($)")
plot(density(outcomes$te), main = paste("Total QALYs per person"), xlab = "QALYs")
plot_m_TR(outcomes$m_M)    # health state trace
rm(list = ls())      # clear memory (removes all the variables from the workspace)
# Uncomment if you don't have all required packages installed
# source("app0_packages_setup.R", echo = TRUE)
library(ggplot2)
library(dampack)
library(dplyr)
library(reshape2)
source("Functions.R")
set.seed(1)  # set the seed
# Model structure
v_n   <- c("healthy", "sick", "dead")          # vector with state names
n_s   <- length(v_n)                           # number of states
n_t   <- 60                                    # number of cycles
n_i   <- 10000                                 # number of individuals
d_r   <- 0.03                                  # discount rate of 3% per cycle
v_dwe <- v_dwc <- 1 / ((1 + d_r) ^ (0:n_t))    # discount weight
#### Deterministic analysis ####
# Transition probabilities
p_HS <- 0.05           # probability healthy -> sick
p_HD_female <- 0.0382  # probability health -> dead when female
p_HD_male   <- 0.0463  # probability health -> dead when male
m_p_HD      <- data.frame(Sex = c("Female", "Male"), p_HD = c(p_HD_female, p_HD_male))
# probability to die in sick state by cycle of being sick
p_SD <- c(0.1, 0.2, 0.3, 0.4, 0.5, rep(0.7, n_t - 5))
# Costs inputs
c_H  <- 1500      # cost of one cycle in healthy state
c_S  <- 5000      # cost of one cycle in sick state
c_D  <- 0
# utility inputs
u_H  <- 1         # utility when healthy
u_S  <- 0.85      # utility when sick
u_D  <- 0         # utility when dead
# randomly sample the sex of an individual (50% female)
v_sex <- sample(x = c("Female", "Male"), prob = c(0.5, 0.5), size = n_i, replace = TRUE)
df_X  <- data.frame(ID = 1:n_i, Sex = v_sex)
# Specify the initial health state of the individuals
# everyone begins in the healthy state (in this example)
v_M_init  <- rep("healthy", times = n_i)
v_Ts_init <- rep(0, n_i)  # a vector with the time of being sick at the start of the model
Probs <- function(M_t, df_X, v_Ts) {
# Arguments:
# M_t: health state occupied  at cycle t (character variable)
# df_X: data frame with individual characteristics data
# v_Ts: vector with the duration of being sick
# Returns:
# transition probabilities for that cycle
# create matrix of state transition probabilities
m_p_t           <- matrix(0, nrow = n_s, ncol = n_i)
# give the state names to the rows
rownames(m_p_t) <-  v_n
# lookup baseline probability and rate of dying based on individual characteristics
p_HD_all <- inner_join(df_X, m_p_HD, by = c("Sex") )
p_HD     <- p_HD_all[M_t == "healthy", "p_HD"]
# update m_p_t with the appropriate probabilities
# transition probabilities when healthy
m_p_t[, M_t == "healthy"] <- rbind(1 - p_HD - p_HS, p_HS, p_HD)
# transition probabilities when sick
m_p_t[, M_t == "sick"]    <- rbind(0, 1 - p_SD[v_Ts], p_SD[v_Ts])
# transition probabilities when dead
m_p_t[, M_t == "dead"]    <- rbind(0, 0, 1)
return(t(m_p_t))
}
Costs <- function (M_t) {
# M_t: current health state
c_t <- c()
c_t[M_t == "dead"]    <- c_D     # costs at dead state
c_t[M_t == "healthy"] <- c_H     # costs accrued by being healthy this cycle
c_t[M_t == "sick"]    <- c_S     # costs accrued by being sick this cycle
return(c_t)  # return costs accrued this cycle
}
Effs <- function (M_t) {
# M_t: current health state
q_t <- c()
q_t[M_t == "dead"]    <- u_D     # QALYs at dead state
q_t[M_t == "healthy"] <- u_H     # QALYs accrued by being healthy this cycle
q_t[M_t == "sick"]    <- u_S     # QALYs accrued by being sick this cycle
return(q_t)  # return the QALYs accrued this cycle
}
MicroSim <- function(n_i, df_X, seed = 1) {
# Arguments:
# n_i:     number of individuals
# df_X     data frame with individual data
# seed: default is 1
set.seed(seed) # set the seed
# create three matrices called m_M, m_C and m_E
# number of rows is equal to the n_i, the number of columns is equal to n_t
# (the initial state and all the n_t cycles)
# m_M is used to store the health state information over time for every individual
# m_C is used to store the costs information over time for every individual
# m_E is used to store the effects information over time for every individual
m_M <- m_C <- m_E <-  matrix(nrow = n_i, ncol = n_t + 1,
dimnames = list(paste("ind"  , 1:n_i, sep = " "),
paste("cycle", 0:n_t, sep = " ")))
m_M[, 1] <- v_M_init          # initial health state
v_Ts     <- v_Ts_init         # initialize time since illnes onset
m_C[, 1] <- Costs(m_M[, 1])   # costs accrued  during cycle 0
m_E[, 1] <- Effs(m_M[, 1])    # QALYs accrued  during cycle 0
# open a loop for time running cycles 1 to n_t
for (t in 1:n_t) {
# calculate the transition probabilities for the cycle based on health state t
m_P <- Probs(m_M[, t], df_X, v_Ts)
# sample the current health state and store that state in matrix m_M
m_M[, t + 1]  <- samplev(m_P, 1)
# calculate costs per individual during cycle t + 1
m_C[, t + 1]  <- Costs(m_M[, t + 1])
# calculate QALYs per individual during cycle t + 1
m_E[, t + 1]  <- Effs (m_M[, t + 1])
# update time since illness onset for t + 1
v_Ts <- if_else(m_M[, t + 1] == "sick", v_Ts + 1, 0)
# Display simulation progress
if(t/(n_t/10) == round(t/(n_t/10), 0)) { # display progress every 10%
cat('\r', paste(t/n_t * 100, "% done", sep = " "))
}
} # close the loop for the time points
# calculate
tc <- m_C %*% v_dwc    # total (discounted) cost per individual
te <- m_E %*% v_dwe    # total (discounted) QALYs per individual
tc_hat <- mean(tc)     # average (discounted) cost
te_hat <- mean(te)     # average (discounted) QALYs
# store the results from the simulation in a list
results <- list(m_M = m_M, m_C = m_C, m_E = m_E, tc = tc , te = te, tc_hat = tc_hat,
te_hat = te_hat)
return(results)  # return the results
} # end of the MicroSim function
# By specifying all the arguments in the `MicroSim()` the simulation can be started
# Run the simulation model
outcomes <- MicroSim(n_i, df_X, seed = 1)
# Show results
results  <- data.frame("Total Cost" = outcomes$tc_hat, "Total QALYs" = outcomes$te_hat)
results
options(scipen = 999)
plot(density(outcomes$tc), main = paste("Total cost per person"), xlab = "Cost ($)")
plot(density(outcomes$te), main = paste("Total QALYs per person"), xlab = "QALYs")
plot_m_TR(outcomes$m_M)    # health state trace
# Function that generates random sample for PSA
gen_psa <- function(n_sim = 1000, seed = 071818){
set.seed(seed) # set a seed to be able to reproduce the same results
df_psa <- data.frame(
# Transition probabilities (per cycle)
# probability to become sick when healthy
p_HS    = rbeta(n_sim, 24, 450)                        ,
# Cost vectors with length n_sim
# cost of remaining one cycle in state H
c_H     = rgamma(n_sim, shape = 225, scale = 6.65)     ,
# cost of remaining one cycle in state S1
c_S     = rgamma(n_sim, shape = 625, scale = 8)        ,
# cost of being in the death state
c_D     = 0                                            ,
# Utility vectors with length n_sim
# utility when healthy
u_H     = rbeta(n_sim, 9, 0.009)                       ,
# utility when sick
u_S     = rbeta(n_sim, 10, 1.75)                       ,
# utility when dead
u_D     = 0
)
return(df_psa)
}
gen_psa(n_sim = 10) # try it
# Decrease number of individuals since PSA takes a lot of time
n_i <- 1000
# Dynamic characteristics
# Specify the initial health state of the individuals
# everyone begins in the healthy state (in this example)
v_M_init <- rep("healthy", times = n_i)
v_Ts_init <- rep(0, n_i) # a vector with the time of being sick at the start of the model
# Number of PSA simulations
n_sim <- 500
# Generate PSA input dataset
df_psa_input <- gen_psa(n_sim = n_sim)
# First six observations
head(df_psa_input)
# Histogram of PSA parameters
# Make your 'Plots' window large in order to see the graphs!
ggplot(melt(df_psa_input, variable.name = "Parameter"), aes(x = value)) +
facet_wrap(~Parameter, scales = "free") +
geom_histogram(aes(y = ..density..)) +
theme_bw(base_size = 16)
# Initialize dataframes with PSA output
# Dataframe of costs and effectiveness
df_c <- df_e <- as.data.frame(matrix(0,
nrow = n_sim,
ncol = 1))
colnames(df_c) <- "Cost"
colnames(df_e) <- "Effectiveness"
source("Function_Microsim_3-state_time.R")
# Test microsimulation function
calculate_ce_out(df_psa_input[1, ], n_wtp = 10000)
for(i in 1:n_sim){
df_out_temp <- calculate_ce_out(df_psa_input[i, ], n_wtp = 10000)
df_c[i, ] <- df_out_temp$Cost
df_e[i, ] <- df_out_temp$Effect
# Display simulation progress
if(i/(n_sim/10) == round(i/(n_sim/10), 0)) { # display progress every 10%
cat('\r', paste('            ', 'Overall progress: ', i/n_sim * 100, "% done",
sep = " "))
}
}
# make an PSA object using dampack
out_psa  <- make_psa_obj(df_c, df_e, df_psa_input, strategies = NULL, "$")
# Total cost and effectiveness
results  <- data.frame("Total Cost" = mean(out_psa$cost[, 1]),
"Total QALYs" = mean(out_psa$effectiveness[, 1]))
results
# Cost-Effectiveness Scatter plot
plot(out_psa)
rm(list = ls())      # clear memory (removes all the variables from the workspace)
# Uncomment if you don't have all required packages installed
# source("app0_packages_setup.R", echo = TRUE)
library(ggplot2)
library(dampack)
library(dplyr)
library(reshape2)
source("Functions.R")
rm(list = ls())      # clear memory (removes all the variables from the workspace)
# Uncomment if you don't have all required packages installed
# source("app0_packages_setup.R", echo = TRUE)
library(ggplot2)
library(dampack)
library(dplyr)
library(reshape2)
source(here::here("functions", "Functions.R"))
setwd("C:/Users/Alan Yang/Desktop/course_materials_central_repo/Microsimulation/Microsim Sick-Sicker/solutions")
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)
if (!require("haven")) install.packages("haven"); library(haven)
if (!require("tidyverse")) install.packages("tidyverse"); library(tidyverse)
if (!require("tableone")) install.packages("tableone"); library(tableone)
if (!require("knitr")) install.packages('knitr'); library(knitr)
rm(list = ls())
#df <- read_sas('H:/Musculoskeletal/work/Data cleaning/data/fspp4_merged_30jun2019.sas7bdat')
df <- read_sas('F:/Musculoskeletal/work/Data cleaning/data/fumar31.sas7bdat')
df <- as.data.frame(df)
df <- df[!is.na(df$PatientAge),]
### gender
# check missing
unique(df$PatientGender) # should have no missing
# define categories
df$PatientGender1 <- rep('Male', nrow(df))
df$PatientGender1[df$PatientGender==1] <- 'Female'
df$PatientGender1 <- as.factor(df$PatientGender1)
# level + re-level
df$PatientGender1 <- factor(df$PatientGender1, levels(df$PatientGender1)[c(2,1)])
levels(df$PatientGender1)
### marital status
# check missing
unique(df$marital)
# define categories
df$marital1 <- rep(NA, nrow(df))
df$marital1[df$marital == 1] <- 'single'
df$marital1[df$marital == 2 | df$marital == 3] <- 'married/common_law'
df$marital1[df$marital == 4 | df$marital ==  5 | df$marital ==  6] <- 'separated/divorced/widowed'
# level + re-level
df$marital1 <- as.factor(df$marital1)
df$marital1 <- factor(df$marital1, levels(df$marital1)[c(3,1,2)])
levels(df$marital1)
### living location
# check missing
unique(df$whereliv)
# define categories
df$whereliv1 <- rep(NA, nrow(df))
df$whereliv1[df$whereliv == 1] <- 'Alone in a house or apartment'
df$whereliv1[df$whereliv == 2] <- 'With a spouse, family member or roommate in a house or an apartment'
df$whereliv1[df$whereliv == 3] <- 'In a nursing home or long-term care home'
df$whereliv1[df$whereliv == 4] <- 'Other residential facility (i.e., seniors residence, retirement home, supportive housing)'
# could include the option 'other' (df$whereliv == 5)
# level + re-level
df$whereliv1 <- as.factor(df$whereliv1)
df$whereliv1 <- factor(df$whereliv1, levels(df$whereliv1)[c(1,4,2,3)])
levels(df$whereliv1)
df$fractype <- rep('None', nrow(df))
df$fracnum <- rep(0, nrow(df)) # assign level number so can automate the ordering based on diff datasets
# first identify those who have multiple fractures
frac <- as.data.frame(df[, names(df) %in% c('wrist','elbow','shoulder','spine','pelvis','hip','femur','tibfib','clavicle','obone')])
rowsums <- rowSums(frac, na.rm=T)
multfrac <- which(rowsums > 1)
# for each patient, set his/her fracture type
for (i in 1:nrow(df)) {
if (!is.na(df$wrist[i])) {
df$fractype[i] <- 'wrist'
df$fracnum[i] <- 1
}
else if (!is.na(df$elbow[i])) {
df$fractype[i] <- 'elbow'
df$fracnum[i] <- 2
}
else if (!is.na(df$shoulder[i])) {
df$fractype[i] <- 'shoulder'
df$fracnum[i] <- 3
}
else if (!is.na(df$spine[i])) {
df$fractype[i] <- 'spine'
df$fracnum[i] <- 4
}
else if (!is.na(df$pelvis[i])) {
df$fractype[i] <- 'pelvis'
df$fracnum[i] <- 5
}
else if (!is.na(df$hip[i])) {
df$fractype[i] <- 'hip'
df$fracnum[i] <- 6
}
else if (!is.na(df$femur[i])) {
df$fractype[i] <- 'femur'
df$fracnum[i] <- 7
}
else if (!is.na(df$tibfib[i])) {
df$fractype[i] <- 'tibfib'
df$fracnum[i] <- 8
}
else if (!is.na(df$clavicle[i])) {
df$fractype[i] <- 'clavicle'
df$fracnum[i] <- 9
}
else if (!is.na(df$obone[i])) {
df$fractype[i] <- 'other'
df$fracnum[i] <- 10
}
}
df <- df[df$fractype != 'None',]  # this is to make sure everyone in our sample had a index fracture
# set the patients with multiple fractures to 'multiple fracture' category
df$fractype[multfrac] <- 'multiple'
df$fracnum[multfrac] <- 11
# df$fractype <- as.factor(df$fractype)
# levels(df$fractype)
df$fracnum <- as.factor(df$fracnum)
levels(df$fracnum)
df$fractype_collapsed <- df$fractype
df$fractype_collapsed[!df$fractype %in% c('wrist', 'spine', 'hip')] <- 'other'
df$fractype_collapsed <- factor(as.character(df$fractype_collapsed), levels=c('wrist','spine','hip','other'))
### previous fracture
# check missing
unique(df$obreak)
df$obreak1 <- rep(NA, nrow(df))
# df$obreak1[df$obreak %in% c(0,2,3,4)] <- 'No'
df$obreak1[df$obreak == 0] <- 'No'
df$obreak1[df$obreak== 1] <- 'Yes'
# level + re-level
df$obreak1 <- as.factor(df$obreak1)
levels(df$obreak1)
# parent history of hip fracture
# check missing
unique(df$parentbreak)
df$parentbreak1 <- rep(NA, nrow(df))
# df$parentbreak1[df$parentbreak %in% c(0,2,3,4)] <- 'No'
df$parentbreak1[df$parentbreak == 0] <- 'No'
df$parentbreak1[df$parentbreak== 1] <- 'Yes'
# level + re-level
df$parentbreak1 <- as.factor(df$parentbreak1)
levels(df$parentbreak1)
# history of falls (in past year)
# check missing
unique(df$ptfall)
df$ptfall1 <- rep(NA, nrow(df))
# df$ptfall1[df$ptfall %in% c(0,2,3,4)] <- 'No'
df$ptfall1[df$ptfall == 0] <- 'No'
df$ptfall1[df$ptfall== 1] <- 'Yes'
# level + re-level
df$ptfall1 <- as.factor(df$ptfall1)
levels(df$ptfall1)
# at baseline
# check missing
unique(df$baselinerisk)
df$baselinerisk1 <- rep(NA, nrow(df))
df$baselinerisk1[df$baselinerisk=='highrisk'] <- 'highrisk'
df$baselinerisk1[df$baselinerisk=='nonhighrisk'] <- 'nonhighrisk'
# level + re-level
df$baselinerisk1 <- as.factor(df$baselinerisk1)
df$baselinerisk1 <- factor(df$baselinerisk1, levels(df$baselinerisk1)[c(2,1)])
levels(df$baselinerisk1)
# at FU
# check missing
unique(df$FUrisk)
df$FUrisk1 <- rep(NA, nrow(df))
df$FUrisk1[df$FUrisk=='highrisk'] <- 'highrisk'
df$FUrisk1[df$FUrisk=='nonhighrisk'] <- 'nonhighrisk'
# level + re-level
df$FUrisk1 <- as.factor(df$FUrisk1)
df$FUrisk1 <- factor(df$FUrisk1, levels(df$FUrisk1)[c(2,1)])
levels(df$FUrisk1)
# at FU, deemed by the program
df$FUrisk_deemed <- rep(NA, nrow(df))
df$FUrisk_deemed[!is.na(df$FUrisk1)] <- 'nonmissing'
df$FUrisk_deemed[df$baselinerisk == 'nonhighrisk' & df$FUrisk == 'highrisk'] <- 'highrisk'
df$FUrisk_deemed <- as.factor(df$FUrisk_deemed)
df$FUrisk_deemed <- factor(df$FUrisk_deemed, levels(df$FUrisk_deemed)[c(2,1)])
levels(df$FUrisk_deemed)
# at FU
# check missing
unique(df$ontxatFU1)
df$ontxatFU1a <- rep(NA, nrow(df))
df$ontxatFU1a[df$ontxatFU1=='2.not'] <- 'No'
df$ontxatFU1a[df$ontxatFU1=='1.yes'] <- 'Yes'
# level + re-level
df$ontxatFU1a <- as.factor(df$ontxatFU1a)
levels(df$ontxatFU1a)
# 80+ vs. <80
df$over80 <- rep(NA, nrow(df))
df$over80[!is.na(df$PatientAge) & df$PatientAge < 80] <- '50-79'
df$over80[!is.na(df$PatientAge) & df$PatientAge >= 80] <- '80+'
df$over80 <- as.factor(df$over80)
# consent vs. no consent
df$consentt <- rep(NA, nrow(df))
df$consentt[df$rsrch_data_use==1] <- 'Yes'
df$consentt[is.na(df$rsrch_data_use) | df$rsrch_data_use %in% c(0,2)] <- 'No'
df$consentt <- as.factor(df$consentt)
df$consentt <- factor(df$consentt, levels(df$consentt)[c(2,1)])
# FU vs. no FU
df$have_FU <- rep("No", nrow(df))
df$have_FU[df$have_anyFU==1] <- "Yes"
df$have_FU <- as.factor(df$have_FU)
df$have_FU <- factor(df$have_FU, levels(df$have_FU)[c(2,1)])
library(dplyr)
df_main2 <- df %>% filter(rsrch_data_use==1) %>%
filter(ontxatbase != 'yes') %>%
filter(baselinerisk != "" & FUrisk == 'highrisk')
myVars22 <- c('PatientAge', 'PatientGender1', 'marital1', 'whereliv1',
'fractype_collapsed', 'obreak1', 'parentbreak1', 'ptfall1',
'ontxatFU1a')
tab5c <- CreateTableOne(vars = myVars22, strata='have_FU', includeNA=F, data=droplevels(df_main2), test = T, testExact=fisher.test)
table5c <- print(tab5c, printToggle=T, noSpaces=T, missing=T, quote=F,
catDigits=1, contDigits=1, explain=F, showAllLevels=F)
colnames(table5c) <- c('Have FU','No FU', 'P-value', 'Test', 'Missing %')
rownames(table5c) <- c("N", "Age (mean, sd)", "Gender - female (n, %)", "Marital status  (n, %)", "single", "married/common law", "separated/divorced/widowed", 'Living location (n, %)', "alone in a house or apartment", 'with a spouse, family member or roommate in a house or an apartment', 'in a nursing home or long-term care home', 'other residential facility (seniors residence, retirement home, supportive housing)', 'Index fracture (n, %)', 'only wrist', "only spine", "only hip", "other",  "Previous fracture  (n, %)", "Parent had a hip fracture (n, %)", "History of falls (n, %)", "Initiation of bone active medication  (n, %)")
knitr::kable(table5c, digits=1)
df_main2_80 <- df_main2[df_main2$over80=="Yes",]
df_main2_50 <- df_main2[df_main2$over80=="No",]
myVars22 <- c('PatientAge', 'PatientGender1', 'marital1', 'whereliv1',
'fractype_collapsed', 'obreak1', 'parentbreak1', 'ptfall1',
'ontxatFU1a')
df_main2_80$have_FU
df_main2$over80
df_main2$over80a
df_main2_80 <- df_main2[df_main2$over80=="80+",]
df_main2_50 <- df_main2[df_main2$over80=="50-79",]
myVars22 <- c('PatientAge', 'PatientGender1', 'marital1', 'whereliv1',
'fractype_collapsed', 'obreak1', 'parentbreak1', 'ptfall1',
'ontxatFU1a')
tab5c <- CreateTableOne(vars = myVars22, strata='have_FU', includeNA=F, data=droplevels(df_main2_80), test = T, testExact=fisher.test)
table5c <- print(tab5c, printToggle=T, noSpaces=T, missing=T, quote=F,
catDigits=1, contDigits=1, explain=F, showAllLevels=F)
colnames(table5c) <- c('Have FU','No FU', 'P-value', 'Test', 'Missing %')
rownames(table5c) <- c("N", "Age (mean, sd)", "Gender - female (n, %)", "Marital status  (n, %)", "single", "married/common law", "separated/divorced/widowed", 'Living location (n, %)', "alone in a house or apartment", 'with a spouse, family member or roommate in a house or an apartment', 'in a nursing home or long-term care home', 'other residential facility (seniors residence, retirement home, supportive housing)', 'Index fracture (n, %)', 'only wrist', "only spine", "only hip", "other",  "Previous fracture  (n, %)", "Parent had a hip fracture (n, %)", "History of falls (n, %)", "Initiation of bone active medication  (n, %)")
knitr::kable(table5c, digits=1)
tab5c <- CreateTableOne(vars = myVars22, strata='have_FU', includeNA=F, data=droplevels(df_main2_50), test = T, testExact=fisher.test)
table5c <- print(tab5c, printToggle=T, noSpaces=T, missing=T, quote=F,
catDigits=1, contDigits=1, explain=F, showAllLevels=F)
82+36
colnames(table5c) <- c('Have FU','No FU', 'P-value', 'Test', 'Missing %')
rownames(table5c) <- c("N", "Age (mean, sd)", "Gender - female (n, %)", "Marital status  (n, %)", "single", "married/common law", "separated/divorced/widowed", 'Living location (n, %)', "alone in a house or apartment", 'with a spouse, family member or roommate in a house or an apartment', 'in a nursing home or long-term care home', 'other residential facility (seniors residence, retirement home, supportive housing)', 'Index fracture (n, %)', 'only wrist', "only spine", "only hip", "other",  "Previous fracture  (n, %)", "Parent had a hip fracture (n, %)", "History of falls (n, %)", "Initiation of bone active medication  (n, %)")
knitr::kable(table5c, digits=1)
784/(784+118)
118/(784+118)
15/82
569/(569+82)
82/(569+82)
215/(215+36)
36/(215+36)
28000/5
