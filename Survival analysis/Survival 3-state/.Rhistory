m_M  <-  matrix(nrow = n_i, ncol = length(times) ,
dimnames = list(paste("ind" , 1:n_i, sep = " "),
paste("year", times, sep = " ")))
m_M[, 1] <- v_M_init           # initial health state for individual i
v_Ts     <- v_Ts_init          # initialize time since illness onset for individual i
# open a loop for time running cycles 1 to n_t
for (t in 1:(length(times)-1)) {
# calculate the transition probabilities for the cycle based on health state t
m_p <- Probs(m_M[, t], v_Ts, t)
# sample the current health state and store that state in matrix m_M
m_M[, t + 1]  <- samplev(m_p, 1)
# update time since illness onset for t + 1
v_Ts <- ifelse(m_M[, t + 1] == "sick", v_Ts + 1, 0)
# Display simulation progress
if(t %in% seq(1,(length(times)),10)) { # display progress every 10%
cat('\r', paste(round(t/length(times)*100,0), "% done", sep = " "))
} else if (t == (length(times)-1)) {cat('\r', paste("100% done"))}
} # close the loop for the time points
# store the results from the simulation in a list
results <- list(m_M = m_M)
return(results)  # return the results
} # end of the MicroSim function
# Run the simulation model
Micro_data <- MicroSim(n_i, seed = 1)
# create the microsimulation trace
m_M_Micro <- t(apply(Micro_data$m_M, 2, function(x) table(factor(x, levels = v_n,
ordered = TRUE))))
m_M_Micro <- m_M_Micro / n_i    # calculate the proportion of individuals
colnames(m_M_Micro) <- v_n
rownames(m_M_Micro) <- paste("Cycle", times, sep = " ")
# Calculate trace for the real data
m_M_data <- transitionProbabilities(generate$cohort, times = times)@probabilities
# visually compare all methods
matplot(times,m_M_data, type='l', lty = 1, col = 1, ylab= "proportion of cohort", xlab = "Time",
main = "Trace comparisons",xlim=c(0,25))
matlines(times, m_M_DES,   col = 2, lty = 1)
matlines(times, m_M_Micro, col = 3, lty = 1)
matlines(times, m_M_PSM,   col = 4, lty = 1)
legend("right", c("True Data", "DES","Microsim",  "PSM"),
col = 1:4, lty = rep(1,4), bty= "n")
rm(list = ls())      # clear memory (removes all the variables from the workspace)
if (!require('here')) install.packages('here'); library(gems)
if (!require('gems')) install.packages('gems'); library(gems)
if (!require('msm')) install.packages('msm'); library(msm)
if (!require('flexsurv')) install.packages('flexsurv'); library(flexsurv)
if (!require('dplyr')) install.packages('dplyr'); library(dplyr)
if (!require('mstate')) install.packages('mstate'); library(mstate)
source("functions.R")
# number of states in the model
v_n       <- c("healthy", "sick", "dead")  # state names
n_s       <- length(v_n)                   # No of states
n_i       <- 5000                          # number of simulations
c_l       <- 1 / 12                        # cycle length (a month)
n_t       <- 40                            # number of years (20 years)
times     <- seq(0, n_t, c_l)              # the cycles in years
set.seed(2009)                             # set the seed
tmat <- matrix(NA, n_s, n_s, dimnames = list(v_n,v_n))
tmat["healthy", "sick"]  <- 1
tmat["healthy", "dead"]  <- 2
tmat["sick"   , "dead"]  <- 3
n_pat     <- 550                      # cohort size
n_years   <- 60                       # number of years
generate  <- gen_data(n_pat,n_years)  # generates true, censored and OS/PFS data
true_data <- generate$true_data       # stores the true data
sim_data  <- generate$sim_data        # stores the censored data
status    <- generate$status          # stores the censoring status
OS_PFS_data <- generate$OS_PFS_data   # store the OS / PFS structured data
head(true_data)
head(sim_data)
head(status)
head(OS_PFS_data)
fit_KM <- survfit (Surv(time = OS_time, event= OS_status)~ 1 , data = OS_PFS_data,
type ="fleming-harrington")
fit_weib <- flexsurvreg(Surv(time = OS_time, event= OS_status)~ 1 , data = OS_PFS_data,
dist = "weibull")
plot(fit_KM, mark.time = T)
plot(fit_weib)
# fit all parametric models to the data and extract the AIC/BIC.
# Select the one with the most appropriate fit
# Repeat for PFS and OS
fit_PFS  <- fit.fun(time ="PFS_time", status = "PFS_status", data = OS_PFS_data,
times = times, extrapolate = T)
fit_OS   <- fit.fun(time = "OS_time", status = "OS_status" , data = OS_PFS_data,
times = times, extrapolate = T)
best_PFS <- fit_PFS[["Weibull"]]
best_OS  <- fit_OS [["Weibull"]]
# construct a partitioned survival model out of the fitted models
m_M_PSM <- partsurv(best_PFS, best_OS, time = times)$trace
# The existing functions in R require the data in a long rather than a wide format
# convert the data in a way that flexsurv understands using the mstate package
data_long       <- msprep(time = sim_data, status = status, trans = tmat )
data_long$trans <- as.factor(data_long$trans) # convert trans to a factor
data_long$from  <- case_when(data_long$from == 1 ~ "healthy",
data_long$from == 2 ~ "sick",
data_long$from == 3 ~ "dead")
data_long$to    <- case_when(data_long$to == 1 ~ "healthy",
data_long$to == 2 ~ "sick",
data_long$to == 3 ~ "dead")
# fit all parametric multistate models simultaneously to the data and extract the AIC/BIC
# Select the one with the lowest AIC
fits <- fit.mstate(time ="time", status = "status", trans, data = data_long,
times = times, extrapolate = T )
best.fit <- fits[["Loglogistic"]]
# Construct a DES model out of the simultaneously fitted multistate model
DES_data <- sim.fmsm(best.fit, start = 1, t = n_years, trans = tmat, M = n_i)
m_M_DES  <- trace.DES(DES_data, n_i  = n_i , times = times, tmat = tmat)
# Multistate models can be fitted independently for each transition.This is more flexible!
# Create subsets for each transition
data_HS <- subset(data_long, trans == 1)
data_HD <- subset(data_long, trans == 2)
data_SD <- subset(data_long, trans == 3)
# fit independent models for each transition and pick the one with the lowest AIC
fit_HS <- fit.fun(time = "time", status = "status", data = data_HS, times = times,
extrapolate = T)
fit_HD <- fit.fun(time = "time", status = "status", data = data_HD, times = times,
extrapolate = T)
fit_SD <- fit.fun(time = "time", status = "status", data = data_SD, times = times,
extrapolate = T)
best.fit_HS <- fit_HS[["Gamma"]]
best.fit_HD <- fit_HD[["Weibull"]]
best.fit_SD <- fit_SD[["Lognormal"]]
# Extract transition probabilities from the best fitting models
p_HS <- flexsurvreg_prob(object = best.fit_HS, times = times)
p_HD <- flexsurvreg_prob(object = best.fit_HD, times = times)
p_SD <- flexsurvreg_prob(object = best.fit_SD, times = times)
# everyone starts in the "healthy" state and therefore has not spent time in "sick"
v_M_init  <- rep("healthy", times = n_i)
v_Ts_init <- rep(0, n_i)  # a vector with the time of being sick at the start of the model
# function that generates the transition probabilities per cycle
Probs <- function(M_t, v_Ts, t) {
# Arguments:
# M_t: health state occupied by at cycle t (character variable)
# v_Ts: vector with the duration of being sick
# t:     current cycle
# Returns:
# transition probabilities for that cycle
# create matrix of state transition probabilities
m_p_t           <- matrix(0, nrow = n_s, ncol = n_i)
# give the state names to the rows
rownames(m_p_t) <-  v_n
# update m_p_t with the appropriate probabilities
# transition probabilities when healthy
m_p_t[, M_t == "healthy"] <- rbind(1 - p_HD[t] - p_HS[t], p_HS[t], p_HD[t])
# transition probabilities when sick
m_p_t[, M_t == "sick"]    <- rbind(0, 1 - p_SD[v_Ts], p_SD[v_Ts])
# transition probabilities when dead
m_p_t[, M_t == "dead"]    <- rbind(0, 0, 1)
return(t(m_p_t))
}
MicroSim <- function(n_i,  seed = 1) {
# Arguments:
# n_i:     number of individuals
# seed:    default is 1
set.seed(seed) # set the seed
# m_M is used to store the health state information over time for every individual
times     <- seq(0, n_t, c_l)  # the cycles in years
m_M  <-  matrix(nrow = n_i, ncol = length(times) ,
dimnames = list(paste("ind" , 1:n_i, sep = " "),
paste("year", times, sep = " ")))
m_M[, 1] <- v_M_init           # initial health state for individual i
v_Ts     <- v_Ts_init          # initialize time since illness onset for individual i
# open a loop for time running cycles 1 to n_t
for (t in 1:(length(times)-1)) {
# calculate the transition probabilities for the cycle based on health state t
m_p <- Probs(m_M[, t], v_Ts, t)
# sample the current health state and store that state in matrix m_M
m_M[, t + 1]  <- samplev(m_p, 1)
# update time since illness onset for t + 1
v_Ts <- ifelse(m_M[, t + 1] == "sick", v_Ts + 1, 0)
# Display simulation progress
if(t %in% seq(1,(length(times)),10)) { # display progress every 10%
cat('\r', paste(round(t/length(times)*100,0), "% done", sep = " "))
} else if (t == (length(times)-1)) {cat('\r', paste("100% done"))}
} # close the loop for the time points
# store the results from the simulation in a list
results <- list(m_M = m_M)
return(results)  # return the results
} # end of the MicroSim function
# Run the simulation model
Micro_data <- MicroSim(n_i, seed = 1)
# create the microsimulation trace
m_M_Micro <- t(apply(Micro_data$m_M, 2, function(x) table(factor(x, levels = v_n,
ordered = TRUE))))
m_M_Micro <- m_M_Micro / n_i    # calculate the proportion of individuals
colnames(m_M_Micro) <- v_n
rownames(m_M_Micro) <- paste("Cycle", times, sep = " ")
rm(list = ls())      # clear memory (removes all the variables from the workspace)
if (!require('here')) install.packages('here'); library(gems)
if (!require('gems')) install.packages('gems'); library(gems)
if (!require('msm')) install.packages('msm'); library(msm)
if (!require('flexsurv')) install.packages('flexsurv'); library(flexsurv)
if (!require('dplyr')) install.packages('dplyr'); library(dplyr)
if (!require('mstate')) install.packages('mstate'); library(mstate)
source("functions.R")
v_n       <- c("healthy", "sick", "dead")  # state names
n_s       <- length(v_n)                   # No of states
c_l       <- 1 / 12                        # cycle length (a month)
n_t       <- 40                            # number of years (20 years)
times     <- seq(0, n_t, c_l)              # the cycles in years
set.seed(2009)                             # set the seed
c_H       <- 200                           # cost of remaining one cycle healthy
c_S       <- 500                           # cost of remaining one cycle sick
c_D       <- 0                             # cost of remaining one cycle dead
v_c       <- c(c_H, c_S, c_D)              # store in a vector
u_H       <- 0.75                          # utility when healthy
u_S       <- 0.30                          # utility when sick
u_D       <- 0                             # utility when dead
v_u       <- c(u_H, u_S, u_D)              # store in a vector
v_dw      <- 1 / (1 + d_r) ^ (times)       # discount weight
rm(list = ls())      # clear memory (removes all the variables from the workspace)
if (!require('here')) install.packages('here'); library(gems)
if (!require('gems')) install.packages('gems'); library(gems)
if (!require('msm')) install.packages('msm'); library(msm)
if (!require('flexsurv')) install.packages('flexsurv'); library(flexsurv)
if (!require('dplyr')) install.packages('dplyr'); library(dplyr)
if (!require('mstate')) install.packages('mstate'); library(mstate)
source("functions.R")
v_n       <- c("healthy", "sick", "dead")  # state names
n_s       <- length(v_n)                   # No of states
c_l       <- 1 / 12                        # cycle length (a month)
n_t       <- 20                            # number of years (20 years)
times     <- seq(0, n_t, c_l)              # the cycles in years
d_r       <- 0.03                          # discount rate
set.seed(2009)                             # set the seed
c_H       <- 200                           # cost of remaining one cycle healthy
c_S       <- 500                           # cost of remaining one cycle sick
c_D       <- 0                             # cost of remaining one cycle dead
v_c       <- c(c_H, c_S, c_D)              # store in a vector
u_H       <- 0.75                          # utility when healthy
u_S       <- 0.30                          # utility when sick
u_D       <- 0                             # utility when dead
v_u       <- c(u_H, u_S, u_D)              # store in a vector
v_dw      <- 1 / (1 + d_r) ^ (times)       # discount weight
# Create IPD and KM data for the OS curves
digitise("OS_Examp.txt", "OS_Examp_AtRisk.txt", nevent_inp= 52,
km_output = "KMdata_OS.txt", ipd_output = "IPDdata_OS.txt")
# Create IPD and KM data for the PFS curves (there have been 99 events in the cohort)
digitise("PFS_Examp.txt", "PFS_Examp_AtRisk.txt", nevent_inp=99,
km_output = "KMdata_PFS.txt", ipd_output = "IPDdata_PFS.txt")
# Link the IPD files across the two arms of the trial for OS and PFS
IPD_OS  <- make.ipd(ipd_files = c("IPDdata_OS.txt"), ctr = 1,
var.labs = c("time","event","arm"))
IPD_PFS <- make.ipd(ipd_files = c("IPDdata_PFS.txt"), ctr = 1,
var.labs = c("time","event","arm"))
# fit all parametric models to the data and extract the AIC/BIC
# Select the one with the most appropriate fit
# Repeat for PFS and OS
fit_PFS  <- fit.fun(time ="time", status = "event", data = IPD_PFS, times = times,
extrapolate = T)
fit_OS   <- fit.fun(time = "time", status = "event" , data = IPD_OS, times = times,
extrapolate = T)
best_PFS <- fit_PFS[["Weibull"]]
best_OS  <- fit_OS [["Weibull"]]
# construct a partitioned survival model out of the fitted models
m_M_PSM <- partsurv(best_PFS,best_OS, time = times)$trace
matplot(m_M_PSM, type="l")
legend("right",v_n, col= 1:3, lty=1:3, bty="n")
v_c_t <- m_M_PSM %*% v_c
v_u_t <- m_M_PSM %*% v_u
tot_c <-  t(v_c_t) %*% v_dw
tot_u <-  t(v_u_t) %*% v_dw
# display results
tot_c
tot_u
v_c_t <- m_M_PSM %*% v_c
v_u_t <- m_M_PSM %*% v_u
tot_c <-  t(v_c_t) %*% v_dw
tot_u <-  t(v_u_t) %*% v_dw
# display results
results <- data.frame(Total_cost = tot_c, Total_QALYs = tot_u)
results
v_c_t <- m_M_PSM %*% v_c
v_u_t <- m_M_PSM %*% v_u
tot_c <-  t(v_c_t) %*% v_dw
tot_u <-  t(v_u_t) %*% v_dw
# display results
results <- data.frame(Total_Cost = tot_c, Total_QALYs = tot_u)
results
source(here::here("functions", "functions.R"))
rm(list = ls())      # clear memory (removes all the variables from the workspace)
if (!require('here')) install.packages('here'); library(gems)
if (!require('gems')) install.packages('gems'); library(gems)
if (!require('msm')) install.packages('msm'); library(msm)
if (!require('flexsurv')) install.packages('flexsurv'); library(flexsurv)
if (!require('dplyr')) install.packages('dplyr'); library(dplyr)
if (!require('mstate')) install.packages('mstate'); library(mstate)
source(here::here("functions", "functions.R"))
v_n       <- c("healthy", "sick", "dead")  # state names
n_s       <- length(v_n)                   # No of states
n_i       <- 5000                          # number of simulations
c_l       <- 1 / 12                        # cycle length (a month)
n_t       <- 40                            # number of years (20 years)
times     <- seq(0, n_t, c_l)              # the cycles in years
set.seed(2009)                             # set the seed
tmat <- matrix(NA, n_s, n_s, dimnames = list(v_n,v_n))
tmat["healthy", "sick"]  <- 1
tmat["healthy", "dead"]  <- 2
tmat["sick"   , "dead"]  <- 3
n_pat     <- 550                      # cohort size
n_years   <- 60                       # number of years
generate  <- gen_data(n_pat,n_years)  # generates true, censored and OS/PFS data
true_data <- generate$true_data       # stores the true data
sim_data  <- generate$sim_data        # stores the censored data
status    <- generate$status          # stores the censoring status
OS_PFS_data <- generate$OS_PFS_data   # store the OS / PFS structured data
head(true_data)
head(sim_data)
head(status)
head(OS_PFS_data)
fit_KM <- survfit (Surv(time = OS_time, event= OS_status)~ 1 , data = OS_PFS_data,
type ="fleming-harrington")
fit_weib <- flexsurvreg(Surv(time = OS_time, event= OS_status)~ 1 , data = OS_PFS_data,
dist = "weibull")
plot(fit_KM, mark.time = T)
plot(fit_weib)
# fit all parametric models to the data and extract the AIC/BIC.
# Select the one with the most appropriate fit
# Repeat for PFS and OS
fit_PFS  <- fit.fun(time ="PFS_time", status = "PFS_status", data = OS_PFS_data,
times = times, extrapolate = T)
fit_OS   <- fit.fun(time = "OS_time", status = "OS_status" , data = OS_PFS_data,
times = times, extrapolate = T)
best_PFS <- fit_PFS[["Weibull"]]
best_OS  <- fit_OS [["Weibull"]]
# construct a partitioned survival model out of the fitted models
m_M_PSM <- partsurv(best_PFS, best_OS, time = times)$trace
# The existing functions in R require the data in a long rather than a wide format
# convert the data in a way that flexsurv understands using the mstate package
data_long       <- msprep(time = sim_data, status = status, trans = tmat )
data_long$trans <- as.factor(data_long$trans) # convert trans to a factor
data_long$from  <- case_when(data_long$from == 1 ~ "healthy",
data_long$from == 2 ~ "sick",
data_long$from == 3 ~ "dead")
data_long$to    <- case_when(data_long$to == 1 ~ "healthy",
data_long$to == 2 ~ "sick",
data_long$to == 3 ~ "dead")
# fit all parametric multistate models simultaneously to the data and extract the AIC/BIC
# Select the one with the lowest AIC
fits <- fit.mstate(time ="time", status = "status", trans, data = data_long,
times = times, extrapolate = T )
best.fit <- fits[["Loglogistic"]]
# Construct a DES model out of the simultaneously fitted multistate model
DES_data <- sim.fmsm(best.fit, start = 1, t = n_years, trans = tmat, M = n_i)
m_M_DES  <- trace.DES(DES_data, n_i  = n_i , times = times, tmat = tmat)
# Multistate models can be fitted independently for each transition.This is more flexible!
# Create subsets for each transition
data_HS <- subset(data_long, trans == 1)
data_HD <- subset(data_long, trans == 2)
data_SD <- subset(data_long, trans == 3)
# fit independent models for each transition and pick the one with the lowest AIC
fit_HS <- fit.fun(time = "time", status = "status", data = data_HS, times = times,
extrapolate = T)
fit_HD <- fit.fun(time = "time", status = "status", data = data_HD, times = times,
extrapolate = T)
fit_SD <- fit.fun(time = "time", status = "status", data = data_SD, times = times,
extrapolate = T)
best.fit_HS <- fit_HS[["Gamma"]]
best.fit_HD <- fit_HD[["Weibull"]]
best.fit_SD <- fit_SD[["Lognormal"]]
# Extract transition probabilities from the best fitting models
p_HS <- flexsurvreg_prob(object = best.fit_HS, times = times)
p_HD <- flexsurvreg_prob(object = best.fit_HD, times = times)
p_SD <- flexsurvreg_prob(object = best.fit_SD, times = times)
# everyone starts in the "healthy" state and therefore has not spent time in "sick"
v_M_init  <- rep("healthy", times = n_i)
v_Ts_init <- rep(0, n_i)  # a vector with the time of being sick at the start of the model
# function that generates the transition probabilities per cycle
Probs <- function(M_t, v_Ts, t) {
# Arguments:
# M_t: health state occupied by at cycle t (character variable)
# v_Ts: vector with the duration of being sick
# t:     current cycle
# Returns:
# transition probabilities for that cycle
# create matrix of state transition probabilities
m_p_t           <- matrix(0, nrow = n_s, ncol = n_i)
# give the state names to the rows
rownames(m_p_t) <-  v_n
# update m_p_t with the appropriate probabilities
# transition probabilities when healthy
m_p_t[, M_t == "healthy"] <- rbind(1 - p_HD[t] - p_HS[t], p_HS[t], p_HD[t])
# transition probabilities when sick
m_p_t[, M_t == "sick"]    <- rbind(0, 1 - p_SD[v_Ts], p_SD[v_Ts])
# transition probabilities when dead
m_p_t[, M_t == "dead"]    <- rbind(0, 0, 1)
return(t(m_p_t))
}
MicroSim <- function(n_i,  seed = 1) {
# Arguments:
# n_i:     number of individuals
# seed:    default is 1
set.seed(seed) # set the seed
# m_M is used to store the health state information over time for every individual
times     <- seq(0, n_t, c_l)  # the cycles in years
m_M  <-  matrix(nrow = n_i, ncol = length(times) ,
dimnames = list(paste("ind" , 1:n_i, sep = " "),
paste("year", times, sep = " ")))
m_M[, 1] <- v_M_init           # initial health state for individual i
v_Ts     <- v_Ts_init          # initialize time since illness onset for individual i
# open a loop for time running cycles 1 to n_t
for (t in 1:(length(times)-1)) {
# calculate the transition probabilities for the cycle based on health state t
m_p <- Probs(m_M[, t], v_Ts, t)
# sample the current health state and store that state in matrix m_M
m_M[, t + 1]  <- samplev(m_p, 1)
# update time since illness onset for t + 1
v_Ts <- ifelse(m_M[, t + 1] == "sick", v_Ts + 1, 0)
# Display simulation progress
if(t %in% seq(1,(length(times)),10)) { # display progress every 10%
cat('\r', paste(round(t/length(times)*100,0), "% done", sep = " "))
} else if (t == (length(times)-1)) {cat('\r', paste("100% done"))}
} # close the loop for the time points
# store the results from the simulation in a list
results <- list(m_M = m_M)
return(results)  # return the results
} # end of the MicroSim function
# Run the simulation model
Micro_data <- MicroSim(n_i, seed = 1)
# create the microsimulation trace
m_M_Micro <- t(apply(Micro_data$m_M, 2, function(x) table(factor(x, levels = v_n,
ordered = TRUE))))
m_M_Micro <- m_M_Micro / n_i    # calculate the proportion of individuals
colnames(m_M_Micro) <- v_n
rownames(m_M_Micro) <- paste("Cycle", times, sep = " ")
# Calculate trace for the real data
m_M_data <- transitionProbabilities(generate$cohort, times = times)@probabilities
# visually compare all methods
matplot(times,m_M_data, type='l', lty = 1, col = 1, ylab= "proportion of cohort", xlab = "Time",
main = "Trace comparisons",xlim=c(0,25))
matlines(times, m_M_DES,   col = 2, lty = 1)
matlines(times, m_M_Micro, col = 3, lty = 1)
matlines(times, m_M_PSM,   col = 4, lty = 1)
legend("right", c("True Data", "DES","Microsim",  "PSM"),
col = 1:4, lty = rep(1,4), bty= "n")
rm(list = ls())      # clear memory (removes all the variables from the workspace)
if (!require('here')) install.packages('here'); library(gems)
if (!require('gems')) install.packages('gems'); library(gems)
if (!require('msm')) install.packages('msm'); library(msm)
if (!require('flexsurv')) install.packages('flexsurv'); library(flexsurv)
if (!require('dplyr')) install.packages('dplyr'); library(dplyr)
if (!require('mstate')) install.packages('mstate'); library(mstate)
source(here::here("functions", "functions.R"))
v_n       <- c("healthy", "sick", "dead")  # state names
n_s       <- length(v_n)                   # No of states
c_l       <- 1 / 12                        # cycle length (a month)
n_t       <- 20                            # number of years (20 years)
times     <- seq(0, n_t, c_l)              # the cycles in years
d_r       <- 0.03                          # discount rate
set.seed(2009)                             # set the seed
c_H       <- 200                           # cost of remaining one cycle healthy
c_S       <- 500                           # cost of remaining one cycle sick
c_D       <- 0                             # cost of remaining one cycle dead
v_c       <- c(c_H, c_S, c_D)              # store in a vector
u_H       <- 0.75                          # utility when healthy
u_S       <- 0.30                          # utility when sick
u_D       <- 0                             # utility when dead
v_u       <- c(u_H, u_S, u_D)              # store in a vector
v_dw      <- 1 / (1 + d_r) ^ (times)       # discount weight
# Create IPD and KM data for the OS curves
digitise(here::here("data","OS_Examp.txt"),
here::here("data", "OS_Examp_AtRisk.txt"),
nevent_inp = 52,
km_output  = here::here("output", "KMdata_OS.txt"),
ipd_output = here::here("output", "IPDdata_OS.txt"))
# Create IPD and KM data for the PFS curves (there have been 99 events in the cohort)
digitise(here::here("data", "PFS_Examp.txt"),
here::here("data", "PFS_Examp_AtRisk.txt"),
nevent_inp = 99,
km_output  = here::here("output", "KMdata_PFS.txt"),
ipd_output  = here::here("output", "IPDdata_PFS.txt"))
# Link the IPD files across the two arms of the trial for OS and PFS
IPD_OS  <- make.ipd(ipd_files = c(here::here("output", "IPDdata_OS.txt")), ctr = 1,
var.labs  = c("time","event","arm"))
IPD_PFS <- make.ipd(ipd_files = c(here::here("output", "IPDdata_PFS.txt")), ctr = 1,
var.labs  = c("time","event","arm"))
# fit all parametric models to the data and extract the AIC/BIC
# Select the one with the most appropriate fit
# Repeat for PFS and OS
fit_PFS  <- fit.fun(time ="time", status = "event", data = IPD_PFS, times = times,
extrapolate = T)
fit_OS   <- fit.fun(time = "time", status = "event" , data = IPD_OS, times = times,
extrapolate = T)
best_PFS <- fit_PFS[["Weibull"]]
best_OS  <- fit_OS [["Weibull"]]
# construct a partitioned survival model out of the fitted models
m_M_PSM <- partsurv(best_PFS,best_OS, time = times)$trace
matplot(m_M_PSM, type="l")
legend("right",v_n, col= 1:3, lty=1:3, bty="n")
v_c_t <- m_M_PSM %*% v_c
v_u_t <- m_M_PSM %*% v_u
tot_c <-  t(v_c_t) %*% v_dw
tot_u <-  t(v_u_t) %*% v_dw
# display results
results <- data.frame(Total_Cost = tot_c, Total_QALYs = tot_u)
results
# Create IPD and KM data for the OS curves
digitise(here::here("data","OS_Examp.txt"),
here::here("data", "OS_Examp_AtRisk.txt"),
nevent_inp = 52,
km_output  = here::here("output", "KMdata_OS.txt"),
ipd_output = here::here("output", "IPDdata_OS.txt"))
# Create IPD and KM data for the PFS curves (there have been 99 events in the cohort)
digitise(here::here("data", "PFS_Examp.txt"),
here::here("data", "PFS_Examp_AtRisk.txt"),
nevent_inp = 99,
km_output  = here::here("output", "KMdata_PFS.txt"),
ipd_output  = here::here("output", "IPDdata_PFS.txt"))
# Link the IPD files across the two arms of the trial for OS and PFS
IPD_OS  <- make.ipd(ipd_files = c(here::here("output", "IPDdata_OS.txt")), ctr = 1,
var.labs  = c("time","event","arm"))
IPD_PFS <- make.ipd(ipd_files = c(here::here("output", "IPDdata_PFS.txt")), ctr = 1,
var.labs  = c("time","event","arm"))
