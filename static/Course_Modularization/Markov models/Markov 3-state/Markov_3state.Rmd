<<<<<<< HEAD
---
title: '3-state Markov model in R'
author: "The DARTH workgroup"
output:
  pdf_document: default
  html_document: default
---

Developed by the Decision Analysis in R for Technologies in Health (DARTH) workgroup:

Fernando Alarid-Escudero, PhD (1) 

Eva A. Enns, MS, PhD (2)	

M.G. Myriam Hunink, MD, PhD (3,4)

Hawre J. Jalal, MD, PhD (5) 

Eline M. Krijkamp, MSc (3)	

Petros Pechlivanoglou, PhD (6,7)

Alan Yang, MSc (7)

In collaboration of: 		

1. Division of Public Administration, Center for Research and Teaching in 
   Economics (CIDE), Aguascalientes, Mexico
2. University of Minnesota School of Public Health, Minneapolis, MN, USA
3. Erasmus MC, Rotterdam, The Netherlands
4. Harvard T.H. Chan School of Public Health, Boston, USA
5. University of Pittsburgh Graduate School of Public Health, Pittsburgh, PA, USA
6. University of Toronto, Toronto ON, Canada
7. The Hospital for Sick Children, Toronto ON, Canada

Please cite our publications when using this code:
 
- Jalal H, Pechlivanoglou P, Krijkamp E, Alarid-Escudero F, Enns E, Hunink MG. 
An Overview of R in Health Decision Sciences. Med Decis Making. 2017; 37(3): 735-746. 
https://journals.sagepub.com/doi/abs/10.1177/0272989X16686559

- Alarid-Escudero F, Krijkamp EM, Enns EA, Yang A, Hunink MGM Pechlivanoglou P,
Jalal H. Cohort State-Transition Models in R: A Tutorial. arXiv:200107824v2. 
2020:1-48. http://arxiv.org/abs/2001.07824

- Krijkamp EM, Alarid-Escudero F, Enns EA, Jalal HJ, Hunink MGM, Pechlivanoglou P. 
Microsimulation modeling for health decision sciences using R: A tutorial. 
Med Decis Making. 2018;38(3):400–22. 
https://journals.sagepub.com/doi/abs/10.1177/0272989X18754513
 
- Krijkamp EM, Alarid-Escudero F, Enns E, Pechlivanoglou P, Hunink MM, Jalal H. 
A Multidimensional Array Representation of State-Transition Model Dynamics. 
Med Decis Making. Online First https://doi.org/10.1177/0272989X19893973

Copyright 2017, THE HOSPITAL FOR SICK CHILDREN AND THE COLLABORATING INSTITUTIONS. 
All rights reserved in Canada, the United States and worldwide. Copyright, 
trademarks, trade names and any and all associated intellectual property are 
exclusively owned by THE HOSPITAL FOR Sick CHILDREN and the collaborating 
institutions. These materials may be used, reproduced, modified, distributed 
and adapted with proper attribution.

\newpage

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval = FALSE)
```

Change `eval` to `TRUE` if you want to knit this document.

```{r}
rm(list = ls())      # clear memory (removes all the variables from the workspace)
```

# 01 Load packages

```{r}
if (!require('pacman')) install.packages('pacman'); library(pacman) # use this package to conveniently install other packages
# load (install if required) packages from CRAN
p_load("dplyr", "tidyr", "reshape2", "devtools", "scales", "ellipse", "ggplot2", "lazyeval", "igraph", "truncnorm", "ggraph", "reshape2", "knitr", "stringr", "diagram", "dampack")                                               
# load (install if required) packages from GitHub
# install_github("DARTH-git/darthtools", force = TRUE) #Uncomment if there is a newer version
p_load_gh("DARTH-git/darthtools")
```

# 02 Load functions

```{r}
# all functions are in the darthtools package
```

# 03 Model input

```{r}
## General setup
cycle_length    <- 1                             # cycle length equal to one year (use 1/12 for monthly)
n_cycles        <- 60                            # number of cycles
v_names_cycles  <- paste("cycle", 0:n_cycles)    # cycle names
v_names_states  <- c("Healthy", "Sick", "Dead")  # state names
n_states        <- length(v_names_states)        # number of health states 

### Discounting factors 
d_c <- 0.03 # annual discount rate for costs 
d_e <- 0.03 # annual discount rate for QALYs

### Strategies 
v_names_str     <- c("Standard of Care",         # store the strategy names
                     "Treatment A", 
                     "Treatment B")  
n_str           <- length(v_names_str)           # number of strategies

## Within-cycle correction (WCC) using Simpson's 1/3 rule 
v_wcc <- gen_wcc(n_cycles = n_cycles,  method = "Simpson1/3")

### Transition probabilities
p_HD      <- 0.01  # probability of dying when healthy
p_HS_SoC  <- 0.05  # probability of becoming sick when healthy, conditional on surviving, under standard of care
p_HS_trtA <- 0.04  # probability of becoming sick when healthy, conditional on surviving, under treatment A
p_HS_trtB <- 0.02  # probability of becoming sick when healthy, conditional on surviving, under treatment B
p_SD      <- 0.1   # probability of dying when sick    

### State rewards
#### Costs 
c_H       <- 400   # cost of one cycle in healthy state
c_S       <- 1000  # cost of one cycle in sick state
c_D       <- 0     # cost of one cycle in dead state
c_trtA    <- 800   # cost of treatment A (per cycle) in healthy state
c_trtB    <- 1500  # cost of treatment B (per cycle) in healthy state
#### Utilities
u_H       <- 1     # utility when healthy 
u_S       <- 0.5   # utility when sick
u_D       <- 0     # utility when dead

### Discount weight for costs and effects 
v_dwc     <- 1 / ((1 + (d_e * cycle_length)) ^ (0:n_cycles))
v_dwe     <- 1 / ((1 + (d_c * cycle_length)) ^ (0:n_cycles))
```

# 04 Construct state-transition models

```{r}
m_P_diag <- matrix(0, nrow = n_states, ncol = n_states, dimnames = list(v_names_states, v_names_states))
m_P_diag["Healthy", "Sick" ]     = "" 
m_P_diag["Healthy", "Dead" ]     = ""
m_P_diag["Healthy", "Healthy" ]  = ""
m_P_diag["Sick"   , "Dead" ]     = ""
m_P_diag["Sick"   , "Sick" ]     = ""
m_P_diag["Dead"   , "Dead" ]     = ""
layout.fig <- c(2, 1)
plotmat(t(m_P_diag), t(layout.fig), self.cex = 0.5, curve = 0, arr.pos = 0.8,  
        latex = T, arr.type = "curved", relsize = 0.85, box.prop = 0.8, 
        cex = 0.8, box.cex = 0.7, lwd = 1)
```

## 04.1 Initial state vector

```{r}
# All starting healthy
v_m_init <- c("Healthy" = 1, "Sick" = 0, "Dead" = 0)  
v_m_init
```

## 04.2 Initialize cohort traces

```{r}
### Initialize cohort trace for SoC 
m_M_SoC <- matrix(0, 
                  nrow = (n_cycles + 1), ncol = n_states, 
                  dimnames = list(v_names_cycles, v_names_states))
# Store the initial state vector in the first row of the cohort trace
m_M_SoC[1, ] <- v_m_init

## Initialize cohort traces for treatments A and B
# Structure and initial states are the same as for SoC
m_M_trtA <- m_M_trtB <- m_M_SoC
```

## 04.3 Create transition probability matrices

```{r}
## Create transition probability matrices for strategy SoC 
### Initialize transition probability matrix for strategy SoC 
# All transitions to a non-death state are assumed to be conditional on survival 
m_P_SoC  <- matrix(0,
                   nrow = n_states, ncol = n_states,
                   dimnames = list(v_names_states, v_names_states)) 
### Fill in matrix 
# from Healthy
m_P_SoC["Healthy", "Healthy"] <- (1 - p_HD) * (1 - p_HS_SoC)
m_P_SoC["Healthy", "Sick"]    <- (1 - p_HD) *      p_HS_SoC
m_P_SoC["Healthy", "Dead"]    <-      p_HD
# from Sick
m_P_SoC["Sick", "Sick"] <- 1 - p_SD
m_P_SoC["Sick", "Dead"] <-     p_SD
# from Dead
m_P_SoC["Dead", "Dead"] <- 1

## Treatment A
# Store the same matrix of SoC in Trt A, only replace different parameters
m_P_trtA <- m_P_SoC 
m_P_trtA["Healthy", "Healthy"] <- (1 - p_HD) * (1 - p_HS_trtA)
m_P_trtA["Healthy", "Sick"]    <- (1 - p_HD) *      p_HS_trtA

## Treatment B
# Store the same matrix of SoC in Trt B, only replace different parameters
m_P_trtB <- m_P_SoC
m_P_trtB["Healthy", "Healthy"] <- (1 - p_HD) * (1 - p_HS_trtB)
m_P_trtB["Healthy", "Sick"]    <- (1 - p_HD) *      p_HS_trtB

## Check if transition probability matrices are valid
### Check that transition probabilities are in [0, 1]
check_transition_probability(m_P_SoC,  verbose = TRUE)
check_transition_probability(m_P_trtA, verbose = TRUE)
check_transition_probability(m_P_trtB, verbose = TRUE)
### Check that all rows sum to 1
check_sum_of_transition_array(m_P_SoC,  n_states = n_states, verbose = TRUE)
check_sum_of_transition_array(m_P_trtA, n_states = n_states, verbose = TRUE)
check_sum_of_transition_array(m_P_trtB, n_states = n_states, verbose = TRUE)
```

# 05 Run Markov model

```{r}
# Iterative solution of time-independent cSTM
for (t in 1:n_cycles){  
  # For SoC
  m_M_SoC [t + 1, ] <- m_M_SoC [t, ] %*% m_P_SoC  
  # For treatment A
  m_M_trtA[t + 1, ] <- m_M_trtA[t, ] %*% m_P_trtA  
  # For treatment B
  m_M_trtB[t + 1, ] <- m_M_trtB[t, ] %*% m_P_trtB 
}

## Store the cohort traces in a list 
l_m_M <- list(m_M_SoC,
              m_M_trtA,
              m_M_trtB)
names(l_m_M) <- v_names_str
```

# 06 Plot Outputs

## 06.1 Plot the cohort trace for strategies SoC

```{r, message = FALSE}
plot_trace(m_M_SoC) 
```

## 06.2 Overall Survival (OS)

Print the overall survival for the Standard of Care

```{r}
v_os_SoC <- 1 - m_M_SoC[, "Dead"]    # calculate the overall survival (OS) probability
v_os_SoC <- rowSums(m_M_SoC[, 1:2])  # alternative way of calculating the OS probability   

plot(v_os_SoC, type = 'l', 
     ylim = c(0, 1),
     ylab = "Survival probability",
     xlab = "Cycle",
     main = "Overall Survival")  # create a simple plot showing the OS

# add grid 
grid(nx = n_cycles, ny = 10, col = "lightgray", lty = "dotted", lwd = par("lwd"), 
     equilogs = TRUE) 
```

## 06.2.1 Life Expectancy (LE)

```{r}
le_SoC <- sum(v_os_SoC)  # summing probability of OS over time  (i.e. life expectancy)
```

## 06.2.2 Disease prevalence

```{r}
v_prev <- m_M_SoC[, "Sick"]/v_os_SoC
plot(v_prev,
     ylim = c(0, 1),
     ylab = "Prevalence",
     xlab = "Cycle",
     main = "Disease prevalence")
```

# 07 State Rewards 

```{r}
## Scale by the cycle length 
# Vector of state utilities under strategy SoC
v_u_SoC    <- c(H  = u_H, 
                S  = u_S,
                D  = u_D) * cycle_length
# Vector of state costs under strategy SoC
v_c_SoC    <- c(H  = c_H, 
                S  = c_S,
                D  = c_D) * cycle_length
# Vector of state utilities under treatment A
v_u_trtA   <- c(H  = u_H, 
                S  = u_S, 
                D  = u_D) * cycle_length
# Vector of state costs under treatment A
v_c_trtA   <- c(H  = c_H + c_trtA, 
                S  = c_S, 
                D  = c_D) * cycle_length
# Vector of state utilities under treatment B
v_u_trtB   <- c(H  = u_H, 
                S  = u_S, 
                D  = u_D) * cycle_length
# Vector of state costs under treatment B
v_c_trtB   <- c(H  = c_H + c_trtB, 
                S  = c_S, 
                D  = c_D) * cycle_length

## Store state rewards 
# Store the vectors of state utilities for each strategy in a list 
l_u   <- list(SQ = v_u_SoC,
              A  = v_u_trtA,
              B  = v_u_trtB)
# Store the vectors of state cost for each strategy in a list 
l_c   <- list(SQ = v_c_SoC,
              A  = v_c_trtA,
              B  = v_c_trtB)

# assign strategy names to matching items in the lists
names(l_u) <- names(l_c) <- v_names_str
```

# 08 Compute expected outcomes 

```{r}
# Create empty vectors to store total utilities and costs 
v_tot_qaly <- v_tot_cost <- vector(mode = "numeric", length = n_str)
names(v_tot_qaly) <- names(v_tot_cost) <- v_names_str

## Loop through each strategy and calculate total utilities and costs 
for (i in 1:n_str) {
  v_u_str <- l_u[[i]]   # select the vector of state utilities for the i-th strategy
  v_c_str <- l_c[[i]]   # select the vector of state costs for the i-th strategy
  
  ### Expected QALYs and costs per cycle 
  ## Vector of QALYs and Costs
  # Apply state rewards 
  v_qaly_str <- l_m_M[[i]] %*% v_u_str # sum the utilities of all states for each cycle
  v_cost_str <- l_m_M[[i]] %*% v_c_str # sum the costs of all states for each cycle
  
  ### Discounted total expected QALYs and Costs per strategy and apply within-cycle correction if applicable
  # QALYs
  v_tot_qaly[i] <- t(v_qaly_str) %*% (v_dwe * v_wcc)
  # Costs
  v_tot_cost[i] <- t(v_cost_str) %*% (v_dwc * v_wcc)
}
```

# 09 Cost-effectiveness analysis (CEA) 

```{r}
## Incremental cost-effectiveness ratios (ICERs) 
df_cea <- calculate_icers(cost       = v_tot_cost, 
                          effect     = v_tot_qaly,
                          strategies = v_names_str)
df_cea
```

```{R}
## CEA table in proper format 
table_cea <- format_table_cea(df_cea) 
table_cea
```

```{r}
## CEA frontier 
plot(df_cea, label = "all", txtsize = 14) +
  expand_limits(x = max(table_cea$QALYs) + 0.1) +
  theme(legend.position = c(0.8, 0.3))
```

=======
---
title: '3-state Markov model in R'
author: "The DARTH workgroup"
output:
  pdf_document: default
  html_document: default
---

Developed by the Decision Analysis in R for Technologies in Health (DARTH) workgroup:

Fernando Alarid-Escudero, PhD (1) 

Eva A. Enns, MS, PhD (2)	

M.G. Myriam Hunink, MD, PhD (3,4)

Hawre J. Jalal, MD, PhD (5) 

Eline M. Krijkamp, MSc (3)	

Petros Pechlivanoglou, PhD (6,7)

Alan Yang, MSc (7)

In collaboration of: 		

1. Division of Public Administration, Center for Research and Teaching in 
   Economics (CIDE), Aguascalientes, Mexico
2. University of Minnesota School of Public Health, Minneapolis, MN, USA
3. Erasmus MC, Rotterdam, The Netherlands
4. Harvard T.H. Chan School of Public Health, Boston, USA
5. University of Pittsburgh Graduate School of Public Health, Pittsburgh, PA, USA
6. University of Toronto, Toronto ON, Canada
7. The Hospital for Sick Children, Toronto ON, Canada

Please cite our publications when using this code:

- Alarid-Escudero F, Krijkamp EM, Enns EA, Yang A, Hunink MGM Pechlivanoglou P,
Jalal H. An Introductory Tutorial on Cohort State-Transition Models in R Using a 
Cost-Effectiveness Analysis Example. Medical Decision Making, 2022 
(Online First):1-18. https://doi.org/10.1177/0272989X221103163

- Jalal H, Pechlivanoglou P, Krijkamp E, Alarid-Escudero F, Enns E, Hunink MG. 
An Overview of R in Health Decision Sciences. Med Decis Making. 2017; 37(3): 735-746. 
https://journals.sagepub.com/doi/abs/10.1177/0272989X16686559

- Krijkamp EM, Alarid-Escudero F, Enns EA, Jalal HJ, Hunink MGM, Pechlivanoglou P. 
Microsimulation modeling for health decision sciences using R: A tutorial. 
Med Decis Making. 2018;38(3):400–22. 
https://journals.sagepub.com/doi/abs/10.1177/0272989X18754513

- Krijkamp EM, Alarid-Escudero F, Enns E, Pechlivanoglou P, Hunink MM, Jalal H. 
A Multidimensional Array Representation of State-Transition Model Dynamics. 
Med Decis Mak. 2020;40(2):242-248. https://doi.org/10.1177/0272989X19893973

Copyright 2017, THE HOSPITAL FOR SICK CHILDREN AND THE COLLABORATING INSTITUTIONS. 
All rights reserved in Canada, the United States and worldwide. Copyright, 
trademarks, trade names and any and all associated intellectual property are 
exclusively owned by THE HOSPITAL FOR Sick CHILDREN and the collaborating 
institutions. These materials may be used, reproduced, modified, distributed 
and adapted with proper attribution.

\newpage

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval = FALSE)
```

Change `eval` to `TRUE` if you want to knit this document.

```{r}
rm(list = ls())      # clear memory (removes all the variables from the workspace)
```

# 01 Load packages

```{r}
if (!require('pacman')) install.packages('pacman'); library(pacman) # use this package to conveniently install other packages
# load (install if required) packages from CRAN
p_load("dplyr", "tidyr", "reshape2", "devtools", "scales", "ellipse", "ggplot2", "lazyeval", "igraph", "truncnorm", "ggraph", "reshape2", "knitr", "stringr", "diagram", "dampack")                                               
# load (install if required) packages from GitHub
# install_github("DARTH-git/darthtools", force = TRUE) #Uncomment if there is a newer version
p_load_gh("DARTH-git/darthtools")
```

# 02 Load functions

```{r}
# all functions are in the darthtools package
```

# 03 Model input

```{r}
## General setup
cycle_length    <- 1                             # cycle length equal to one year (use 1/12 for monthly)
n_cycles        <- 60                            # number of cycles
v_names_cycles  <- paste("cycle", 0:n_cycles)    # cycle names
v_names_states  <- c("Healthy", "Sick", "Dead")  # state names
n_states        <- length(v_names_states)        # number of health states 

### Discounting factors 
d_c <- 0.03 # annual discount rate for costs 
d_e <- 0.03 # annual discount rate for QALYs

### Strategies 
v_names_str     <- c("Standard of Care",         # store the strategy names
                     "Treatment A", 
                     "Treatment B")  
n_str           <- length(v_names_str)           # number of strategies

## Within-cycle correction (WCC) using Simpson's 1/3 rule 
v_wcc <- gen_wcc(n_cycles = n_cycles,  method = "Simpson1/3")

### Transition probabilities
p_HD      <- 0.01  # probability of dying when healthy
p_HS_SoC  <- 0.05  # probability of becoming sick when healthy, conditional on surviving, under standard of care
p_HS_trtA <- 0.04  # probability of becoming sick when healthy, conditional on surviving, under treatment A
p_HS_trtB <- 0.02  # probability of becoming sick when healthy, conditional on surviving, under treatment B
p_SD      <- 0.1   # probability of dying when sick    

### State rewards
#### Costs 
c_H       <- 400   # cost of one cycle in healthy state
c_S       <- 1000  # cost of one cycle in sick state
c_D       <- 0     # cost of one cycle in dead state
c_trtA    <- 800   # cost of treatment A (per cycle) in healthy state
c_trtB    <- 1500  # cost of treatment B (per cycle) in healthy state
#### Utilities
u_H       <- 1     # utility when healthy 
u_S       <- 0.5   # utility when sick
u_D       <- 0     # utility when dead

### Discount weight for costs and effects 
v_dwc     <- 1 / ((1 + (d_e * cycle_length)) ^ (0:n_cycles))
v_dwe     <- 1 / ((1 + (d_c * cycle_length)) ^ (0:n_cycles))
```

# 04 Construct state-transition models

```{r}
m_P_diag <- matrix(0, nrow = n_states, ncol = n_states, dimnames = list(v_names_states, v_names_states))
m_P_diag["Healthy", "Sick" ]     = "" 
m_P_diag["Healthy", "Dead" ]     = ""
m_P_diag["Healthy", "Healthy" ]  = ""
m_P_diag["Sick"   , "Dead" ]     = ""
m_P_diag["Sick"   , "Sick" ]     = ""
m_P_diag["Dead"   , "Dead" ]     = ""
layout.fig <- c(2, 1)
plotmat(t(m_P_diag), t(layout.fig), self.cex = 0.5, curve = 0, arr.pos = 0.8,  
        latex = T, arr.type = "curved", relsize = 0.85, box.prop = 0.8, 
        cex = 0.8, box.cex = 0.7, lwd = 1)
```

## 04.1 Initial state vector

```{r}
# All starting healthy
v_s_init <- c("Healthy" = 1, "Sick" = 0, "Dead" = 0)  
v_s_init
```

## 04.2 Initialize cohort traces

```{r}
### Initialize cohort trace for SoC 
m_M_SoC <- matrix(0, 
                  nrow = (n_cycles + 1), ncol = n_states, 
                  dimnames = list(v_names_cycles, v_names_states))
# Store the initial state vector in the first row of the cohort trace
m_M_SoC[1, ] <- v_s_init

## Initialize cohort traces for treatments A and B
# Structure and initial states are the same as for SoC
m_M_trtA <- m_M_trtB <- m_M_SoC
```

## 04.3 Create transition probability matrices

```{r}
## Create transition probability matrices for strategy SoC 
### Initialize transition probability matrix for strategy SoC 
# All transitions to a non-death state are assumed to be conditional on survival 
m_P_SoC  <- matrix(0,
                   nrow = n_states, ncol = n_states,
                   dimnames = list(v_names_states, v_names_states)) 
### Fill in matrix 
# from Healthy
m_P_SoC["Healthy", "Healthy"] <- (1 - p_HD) * (1 - p_HS_SoC)
m_P_SoC["Healthy", "Sick"]    <- (1 - p_HD) *      p_HS_SoC
m_P_SoC["Healthy", "Dead"]    <-      p_HD
# from Sick
m_P_SoC["Sick", "Sick"] <- 1 - p_SD
m_P_SoC["Sick", "Dead"] <-     p_SD
# from Dead
m_P_SoC["Dead", "Dead"] <- 1

## Treatment A
# Store the same matrix of SoC in Trt A, only replace different parameters
m_P_trtA <- m_P_SoC 
m_P_trtA["Healthy", "Healthy"] <- (1 - p_HD) * (1 - p_HS_trtA)
m_P_trtA["Healthy", "Sick"]    <- (1 - p_HD) *      p_HS_trtA

## Treatment B
# Store the same matrix of SoC in Trt B, only replace different parameters
m_P_trtB <- m_P_SoC
m_P_trtB["Healthy", "Healthy"] <- (1 - p_HD) * (1 - p_HS_trtB)
m_P_trtB["Healthy", "Sick"]    <- (1 - p_HD) *      p_HS_trtB

## Check if transition probability matrices are valid
### Check that transition probabilities are in [0, 1]
check_transition_probability(m_P_SoC,  verbose = TRUE)
check_transition_probability(m_P_trtA, verbose = TRUE)
check_transition_probability(m_P_trtB, verbose = TRUE)
### Check that all rows sum to 1
check_sum_of_transition_array(m_P_SoC,  n_states = n_states, verbose = TRUE)
check_sum_of_transition_array(m_P_trtA, n_states = n_states, verbose = TRUE)
check_sum_of_transition_array(m_P_trtB, n_states = n_states, verbose = TRUE)
```

# 05 Run Markov model

```{r}
# Iterative solution of time-independent cSTM
for (t in 1:n_cycles){  
  # For SoC
  m_M_SoC [t + 1, ] <- m_M_SoC [t, ] %*% m_P_SoC  
  # For treatment A
  m_M_trtA[t + 1, ] <- m_M_trtA[t, ] %*% m_P_trtA  
  # For treatment B
  m_M_trtB[t + 1, ] <- m_M_trtB[t, ] %*% m_P_trtB 
}

## Store the cohort traces in a list 
l_m_M <- list(m_M_SoC,
              m_M_trtA,
              m_M_trtB)
names(l_m_M) <- v_names_str
```

# 06 Plot Outputs

## 06.1 Plot the cohort trace for strategies SoC

```{r, message = FALSE}
plot_trace(m_M_SoC) 
```

## 06.2 Overall Survival (OS)

Print the overall survival for the Standard of Care

```{r}
v_os_SoC <- 1 - m_M_SoC[, "Dead"]    # calculate the overall survival (OS) probability
v_os_SoC <- rowSums(m_M_SoC[, 1:2])  # alternative way of calculating the OS probability   

plot(v_os_SoC, type = 'l', 
     ylim = c(0, 1),
     ylab = "Survival probability",
     xlab = "Cycle",
     main = "Overall Survival")  # create a simple plot showing the OS

# add grid 
grid(nx = n_cycles, ny = 10, col = "lightgray", lty = "dotted", lwd = par("lwd"), 
     equilogs = TRUE) 
```

## 06.2.1 Life Expectancy (LE)

```{r}
le_SoC <- sum(v_os_SoC)  # summing probability of OS over time  (i.e. life expectancy)
```

## 06.2.2 Disease prevalence

```{r}
v_prev <- m_M_SoC[, "Sick"]/v_os_SoC
plot(v_prev,
     ylim = c(0, 1),
     ylab = "Prevalence",
     xlab = "Cycle",
     main = "Disease prevalence")
```

# 07 State Rewards 

```{r}
## Scale by the cycle length 
# Vector of state utilities under strategy SoC
v_u_SoC    <- c(H  = u_H, 
                S  = u_S,
                D  = u_D) * cycle_length
# Vector of state costs under strategy SoC
v_c_SoC    <- c(H  = c_H, 
                S  = c_S,
                D  = c_D) * cycle_length
# Vector of state utilities under treatment A
v_u_trtA   <- c(H  = u_H, 
                S  = u_S, 
                D  = u_D) * cycle_length
# Vector of state costs under treatment A
v_c_trtA   <- c(H  = c_H + c_trtA, 
                S  = c_S, 
                D  = c_D) * cycle_length
# Vector of state utilities under treatment B
v_u_trtB   <- c(H  = u_H, 
                S  = u_S, 
                D  = u_D) * cycle_length
# Vector of state costs under treatment B
v_c_trtB   <- c(H  = c_H + c_trtB, 
                S  = c_S, 
                D  = c_D) * cycle_length

## Store state rewards 
# Store the vectors of state utilities for each strategy in a list 
l_u   <- list(SQ = v_u_SoC,
              A  = v_u_trtA,
              B  = v_u_trtB)
# Store the vectors of state cost for each strategy in a list 
l_c   <- list(SQ = v_c_SoC,
              A  = v_c_trtA,
              B  = v_c_trtB)

# assign strategy names to matching items in the lists
names(l_u) <- names(l_c) <- v_names_str
```

# 08 Compute expected outcomes 

```{r}
# Create empty vectors to store total utilities and costs 
v_tot_qaly <- v_tot_cost <- vector(mode = "numeric", length = n_str)
names(v_tot_qaly) <- names(v_tot_cost) <- v_names_str

## Loop through each strategy and calculate total utilities and costs 
for (i in 1:n_str) {
  v_u_str <- l_u[[i]]   # select the vector of state utilities for the i-th strategy
  v_c_str <- l_c[[i]]   # select the vector of state costs for the i-th strategy
  
  ### Expected QALYs and costs per cycle 
  ## Vector of QALYs and Costs
  # Apply state rewards 
  v_qaly_str <- l_m_M[[i]] %*% v_u_str # sum the utilities of all states for each cycle
  v_cost_str <- l_m_M[[i]] %*% v_c_str # sum the costs of all states for each cycle
  
  ### Discounted total expected QALYs and Costs per strategy and apply within-cycle correction if applicable
  # QALYs
  v_tot_qaly[i] <- t(v_qaly_str) %*% (v_dwe * v_wcc)
  # Costs
  v_tot_cost[i] <- t(v_cost_str) %*% (v_dwc * v_wcc)
}
```

# 09 Cost-effectiveness analysis (CEA) 

```{r}
## Incremental cost-effectiveness ratios (ICERs) 
df_cea <- calculate_icers(cost       = v_tot_cost, 
                          effect     = v_tot_qaly,
                          strategies = v_names_str)
df_cea
```

```{R}
## CEA table in proper format 
table_cea <- format_table_cea(df_cea) 
table_cea
```

```{r}
## CEA frontier 
plot(df_cea, label = "all", txtsize = 14) +
  expand_limits(x = max(table_cea$QALYs) + 0.1) +
  theme(legend.position = c(0.8, 0.3))
```

>>>>>>> da36a6af5b5df0f53272afa0e73089f8abde74fa
