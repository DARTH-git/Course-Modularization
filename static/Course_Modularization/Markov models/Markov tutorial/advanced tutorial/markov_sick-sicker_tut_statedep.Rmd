---
title: 'Cohort State-Transition Models in R'
subtitle: 'with state-residence time dependency'
author: "The DARTH workgroup"
output:
  pdf_document: default
  html_document: default
  fig_caption: yes
keep_tex: yes
self_contained: no
---

Developed by the Decision Analysis in R for Technologies in Health (DARTH) workgroup:

Fernando Alarid-Escudero, PhD (1) 

Eva A. Enns, MS, PhD (2)	

M.G. Myriam Hunink, MD, PhD (3,4)

Hawre J. Jalal, MD, PhD (5) 

Eline M. Krijkamp, MSc (3)	

Petros Pechlivanoglou, PhD (6,7)

Alan Yang, MSc (7)

In collaboration of: 		

1. Division of Public Administration, Center for Research and Teaching in Economics (CIDE), 
   Aguascalientes, Mexico
2. University of Minnesota School of Public Health, Minneapolis, MN, USA
3. Erasmus MC, Rotterdam, The Netherlands
4. Harvard T.H. Chan School of Public Health, Boston, USA
5. University of Pittsburgh Graduate School of Public Health, Pittsburgh, PA, USA
6. University of Toronto, Toronto ON, Canada
7. The Hospital for Sick Children, Toronto ON, Canada

Please cite our publications when using this code:
 
- Jalal H, Pechlivanoglou P, Krijkamp E, Alarid-Escudero F, Enns E, Hunink MG. 
An Overview of R in Health Decision Sciences. Med Decis Making. 2017; 37(3): 735-746. 
https://journals.sagepub.com/doi/abs/10.1177/0272989X16686559
 
- Krijkamp EM, Alarid-Escudero F, Enns EA, Jalal HJ, Hunink MGM, Pechlivanoglou P. 
Microsimulation modeling for health decision sciences using R: A tutorial. 
Med Decis Making. 2018;38(3):400–22. 
https://journals.sagepub.com/doi/abs/10.1177/0272989X18754513
 
- Krijkamp EM, Alarid-Escudero F, Enns E, Pechlivanoglou P, Hunink MM, Jalal H. 
A Multidimensional Array Representation of State-Transition Model Dynamics. 
Med Decis Making. Feb;40(2):242-248. https://doi.org/10.1177/0272989X19893973

- Alarid-Escudero, F., Krijkamp, E. M., Enns, E. A., Hunink, M. G. M., 
Pechlivanoglou, P., & Jalal, H. (2020). Cohort state-transition models in R: 
From conceptualization to implementation. ArXiv:2001.07824v1, 1–31. 
http://arxiv.org/abs/2001.07824

Copyright 2017, THE HOSPITAL FOR SICK CHILDREN AND THE COLLABORATING INSTITUTIONS. 
All rights reserved in Canada, the United States and worldwide. Copyright, 
trademarks, trade names and any and all associated intellectual property are 
exclusively owned by THE HOSPITAL FOR Sick CHILDREN and the collaborating 
institutions. These materials may be used, reproduced, modified, distributed 
and adapted with proper attribution.

\newpage

# Code of Appendix

Implements a time-independent Sick-Sicker cohort state-transition model (cSTM).                       

- *Standard of Care (SoC)*: current available care for the patients with the disease. This strategy reflects the natural history of the disease progression.

- *Strategy A*: treatment A is given to all sick patients, patients in the Sick and Sicker, but only improves the utility of those being sick.

- *Strategy B*: treatment B reduces disease progression from the Sick to Sicker states. However, it is not possible to distinguish those sick from sicker, and therefore all individuals in one of the two sick states get the treatment.   
 
- *Strategy AB*: combines treatment A and treatment B. The disease progression is reduced, and Sick individuals have an improved utility.

\newpage

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval = T)
```

Change `eval` to `TRUE` if you want to knit this document.

```{r}
rm(list = ls())      # clear memory (removes all the variables from the workspace)
```

# 01 Load packages

```{r, warning = F, message = F}
if (!require('pacman')){
  install.packages('pacman')
  library(pacman) # use this package to conveniently install other packages
}
# load (install if required) packages from CRAN
pacman::p_load("dplyr", "data.table", "devtools", "scales", "ellipse", "ggplot2", 
               "lazyeval", "igraph", "truncnorm", "ggraph", "reshape2", "knitr", 
               "stringr", "gridExtra", "diagram", "dampack", "boot", "doParellel", "flexsurv")                                               
# load (install if required) packages from GitHub
# install_github("DARTH-git/darthtools", force = TRUE) Uncomment if there is a newer version
pacman::p_load_gh("DARTH-git/darthtools")
```

# 02 Load functions

```{r}
source("Functions.R")
```

# 03 Input model parameters

```{r}
# Strategy names
v_names_str <- c("Standard of care",   # store the strategy names
                 "Strategy A", 
                 "Strategy B",
                 "Strategy AB") 

# Markov model parameters
n_age_init  <- 25                      # age at baseline
n_age_max   <- 100                     # maximum age of follow up
n_cycles    <- n_age_max - n_age_init  # time horizon, number of cycles
# the 4 states of the model: 
v_names_states <- c("H",  # Healthy (H)
                    "S1", # Sick (S1), 
                    "S2", # Sicker (S2)
                    "D")  # Dead (D)

## Tunnel inputs
# Number of tunnels
n_tunnel_size <- n_cycles
# Name for tunnels states of Sick state
v_Sick_tunnel <- paste("S1_", seq(1, n_tunnel_size), "Yr", sep = "")
# Create variables for model with tunnels
v_names_states_tunnels <- c("H", v_Sick_tunnel, "S2", "D") # health state names
n_states_tunnels <- length(v_names_states_tunnels)         # number of health states

## Transition probabilities (per cycle), hazard ratios 
p_HS1    <- 0.15  # probability to become Sick when Healthy conditional on surviving
p_S1H    <- 0.5   # probability to become Healthy when Sick conditional on surviving
hr_S1    <- 3     # hazard ratio of death in Sick vs Healthy 
hr_S2    <- 10    # hazard ratio of death in Sicker vs Healthy    

# Effectiveness of treatment B 
hr_S1S2_trtB <- 0.6  # hazard ratio of becoming Sicker when Sick under treatment B

# Weibull parameters for state-residence-dependent transition probability of 
# becoming Sicker when Sick conditional on surviving
p_S1S2_scale <- 0.08 # scale
p_S1S2_shape <- 1.1  # shape

## Age-dependent mortality rates
lt_usa_2015  <- read.csv("LifeTable_USA_Mx_2015.csv")
v_r_mort_by_age <- lt_usa_2015 %>% 
                   select(Total) %>%
                   as.matrix() # anyone above 100 have the same mortality
names(v_r_mort_by_age) <- lt_usa_2015$Age

## State rewards
# Costs
c_H      <- 2000  # cost of remaining one cycle in Healthy 
c_S1     <- 4000  # cost of remaining one cycle in Sick 
c_S2     <- 15000 # cost of remaining one cycle in Sicker 
c_D      <- 0     # cost of being dead (per cycle)
c_trtA   <- 12000 # cost of treatment A
c_trtB   <- 13000 # cost of treatment B
# Utilities
u_H      <- 1     # utility when Healthy 
u_S1     <- 0.75  # utility when Sick 
u_S2     <- 0.5   # utility when Sicker
u_D      <- 0     # utility when Dead 
u_trtA   <- 0.95  # utility when being treated with A  

## Transition rewards
du_HS1   <- 0.01  # disutility when transitioning from Healthy to Sick
ic_HS1   <- 1000  # increase in cost when transitioning from Healthy to Sick
ic_D     <- 2000  # increase in cost when dying
  
n_str    <- length(v_names_str)     # number of strategies
n_states <- length(v_names_states)  # number of states

# Discounting factors
d_c      <- 0.03                    # discount rate for costs 
d_e      <- 0.03                    # discount rate for QA 

# Discount weights for costs and effects
v_dwc    <- 1 / (1 + d_c) ^ (0:n_cycles) 
v_dwe    <- 1 / (1 + d_e) ^ (0:n_cycles) 

# Within-cycle correction (WCC) using Simpson's 1/3 rule
v_wcc    <- darthtools::gen_wcc(n_cycles = n_cycles, 
                                method = "Simpson1/3") # vector of wcc

### Process model inputs
## Age-specific transition probabilities to the Dead state
# extract age-specific all-cause mortality rates for ages in model time horizon
v_r_HDage  <- v_r_mort_by_age[(n_age_init + 1) + 0:(n_cycles - 1)]
# compute mortality rates
v_r_S1Dage <- v_r_HDage * hr_S1        # Age-specific mortality rate in the Sick state 
v_r_S2Dage <- v_r_HDage * hr_S2        # Age-specific mortality rate in the Sicker state 
# transform rates to probabilities
v_p_HDage  <- rate_to_prob(v_r_HDage)  # Age-specific mortality risk in the Healthy state 
v_p_S1Dage <- rate_to_prob(v_r_S1Dage) # Age-specific mortality risk in the Sick state
v_p_S2Dage <- rate_to_prob(v_r_S2Dage) # Age-specific mortality risk in the Sicker state

## History-dependent transition probability of becoming Sicker when Sick
# conditional on surviving
# Weibull hazard



v_r_S1S2_tunnels <- HweibullPH(0:n_tunnel_size   ,
                          shape = p_S1S2_shape, 
                          scale  = p_S1S2_scale)
v_p_S1S2_tunnels <- 1 - exp(- diff(v_r_S1S2_tunnels))


## History-dependent transition probability of becoming Sicker when Sick for treatment B
# apply hazard ratio to scale to obtain transition rate of becoming Sicker when Sick for treatment B
p_S1S2_scale_trtB <- p_S1S2_scale * hr_S1S2_trtB
p_S1S2_shape_trtB <- p_S1S2_shape
v_r_S1S2_tunnels_trtB <- HweibullPH(0:n_tunnel_size   ,
                          shape = p_S1S2_shape_trtB, 
                          scale  = p_S1S2_scale_trtB)
v_p_S1S2_tunnels_trtB <- 1 - exp(- diff(v_r_S1S2_tunnels_trtB))  # probability to become Sicker when Sick 
                                                               # under treatment B conditional on surviving
```

# 04 Define and initialize matrices and vectors

## 04.1 Cohort trace

```{r}
## Initial state vector
# All starting healthy
v_s_init_tunnels <- c(1, rep(0, n_tunnel_size), 0, 0) 

## Initialize cohort trace for state-residence time dependent (ad) cSTM for SoC
m_M_tunnels <- matrix(0, 
                      nrow     = (n_cycles + 1), ncol = n_states_tunnels, 
                      dimnames = list(0:n_cycles, v_names_states_tunnels))
# Store the initial state vector in the first row of the cohort trace
m_M_tunnels[1, ]  <- v_s_init_tunnels
## Initialize cohort trace for strategies A, B, and AB
# Structure and initial states are the same as for SoC
m_M_tunnels_strA  <- m_M_tunnels # Strategy A
m_M_tunnels_strB  <- m_M_tunnels # Strategy B
m_M_tunnels_strAB <- m_M_tunnels # Strategy AB
```

## 04.1.1 Transition arrays

```{r}
## Initialize transition array which will capture transitions from each state to another over time 
# for SoC
a_A_tunnels <- array(0,
                     dim = c(n_states_tunnels, n_states_tunnels, n_cycles + 1),
                     dimnames = list(v_names_states_tunnels, v_names_states_tunnels, 0:n_cycles))
# Set first slice of A with the initial state vector in its diagonal
diag(a_A_tunnels[, , 1]) <- v_s_init_tunnels
# Initialize transition array for strategies A, B and AB as a copy of SoC's
a_A_tunnels_strA <- a_A_tunnels_strB <- a_A_tunnels_strAB <- a_A_tunnels
```

## 04.2 Transition probability arrays

```{r}
## Initialize transition probability array for strategy SoC
# all transitions to a non-death state are assumed to be conditional on survival 
# Initialize 3-D array
a_P_tunnels <- array(0, dim   = c(n_states_tunnels, n_states_tunnels, n_cycles),
                     dimnames = list(v_names_states_tunnels, v_names_states_tunnels, 0:(n_cycles - 1)))
```

Fill in the transition probability arrays:

```{r}
## From H
a_P_tunnels["H", "H", ]              <- (1 - v_p_HDage) * (1 - p_HS1)
a_P_tunnels["H", v_Sick_tunnel[1], ] <- (1 - v_p_HDage) * p_HS1
a_P_tunnels["H", "D", ]              <- v_p_HDage
## From S1
for(i in 1:(n_tunnel_size - 1)){
  a_P_tunnels[v_Sick_tunnel[i], "H", ]  <- (1 - v_p_S1Dage) * p_S1H
  a_P_tunnels[v_Sick_tunnel[i], 
              v_Sick_tunnel[i + 1], ]   <- (1 - v_p_S1Dage) *
                                           (1 - (p_S1H + v_p_S1S2_tunnels[i]))
  a_P_tunnels[v_Sick_tunnel[i], "S2", ] <- (1 - v_p_S1Dage) * v_p_S1S2_tunnels[i]
  a_P_tunnels[v_Sick_tunnel[i], "D", ]  <- v_p_S1Dage
}
# repeat code for the last cycle to force the cohort stay in the last tunnel state of Sick
a_P_tunnels[v_Sick_tunnel[n_tunnel_size], "H", ]  <- (1 - v_p_S1Dage) * p_S1H
a_P_tunnels[v_Sick_tunnel[n_tunnel_size],
            v_Sick_tunnel[n_tunnel_size], ] <- (1 - v_p_S1Dage) *
                                               (1 - (p_S1H + v_p_S1S2_tunnels[n_tunnel_size]))
a_P_tunnels[v_Sick_tunnel[n_tunnel_size], "S2", ] <- (1 - v_p_S1Dage) * 
                                                     v_p_S1S2_tunnels[n_tunnel_size]
a_P_tunnels[v_Sick_tunnel[n_tunnel_size], "D", ]  <- v_p_S1Dage
## From S2
a_P_tunnels["S2", "S2", ] <- 1 - v_p_S2Dage
a_P_tunnels["S2", "D", ]  <- v_p_S2Dage
## From D
a_P_tunnels["D", "D", ] <- 1

## Initialize transition probability matrix for strategy A as a copy of SoC's
a_P_tunnels_strA <- a_P_tunnels

## Initialize transition probability array for strategies B 
a_P_tunnels_strB <- a_P_tunnels

## Only need to update the probabilities involving the transition from Sick to Sicker, v_p_S1S2_tunnels
# From S1
for(i in 1:(n_tunnel_size - 1)){
  a_P_tunnels_strB[v_Sick_tunnel[i], "H", ]  <- (1 - v_p_S1Dage) * p_S1H
  a_P_tunnels_strB[v_Sick_tunnel[i], 
              v_Sick_tunnel[i + 1], ]        <- (1 - v_p_S1Dage) * 
                                                (1 - (p_S1H + v_p_S1S2_tunnels_trtB[i]))
  a_P_tunnels_strB[v_Sick_tunnel[i], "S2", ] <- (1 - v_p_S1Dage) * v_p_S1S2_tunnels_trtB[i]
  a_P_tunnels_strB[v_Sick_tunnel[i], "D", ]  <- v_p_S1Dage
}
# repeat code for the last cycle to force the cohort stay in the last tunnel state of Sick
a_P_tunnels_strB[v_Sick_tunnel[n_tunnel_size], "H", ] <- (1 - v_p_S1Dage) * p_S1H
a_P_tunnels_strB[v_Sick_tunnel[n_tunnel_size],
            v_Sick_tunnel[n_tunnel_size], ] <- (1 - v_p_S1Dage) * 
                                               (1 - (p_S1H +v_p_S1S2_tunnels_trtB[n_tunnel_size]))
a_P_tunnels_strB[v_Sick_tunnel[n_tunnel_size], "S2", ] <- (1 - v_p_S1Dage) *
                                                           v_p_S1S2_tunnels_trtB[n_tunnel_size]
a_P_tunnels_strB[v_Sick_tunnel[n_tunnel_size], "D", ]  <- v_p_S1Dage

## Initialize transition probability matrix for strategy AB as a copy of B's
a_P_tunnels_strAB <- a_P_tunnels_strB

### Check if transition probability matrices are valid
## Check that transition probabilities are [0, 1]
check_transition_probability(a_P_tunnels,       verbose = TRUE)
check_transition_probability(a_P_tunnels_strA,  verbose = TRUE)
check_transition_probability(a_P_tunnels_strB,  verbose = TRUE)
check_transition_probability(a_P_tunnels_strAB, verbose = TRUE)
## Check that all rows sum to 1
check_sum_of_transition_array(a_P_tunnels,       n_states = n_states_tunnels, n_cycles = n_cycles, verbose = TRUE)
check_sum_of_transition_array(a_P_tunnels_strA,  n_states = n_states_tunnels, n_cycles = n_cycles, verbose = TRUE)
check_sum_of_transition_array(a_P_tunnels_strB,  n_states = n_states_tunnels, n_cycles = n_cycles, verbose = TRUE)
check_sum_of_transition_array(a_P_tunnels_strAB, n_states = n_states_tunnels, n_cycles = n_cycles, verbose = TRUE)
```

# 05 Run Markov model

```{r}
# Iterative solution of age-dependent cSTM
for(t in 1:n_cycles){
  ## Fill in cohort trace
  # For SoC 
  m_M_tunnels[t + 1, ]         <- m_M_tunnels[t, ]        %*% a_P_tunnels[, , t]
  # For strategy A
  m_M_tunnels_strA[t + 1, ]    <- m_M_tunnels_strA[t, ]   %*% a_P_tunnels_strA[, , t]
  # For strategy B 
  m_M_tunnels_strB[t + 1, ]    <- m_M_tunnels_strB[t, ]   %*% a_P_tunnels_strB[, , t]
  # For strategy AB
  m_M_tunnels_strAB[t + 1, ]   <- m_M_tunnels_strAB[t, ]  %*% a_P_tunnels_strAB[, , t]
  
  ## Fill in transition-dynamics array
  # For SoC
  a_A_tunnels[, , t + 1]       <- m_M_tunnels[t, ]         *  a_P_tunnels[, , t]
  # For strategy A 
  a_A_tunnels_strA[, , t + 1]  <- m_M_tunnels_strA[t, ]    *  a_P_tunnels_strA[, , t]
  # For strategy B
  a_A_tunnels_strB[, , t + 1]  <- m_M_tunnels_strB[t, ]    *  a_P_tunnels_strB[, , t]
  # For strategy AB
  a_A_tunnels_strAB[, , t + 1] <- m_M_tunnels_strAB[t, ]   *  a_P_tunnels_strAB[, , t]
}

# Create aggregated trace
m_M_tunnels_sum       <- cbind(H  = m_M_tunnels[, "H"], 
                               S1 = rowSums(m_M_tunnels[, 2:(n_tunnel_size +1)]), 
                               S2 = m_M_tunnels[, "S2"],
                               D  = m_M_tunnels[, "D"])

m_M_tunnels_sum_strA  <- cbind(H  = m_M_tunnels_strA[, "H"], 
                               S1 = rowSums(m_M_tunnels_strA[, 2:(n_tunnel_size +1)]), 
                               S2 = m_M_tunnels_strA[, "S2"],
                               D  = m_M_tunnels_strA[, "D"])

m_M_tunnels_sum_strB  <- cbind(H  = m_M_tunnels_strB[, "H"], 
                               S1 = rowSums(m_M_tunnels_strB[, 2:(n_tunnel_size +1)]), 
                               S2 = m_M_tunnels_strB[, "S2"],
                               D  = m_M_tunnels_strB[, "D"])

m_M_tunnels_sum_strAB <- cbind(H  = m_M_tunnels_strAB[, "H"], 
                               S1 = rowSums(m_M_tunnels_strAB[, 2:(n_tunnel_size +1)]), 
                               S2 = m_M_tunnels_strAB[, "S2"],
                               D  = m_M_tunnels_strAB[, "D"])

## Store the cohort traces in a list
l_m_M <- list(m_M_tunnels_sum,      
              m_M_tunnels_sum_strA,      
              m_M_tunnels_sum_strB, 
              m_M_tunnels_sum_strAB)
names(l_m_M) <- v_names_str
```

# 06 Compute and Plot Epidemiological Outcomes

## 06.1 Cohort trace

```{r Sick-Sicker-Trace-StateTimDep, fig.cap='Cohort trace of the state-residence time dependent cSTM under standard of care', message=FALSE, warning=FALSE, fig.pos="H", }
# create a plot of the data
plot_trace(l_m_M$`Standard of care`)
```

```{r Sick-Sicker-Trace-StateTimDep, fig.cap='Cohort trace by state of the state-residence time dependent cSTM under all strategies', message=FALSE, warning=FALSE, fig.pos="H"}
# create a plot of all traces
plot_trace_strategy(l_m_M)
```

# 07 Compute Cost-Effectiveness Outcomes

## 07.1 State and transition rewards for each strategy

```{r}
## Vector of utilities for S1 under strategy SoC
v_u_S1_SoC <- rep(u_S1, n_tunnel_size)
names(v_u_S1_SoC) <- v_Sick_tunnel
## Vector of state utilities under strategy SoC
v_u_SoC <- c(H  = u_H, 
             v_u_S1_SoC, 
             S2 = u_S2,
             D  = u_D)
## Vector of costs per cycle for S1 under strategy SoC
v_c_S1_SoC <- rep(c_S1, n_tunnel_size)
names(v_c_S1_SoC) <- v_Sick_tunnel
## Vector of state costs per cycle under strategy SoC
v_c_SoC <- c(H  = c_H,
             v_c_S1_SoC, 
             S2 = c_S2,
             D  = c_D)

## Vector of utilities for S1 under strategy A
v_u_S1_strA <- rep(u_trtA, n_tunnel_size)
names(v_u_S1_strA) <- v_Sick_tunnel
## Vector of state utilities under strategy A
v_u_strA <- c(H  = u_H, 
              v_u_S1_strA, 
              S2 = u_S2, 
              D  = u_D)
## Vector of costs per cycle for S1 under strategy A
v_c_S1_strA <- rep(c_S1 + c_trtA, n_tunnel_size)
names(v_c_S1_strA) <- v_Sick_tunnel
## Vector of state costs per cycle under strategy A
v_c_strA <- c(H  = c_H, 
              v_c_S1_strA,
              S2 = c_S2 + c_trtA,
              D  = c_D)

## Vector of utilities for S1 under strategy B
v_u_S1_strB <- rep(u_S1, n_tunnel_size)
names(v_u_S1_strB) <- v_Sick_tunnel
## Vector of state utilities under strategy B
v_u_strB <- c(H  = u_H, 
              v_u_S1_strB, 
              S2 = u_S2,
              D  = u_D)
## Vector of costs per cycle for S1 under strategy B
v_c_S1_strB <- rep(c_S1 + c_trtB, n_tunnel_size)
names(v_c_S1_strB) <- v_Sick_tunnel
## Vector of state costs per cycle under strategy B
v_c_strB <- c(H  = c_H, 
              v_c_S1_strB, 
              S2 = c_S2 + c_trtB,
              D  = c_D)

## Vector of utilities for S1 under strategy AB
v_u_S1_strAB <- rep(u_trtA, n_tunnel_size)
names(v_u_S1_strAB) <- v_Sick_tunnel
## Vector of state utilities under strategy AB
v_u_strAB <- c(H  = u_H, 
               v_u_S1_strAB, 
               S2 = u_S2, 
               D  = u_D)
## Vector of costs per cycle for S1 under strategy AB
v_c_S1_strAB <- rep(c_S1 + (c_trtA + c_trtB), n_tunnel_size)
names(v_c_S1_strAB) <- v_Sick_tunnel
## Vector of state costs per cycle under strategy AB
v_c_strAB <- c(H  = c_H, 
               v_c_S1_strAB, 
               S2 = c_S2 + (c_trtA + c_trtB), 
               D  = c_D)

## Store the vectors of state utilities for each strategy in a list 
l_u   <- list(v_u_SoC,
              v_u_strA,
              v_u_strB,
              v_u_strAB)
## Store the vectors of state cost for each strategy in a list 
l_c   <- list(v_c_SoC,
              v_c_strA,
              v_c_strB,
              v_c_strAB)
## Store the transition array for each strategy in a list
l_a_A <- list(a_A_tunnels,
              a_A_tunnels_strA,
              a_A_tunnels_strB,
              a_A_tunnels_strAB)

# assign strategy names to matching items in the lists
names(l_u) <- names(l_c) <- names(l_a_A) <- v_names_str
```

## 07.2 Mean Costs and QALYs for each strategy

```{r}
## create empty vectors to store total utilities and costs 
v_tot_qaly <- v_tot_cost <- vector(mode = "numeric", length = n_str)
names(v_tot_qaly) <- names(v_tot_cost) <- v_names_str

#### Loop through each strategy and calculate total utilities and costs ####
for (i in 1:n_str) {
  v_u_str         <- l_u[[i]]   # select the vector of state utilities for the ith strategy
  v_c_str         <- l_c[[i]]   # select the vector of state costs for the ith strategy
  a_A_tunnels_str <- l_a_A[[i]] # select the transition array for the ith strategy
  
  #### Array of state utilities and costs ####
  # Create transition matrices of state utilities and state costs for the ith strategy 
  m_u_str  <- matrix(v_u_str, nrow = n_states_tunnels, ncol = n_states_tunnels, byrow = T)
  m_c_str  <- matrix(v_c_str, nrow = n_states_tunnels, ncol = n_states_tunnels, byrow = T)
  # Expand the transition matrix of state utilities across cycles to form a transition array of state utilities
  a_R_u_str <- array(m_u_str, 
                     dim      = c(n_states_tunnels, n_states_tunnels, n_cycles + 1),
                     dimnames = list(v_names_states_tunnels, v_names_states_tunnels, 0:n_cycles))
  # Expand the transition matrix of state costs across cycles to form a transition array of state costs
  a_R_c_str <- array(m_c_str, 
                     dim      = c(n_states_tunnels, n_states_tunnels, n_cycles + 1),
                     dimnames = list(v_names_states_tunnels, v_names_states_tunnels, 0:n_cycles))
  
  #### Apply transition rewards ####  
  # Add disutility due to transition from H to S1
  a_R_u_str["H", "S1_1Yr", ]          <- a_R_u_str["H", "S1_1Yr", ]          - du_HS1
  # Add transition cost per cycle due to transition from H to S1
  a_R_c_str["H", "S1_1Yr", ]          <- a_R_c_str["H", "S1_1Yr", ]          + ic_HS1
  # Add transition cost per cycle of dying from all non-dead states
  a_R_c_str[-n_states_tunnels, "D", ] <- a_R_c_str[-n_states_tunnels, "D", ] + ic_D
  
  #### Expected QALYs and Costs for all transitions per cycle ####
  # QALYs = life years x QoL
  # Note: all parameters are annual in our example. In case your own case example is different make sure you correctly apply .
  a_Y_c_str <- a_A_tunnels_str * a_R_c_str
  a_Y_u_str <- a_A_tunnels_str * a_R_u_str 
  
  #### Expected QALYs and Costs per cycle ####
  ## Vector of QALYs under 
  v_qaly_str <- apply(a_Y_u_str, 3, sum) # sum the proportion of the cohort across transitions 
  v_cost_str <- apply(a_Y_c_str, 3, sum) # sum the proportion of the cohort across transitions
  
  #### Discounted total expected QALYs and Costs per strategy and apply half-cycle correction if applicable ####
  ## QALYs
  v_tot_qaly[i] <- t(v_qaly_str) %*% (v_dwe * v_wcc)
  ## Costs
  v_tot_cost[i] <- t(v_cost_str) %*% (v_dwc * v_wcc)
}
```

## 07.3 Compute ICERs of the Markov model

```{r}
# Calculate incremental cost-effectiveness ratios (ICERs)
df_cea <- calculate_icers(cost       = v_tot_cost, 
                          effect     = v_tot_qaly,
                          strategies = v_names_str)
df_cea
```

## 07.4 CEA results

```{r}
# Create CEA table in proper format
table_cea <- format_table_cea(df_cea)
table_cea
```

## 07.5 Plot frontier of the Markov model

```{r Sick-Sicker-CEA, fig.cap='Cost-effectiveness efficient frontier for the state-residence time dependent Sick-Sicker model.', message=FALSE, warning=FALSE, fig.pos="H"}
plot(df_cea, label = "all") +
     expand_limits(x = max(table_cea$QALYs) + 0.3, 
                   y = 250000) 
```
