---
title: 'Survival Analysis - 3-state model'
author: "The DARTH workgroup"
output:
  pdf_document: default
  html_document: default
---

Developed by the Decision Analysis in R for Technologies in Health (DARTH) workgroup:

Fernando Alarid-Escudero, PhD 
Eva A. Enns, MS, PhD 
M.G. Myriam Hunink, MD, PhD 
Hawre J. Jalal, MD, PhD 
Eline M. Krijkamp, PhD
Petros Pechlivanoglou, PhD 
Alan Yang, MSc 

\newpage

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval = TRUE)
rm(list = ls())     # clear memory (removes all the variables from the workspace)
options(scipen = 999) # disable scientific notation
```

Change `eval` to `TRUE` if you want to knit this document.

# 01 Load packages

```{r, warning = F, message = F}
if (!require('pacman')) install.packages('pacman'); library(pacman) # use this package to conveniently install other packages
# load (install if required) packages from CRAN
p_load("here", "dplyr", "devtools", "gems", "flexsurv", "flexsurvcure", "survHE", "survminer", "ggplot2", "msm", "igraph", "mstate", "reshape2", "knitr", "dampack", "data.table", "tm", "ggsurvfit")  

# load (install if required) packages from GitHub
install_github("DARTH-git/darthtools", force = TRUE) #Uncomment if there is a newer version
library(darthtools)
p_load_gh("DARTH-git/darthtools")
```

# 02 Load functions

```{r}
# No function needed
```

# 03 Input model parameters

```{r}
set.seed(1)            # set the seed  
#PP in the markov model is is H or Healthy?
v_names_states <- c("H", "S", "D")   # the model states names, Healthy (H), Sick (S) and Dead

# Model structure 
n_cycles      <- 30      # time horizon, 30 cycles
cycle_length  <- 1       # cycle length, 1 year

d_c      <- 0.030        # discount rate of 3.0% per cycle for costs
d_e      <- 0.015        # discount rate of 1.5% per cycle for effects

r_SD      <- 0.1         # annual rate of dying when sick
p_SD      <- rate_to_prob(r = r_SD, t = cycle_length) # probability of dying when sick


# initial cohort distribution (everyone allocated to the "H" state)
v_init <- c("H" = 1,
            "S" = 0,
            "D"  = 0)  

# Cost inputs
c_H    <- 400   # cost of one cycle in the healthy state
c_S    <- 1000  # cost of one cycle in the sick state
c_D    <- 0     # cost of one cycle in the dead state
c_trtA <- 800   # cost of treatment A (per year) in healthy state
c_trtB <- 1500  # cost of treatment B (per year) in healthy state

# Utility inputs
u_H   <- 1        # utility when healthy 
u_S   <- 0.5      # utility when sick 
u_D   <- 0        # utility when dead

v_dwe        <- 1 / ((1 + d_e) ^ (0:n_cycles))  # discount weight 
v_dwc        <- 1 / ((1 + d_c) ^ (0:n_cycles))  # discount weight 

n_states    <- length(v_names_states)        # the number of health states
v_names_str <- c("Standard of Care",         # store the strategy names
                     "Treatment A", 
                     "Treatment B")  

v_times         <- seq(0, n_cycles, cycle_length) # the cycles in years
v_names_cycles  <- paste("cycle", 0:n_cycles)     # cycle names
```

Survival analysis component

```{r}
# Load the 3 state data, structure is a list
l_data_survival <- readRDS("Data_Survival_3state.RDS")

data_HS <- l_data_survival$data_HS # Subtract the data for the transition from H to S
head(data_HS) # patient ID, transition, time and status (1 = event, 0 = censored)

data_HD  <- l_data_survival$data_HD  # Subtract the data for the transition from H to D
head(data_HD) # patient ID, transition, time and status (1 = event, 0 = censored)

# Fit independent models for each transition and pick one that fits best
# We use the survfit function from the survival package
# This function always requires the Surv function to created survival objects
# The time and status indicate the data, ~1 means that we don't have any covariates.
fitkm_HS <- survfit(Surv(time, status) ~ 1, data = data_HS) # estimate Kaplan Meier curve
summary(fitkm_HS, t = v_times) # Summarize the fitted curve 
plot(fitkm_HS) # plot the curve 
```


### Extra material - Nice plotting KM curves
```{r}
# Healthy to Sick 
survfit2(Surv(time, status) ~ 1, data = data_HS) %>%
    ggsurvfit() +
     add_censor_mark() +
     add_confidence_interval() +
     add_quantile() +
     add_risktable() +
     scale_ggsurvfit()

# Healthy do dead 
survfit2(Surv(time, status) ~ 1, data = data_HD) %>%
    ggsurvfit() +
     add_censor_mark() +
     add_confidence_interval() +
     add_quantile() +
     add_risktable() +
     scale_ggsurvfit()

```

## Paramatric modeling 
```{r}
# fit parametric models using flexsurv, we choose a weibull function
fitflex_HS <- flexsurvreg(Surv(time, status)~1, data = data_HS , dist = "weibull")
fitflex_HS # print the model parameters 
summary(fitflex_HS, t = v_times) # summarize the survival 
plot(fitflex_HS) # plot the survival curve, # default is that the parametric estimated curve is plotted as well as the observed KM curve

# If we now like to extrapolate the data, we can use the parametric survival function to do so
plot(fitflex_HS, t = 0:30, xlim = c(0,30))

# flexsurvreg: estimates the curves 
# we did the demonstration using weibull only, but like to fit many different distributions
# however, we do not want to write the same code over and over again
# fit.models: is a wrapper to run the function many times. 

# create a vector of the distributions we want to fit
# sort alphabetically 
v_survival_distribution <- sort(c("exponential", "gamma", "weibull", "log-Normal", "log-Logistic", "Gompertz")) # 

fitsurvHE_HS <- fit.models(Surv(time, status) ~ 1, data = data_HS, distr = v_distribution ) # all values 
plot(fitsurvHE_HS) # plot the models

# Get the AIC and BIC values 
# Create an overview 
v_AIC_HS <- fitsurvHE_HS$model.fitting$aic
v_BIC_HS <- fitsurvHE_HS$model.fitting$bic
names(v_AIC_HS) <- names(v_BIC_HS) <- v_distribution
l_fit_HS <- list (AIC = v_AIC_HS, 
                  BIC = v_BIC_HS)

# Select the best fitted model based on the lowest AIC
best_HS <- fitsurvHE_HS$models$`log-Logistic` # select the best model
  
# Do the same now for the HD data
fitsurvHE_HD <- fit.models(Surv(time, status) ~ 1, data = data_HD, distr = v_distribution ) # all values 
plot(fitsurvHE_HD) # plot the models

# Get the AIC and BIC values 
# Create an overview 
v_AIC_HD <- fitsurvHE_HD$model.fitting$aic
v_BIC_HD <- fitsurvHE_HD$model.fitting$bic
names(v_AIC_HD) <- names(v_BIC_HD) <- v_distribution
l_fit_HD <- list (AIC = v_AIC_HD, 
                  BIC = v_BIC_HD)

  
best_HD <- fitsurvHE_HD$models$Exponential # select the best model
    
```




### Extra material
The following code chunk does the same as what we did before, but using the fit.fun from the `dampack`darthtools` package. Depending on your personal preferences and what you want to achieve with your model you can use either one. 

```{r}
# Fit the model for both of the transitions 
fit_HS  <- fit.fun(time = "time", status = "status", data = data_HS, times = v_times)
fit_HD  <- fit.fun(time = "time", status = "status", data = data_HD,times = v_times)

plot(fit_HS$model.objects)

# Find the best-fitting models based on AIC
fit_HS$AIC
fit_HD$AIC
best_HS  <- fit_HS$model.objects$models$`log-Logistic`
best_HD  <- fit_HD$model.objects$models$Exponential
```

# 03.2 Calculate transition probabilities
For the best fitting survival models we calculate  the transition probabilities. We do this using the `trans_prob` function from the `darthtools` package.

```{r}
# First display the survival probabilities for the best fitting model
surv_prob(best_HS, times = v_times) # survival probabilities for the best fitting model
surv_prob(best_HD, times = v_times) # survival probabilities for the best fitting model
# if you would like to adjust for the time , create a new vector or times based on the new cycle length 

# Next, use this survival probabilities to estimate the transition probability (assuming still all annual) using the trans_prob function from darthtools
v_p_HS    <- trans_prob(surv_prob(best_HS, times = v_times)) 
v_p_HD    <- trans_prob(surv_prob(best_HD,  times = v_times))

```

# 04 Define and initialize matrices and vectors

## 04.1 Cohort trace

```{r}
# create the cohort trace
m_M <- matrix(NA, 
              nrow = n_cycles + 1 ,  # create Markov trace (n_t + 1 because R doesn't 
                                # understand cycle 0)
              ncol = n_states, 
              dimnames = list(0:n_cycles, v_names_states))

m_M[1, ] <- v_init  # initialize first cycle of Markov trace
```

## 04.2 Transition probability array

```{r}
# create the transition probability array
a_P <- array(0,                                      # Create 3-D array
             dim = c(n_states, n_states, n_cycles),
             dimnames = list(v_names_states, v_names_states, 0:(n_cycles - 1))) # name the dimensions of the array 
```

Fill in the transition probability array:

```{r}
# from Healthy
a_P["H", "H", ] <- (1 - v_p_HD) * (1 - v_p_HS)
a_P["H", "S", ] <- (1 - v_p_HD) * v_p_HS
a_P["H", "D", ] <-  v_p_HD

# from Sick
a_P["S", "S", ] <- 1 - p_SD
a_P["S", "D", ] <- p_SD

# from Dead
a_P["D", "D", ]   <- 1
```

## 04.3 Check if transition array and probabilities are valid

```{r}
# Check that transition probabilities are in [0, 1]
check_transition_probability(a_P, verbose = TRUE)
# Check that all rows sum to 1
check_sum_of_transition_array(a_P, n_rows = n_states, n_cycles = n_cycles, verbose = TRUE)
```

# 05 Run Markov model

```{r}
for (t in 1:n_cycles){ # t<-1                   # loop through the number of cycles
  m_M[t + 1, ] <- m_M[t, ] %*% a_P[, , t]  # estimate the Markov trace for cycle t + 1 
                                           # using the t-th matrix from the 
                                           # probability array 
}
head(m_M)  # print the first lines of the matrix 
matplot(m_M, type ='l')
```

# 07 Compute Cost-Effectiveness Outcomes

```{r}
# Vectors with costs and utilities by treatment
v_u_SoC <- v_u_trtA <- v_u_trtB <- c(H = c_H, 
                                     S = c_S,         
                                     D = c_D)
v_c_Soc   <- c(H  = c_H, 
               S  = c_S, 
               D  = c_D) 


v_c_trtA   <- c(H  = c_H + c_trtA, 
                S  = c_S, 
                D  = c_D) 

v_c_trtB   <- c(H  = c_H + c_trtB, 
                S  = c_S, 
                D  = c_D) 

```

## 07.1 Mean Costs and QALYs for Treatment and No Treatment

```{r}
v_tu_SoC  <- m_M   %*%  v_u_SoC
v_tu_trtA <- m_M   %*%  v_u_trtA
v_tu_trtB <- m_M   %*%  v_u_trtB

v_tc_SoC  <- m_M   %*%  v_c_Soc 
v_tc_trtA <- m_M   %*%  v_c_trtA
v_tc_trtB <- m_M   %*%  v_c_trtB

```

## 07.2 Discounted Mean Costs and QALYs

```{r}
tu_d_SoC  <- t(v_tu_SoC)  %*%  v_dwe 
tu_d_trtA <- t(v_tu_trtA) %*%  v_dwe
tu_d_trtB <- t(v_tu_trtB) %*%  v_dwe

tc_d_SoC  <- t(v_tc_SoC)  %*%  v_dwc
tc_d_trtA <- t(v_tc_trtA) %*%  v_dwc
tc_d_trtB <- t(v_tc_trtB) %*%  v_dwc

# store them into a vector
v_tc_d      <- c(tc_d_SoC, tc_d_trtA, tc_d_trtB)
v_tu_d      <- c(tu_d_SoC, tu_d_trtA, tc_d_trtB)

# Dataframe with discounted costs and effectiveness
df_ce       <- data.frame(Strategy = v_names_str,
                          Cost     = v_tc_d,
                          Effect   = v_tu_d
                          )
df_ce
```

## 07.3 Compute ICERs of the Markov model

```{r}
df_cea <- calculate_icers(cost       = df_ce$Cost,
                          effect     = df_ce$Effect,
                          strategies = df_ce$Strategy
                          )
df_cea
```

## 07.4 Plot frontier of the Markov model

```{r}
plot(df_cea, effect_units = "QALYs")
```



# Acknowlegdement

For this work we made use of the template developed by the Decision Analysis in R for Technologies in Health (DARTH) workgroup: <http://darthworkgroup.com>.

The notation of our code is based on the following provided framework and coding convention: Alarid-Escudero, F., Krijkamp, E., Pechlivanoglou, P. et al. A Need for Change! A Coding Framework for Improving Transparency in Decision Modeling. PharmacoEconomics 37, 1329–1339 (2019). <https://doi.org/10.1007/s40273-019-00837-x>.

- Alarid-Escudero F, Krijkamp EM, Enns EA, Yang A, Hunink MGM Pechlivanoglou P,
Jalal H. An Introductory Tutorial on Cohort State-Transition Models in R Using a 
Cost-Effectiveness Analysis Example. Medical Decision Making, 2023; 43(1).
(Epub). <https://doi.org/10.1177/0272989X221103163>

- Alarid-Escudero F, Krijkamp EM, Enns EA, Yang A, Hunink MGM Pechlivanoglou P,
Jalal H. A Tutorial on Time-Dependent Cohort State-Transition Models in R using 
a Cost-Effectiveness Analysis Example. Medical Decision Making, 2023; 43(1). 
<https://doi.org/10.1177/0272989X221121747>


Other work from DARTH can be found on the website: <http://darthworkgroup.com/publications/>

# Copyright for assignment work

Copyright 2017, THE HOSPITAL FOR SICK CHILDREN AND THE COLLABORATING INSTITUTIONS.All rights reserved in Canada, the United States and worldwide. Copyright, trademarks, trade names and any and all associated intellectual property are exclusively owned by THE HOSPITAL FOR Sick CHILDREN and the collaborating  institutions. These materials may be used, reproduced, modified, distributed and adapted with proper attribution.


