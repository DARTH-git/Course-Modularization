---
title: 'Survival Analysis - Sick-Sicker model'
author: "The DARTH workgroup"
output:
  pdf_document: default
  html_document: default
---

Developed by the Decision Analysis in R for Technologies in Health (DARTH) workgroup:

Fernando Alarid-Escudero, PhD (1) 

Eva A. Enns, MS, PhD (2)	

M.G. Myriam Hunink, MD, PhD (3,4)

Hawre J. Jalal, MD, PhD (5) 

Eline M. Krijkamp, MSc (3)	

Petros Pechlivanoglou, PhD (6)

Alan Yang, MSc (7)

In collaboration of: 		

1. Drug Policy Program, Center for Research and Teaching in Economics (CIDE) - CONACyT, 
   Aguascalientes, Mexico
2. University of Minnesota School of Public Health, Minneapolis, MN, USA
3. Erasmus MC, Rotterdam, The Netherlands
4. Harvard T.H. Chan School of Public Health, Boston, USA
5. University of Pittsburgh Graduate School of Public Health, Pittsburgh, PA, USA
6. The Hospital for Sick Children, Toronto and University of Toronto, Toronto ON, Canada
7. The Hospital for Sick Children, Toronto ON, Canada

Please cite our publications when using this code:
 
- Jalal H, Pechlivanoglou P, Krijkamp E, Alarid-Escudero F, Enns E, Hunink MG. 
An Overview of R in Health Decision Sciences. Med Decis Making. 2017; 37(3): 735-746. 
https://journals.sagepub.com/doi/abs/10.1177/0272989X16686559
 
- Krijkamp EM, Alarid-Escudero F, Enns EA, Jalal HJ, Hunink MGM, Pechlivanoglou P. 
Microsimulation modeling for health decision sciences using R: A tutorial. 
Med Decis Making. 2018;38(3):400â€“22. 
https://journals.sagepub.com/doi/abs/10.1177/0272989X18754513
 
- Krijkamp EM, Alarid-Escudero F, Enns E, Pechlivanoglou P, Hunink MM, Jalal H. A Multidimensional Array Representation of State-Transition Model Dynamics. Med Decis Mak. 2020;40(2):242-248. doi:10.1177/0272989X19893973

Copyright 2017, THE HOSPITAL FOR SICK CHILDREN AND THE COLLABORATING INSTITUTIONS. 
All rights reserved in Canada, the United States and worldwide. Copyright, 
trademarks, trade names and any and all associated intellectual property are 
exclusively owned by THE HOSPITAL FOR Sick CHILDREN and the collaborating 
institutions. These materials may be used, reproduced, modified, distributed 
and adapted with proper attribution.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval = TRUE)
rm(list = ls())     # clear memory (removes all the variables from the workspace)
options(scipen=999) # disable scientific notation
```

Change `eval` to `TRUE` if you want to knit this document.

# Blog post

The choice of a cycle length in decision-analytic models such as cohort state-transition models and individual-based state transition models (microsimulation models) should be determined by the frequency of clinical events and interventions. Sometimes there is need or decrease the cycle length in a decision model to reduce error in outcomes resulting from discretization of the underlying continuous-time processes or to increase the cycle length to gain computational efficiency. Other times there is a need to change cycle lengths when the frequency of clinical events,  intervention administration, and cost and utility accruals change after some time since model start. Cycle length conversion is also frequently required if a new decision model is built using data that have a different measurement interval than the model's cycle length.

We present a method for building a microsimulation model with variable cycle lengths along its time horizon and illustrate it through a cost-effectiveness analysis example using a modification of the "Sick-Sicker" decision model. In this example, individuals move through four health states: "Healthy", "Sick", "Sicker" and "Dead" and accrue costs and utilities over time. The model begins with a cycle length of one week. However, we wish to model individuals transitioning between "non-dead" states in weekly cycles for the first 10 years of uninterupted residence in any of the "non-dead" states. Once individuals have remained in any of the "non-dead" states for 10 years, they will be asssumed to transition in yearly cycles going forward. We assume that we 

To implement the aforementioned model structure and cycle length switch, we first estimate weekly and yearly transition probabilities through parametric survival and multi-state models. Then, we convert yearly costs and utilities to weekly costs and calculate "weekly" utilities. The model begins with individuals transitioning between health states in weekly cycles within a for-loop. In parallel, the number of weeks each individual has spent in each state is stored in a "tracker matrix". The weekly-cycle for-loop runs for 1560 weeks, which is 30 years in weeks since each of the three "non-dead" states can allow an individual to stay for a maximum of 10 years before they switch to yearly cycles.For example an individual  could stay 7 years in the Healthy state, 3 years in the Sick state and 3 years in the Sicker state.....  At each weekly cycle, only individuals who are not dead or have not yet spent 10 years in a "non-dead" state can make a transition. After the loop ends, we obtain the current state each individual is in and also the number of weeks they have spent in that state and convert them into years. Each individual then starts off at their last state and the corresponding year in another for-loop and move in yearly cycles until the end of the time horizon. Finally, weekly and yearly costs and utilities of all individuals are properly discounted and averaged to calculate final outcomes. 

The model can be extended to have different maximum number of cycles before switching for different "non-dead" states (e.g. 10 years for "Healthy", and 5 years for "Sick" and "Sicker") or have additional for-loops that can accommodate more cycle length switches. The coding structure and implementation are similar.

This example is implemented in R and the R code is available for download. 

\newpage

# 01 Load packages

```{r, warning=F, message=F}
if (!require('pacman')) install.packages('pacman'); library(pacman) # use this package to conveniently install other packages
# load (install if required) packages from CRAN
p_load("here", "dplyr", "devtools", "gems", "flexsurv", "flexsurvcure", "survHE", "ggplot2", "msm", "igraph", "mstate", "reshape2", "knitr", "abind", "DES", "survminer", "dampack", "data.table", "tm")  

# load (install if required) packages from GitHub
# install_github("DARTH-git/darthtools", force = TRUE) Uncomment if there is a newer version
p_load_gh("DARTH-git/darthtools")
```

# 02 Load functions

```{r}
# No function needed
```

# 03 Input model parameters

```{r}
# Model structure
v_names_states <- c("H", "S1", "S2", "D")                       # the model states names
n_states       <- length(v_names_states)                        # the number of health states
n_i            <- 10000                                         # number of simulated individuals
n_t_yr         <- 100                                           # time horizon, 30 cycles
c_l            <- 1/52                                          # cycle length (weekly)
times          <- seq(from = 0, to = n_t_yr, by = c_l)          # sequence of cycle days to be considered in the model 
c_l_yr         <- 1                                             # cycle length (annual)
times_yr       <- seq(from = 0, to = n_t_yr, by = c_l_yr)       # sequence of cycle years to be considered in the model 
n_t            <- length(times)-1                               # time horizon in weeks
d_r            <- 0.03  * c_l                                   # discount rate of 3% per year, weekly rate
v_dw           <- 1 / (1 + d_r) ^ (times[-length(times)])       # calculate discount weights for each week based on discount rate 
d_r_yr         <- 0.03                                          # discount rate per year
v_dw_yr        <- 1 / (1 + d_r) ^ (times_yr[-length(times_yr)]) # calculate discount weights for each year based on
v_names_str    <- c("no treatment", "treatment")                # strategy names

# Event probabilities (per cycle)
# Annual transition probabilities
p_HS1 <- 0.15  # probability of becoming sick when healthy

# Annual probabilities of death
# load age dependent probability
# or use "../data/" if you have a datafolder
p_mort   <- read.csv("mortProb_age.csv")                
# load age distribution
dist_Age <- read.csv("MyPopulation-AgeDistribution.csv") 

# Cost inputs 
# Weekly
c_H      <- 2000  * c_l  # cost of one cycle in the healthy state
c_S1     <- 4000  * c_l  # cost of one cycle in the sick state
c_S2     <- 15000 * c_l  # cost of one cycle in the sicker state
c_D      <- 0     * c_l  # cost of one cycle in the dead state
c_Trt    <- 12000 * c_l  # cost of treatment (per cycle)
# Annual
c_H_yr   <- 2000         # cost of one cycle in the healthy state
c_S1_yr  <- 4000         # cost of one cycle in the sick state
c_S2_yr  <- 15000        # cost of one cycle in the sicker state
c_D_yr   <- 0            # cost of one cycle in the dead state
c_Trt_yr <- 12000        # cost of treatment (per cycle)

# Utility inputs
# Weekly
u_H      <- 1     * c_l  # utility when healthy 
u_S1     <- 0.75  * c_l  # utility when sick 
u_S2     <- 0.5   * c_l  # utility when sicker
u_D      <- 0     * c_l  # utility when dead
u_Trt    <- 0.95  * c_l  # utility when sick(er) and being treated
# Annual
u_H_yr   <- 1            # utility when healthy 
u_S1_yr  <- 0.75         # utility when sick 
u_S2_yr  <- 0.5          # utility when sicker
u_D_yr   <- 0            # utility when dead
u_Trt_yr <- 0.95         # utility when sick(er) and being treated
```

# 04 Sample individual level characteristicS

## 04.1 Static characteristics

```{r}
set.seed(2019)    # set the seed for the simulation of individual characteristics
n_i      <- 10000
v_x      <- runif(n_i, min = 0.95, max = 1.05) # treatment effect modifier at baseline  

# sample from age distribution an initial age for every individual
v_age0   <- sample(x = dist_Age$age, prob = dist_Age$prop, size = n_i, replace = TRUE)

# store the information at baseline into a data frame.
df_X     <- data.frame(ID = 1:n_i, x = v_x, Age = v_age0)
```

Survival analysis component

```{r}
# load the Sicker data 
data_long <- read.csv("data_long_Sicker.csv", row.names = 1)
head(data_long)

# Multi-state models can be fitted independently for each transition. This is more flexible!

# Create subsets for each transition
data_S1H  <- subset(data_long, trans == 1)
data_S1S2 <- subset(data_long, trans == 2)
data_S1D  <- subset(data_long, trans == 3)
data_S2D  <- subset(data_long, trans == 4)

# fit independent models for each transition and pick the one with the lowest AIC
fit_S1H   <- fit.fun(time = "time", status = "status", data = data_S1H, times = times, 
                     extrapolate = T)
fit_S1S2  <- fit.fun(time = "time", status = "status", data = data_S1S2, times = times, 
                     extrapolate = T)
fit_S1D   <- fit.fun(time = "time", status = "status", data = data_S1D, times = times, 
                     extrapolate = T)
fit_S2D   <- fit.fun(time = "time", status = "status", data = data_S2D, times = times, 
                     extrapolate = T)

best.fit_S1H  <- fit_S1H$model.objects$models[["Royston-Parmar"]]
best.fit_S1S2 <- fit_S1S2$model.objects$models[["log-Logistic"]]
best.fit_S1D  <- fit_S1D$model.objects$models[["Exponential"]]
best.fit_S2D  <- fit_S2D$model.objects$models[["Weibull (AFT)"]]

# Extract transition probabilities from the best fitting models
# Weekly
p_S1H     <- trans_prob(surv_prob(best.fit_S1H,  times = times))
p_S1S2    <- trans_prob(surv_prob(best.fit_S1S2, times = times))
p_S1D     <- trans_prob(surv_prob(best.fit_S1D,  times = times))
p_S2D     <- trans_prob(surv_prob(best.fit_S2D,  times = times))
# Annual
p_S1H_yr  <- trans_prob(surv_prob(best.fit_S1H,  times = times_yr))
p_S1S2_yr <- trans_prob(surv_prob(best.fit_S1S2, times = times_yr))
p_S1D_yr  <- trans_prob(surv_prob(best.fit_S1D,  times = times_yr))
p_S2D_yr  <- trans_prob(surv_prob(best.fit_S2D,  times = times_yr))
```

## 04.2 Dynamic characteristics 

```{r}
# Specify the initial health state of the individuals 
# everyone begins in the healthy state (in this example)
v_M_init   <- rep("H", n_i)  # a vector with the initial health state for all individuals 
v_Ts1_init <- rep(0, n_i)    # a vector with the time of being sick at the start of the model 
v_Ts2_init <- rep(0, n_i)    # a vector with the time of being sick at the start of the model   
```

# 05 Define Simulation Functions

## 05.1 Probability function

The function that updates the transition probabilities of every cycle is shown below.

```{r}
Probs <- function(M_t, df_X, v_Ts1, v_Ts2, t, n_i, yearly = FALSE) { 
  # Arguments:
    # M_t   : health state occupied at cycle t (character variable)
    # df_X  : individual characteristics including Age, Sex and the effect modifier of the treatment effect
    # v_Ts1 : time an individual is sick
    # v_Ts2 : time an individual is sicker
    # t     : current cycle 
    # n_i   : number of individuals
    # yearly: whether the cycle is annual 
  # Returns: 
    # transition probabilities for that cycle
  
  # Determine weekly or yearly
  if (yearly) {
    p_S1H  <- p_S1H_yr
    p_S1S2 <- p_S1S2_yr
    p_S1D  <- p_S1D_yr
    p_S2D  <- p_S2D_yr
  }
  
  # create matrix of state transition probability vectors
  m_p_t           <- matrix(0, nrow = n_states, ncol = n_i) 
  rownames(m_p_t) <-  v_names_states  # give the state names to the rows
  
  # lookup baseline probability and rate of dying based on individual characteristics
  p_HD_all <- inner_join(df_X, p_mort, by = c("Age"))
  p_HD     <- p_HD_all[M_t == "H", "p_HD"]
  
  # update the v_p with the appropriate probabilities   
  # transition probabilities when healthy
  m_p_t["H",  M_t == "H"]  <- (1 - p_HD) * (1 - p_HS1) 
  m_p_t["S1", M_t == "H"]  <- (1 - p_HD) *      p_HS1  
  m_p_t["S2", M_t == "H"]  <-                       0
  m_p_t["D",  M_t == "H"]  <-      p_HD                  
  
  # transition probabilities when sick
  m_p_t["H",  M_t == "S1"] <- (1 - p_S1D[v_Ts1]) *      p_S1H[v_Ts1]
  m_p_t["S1", M_t == "S1"] <- (1 - p_S1D[v_Ts1]) * (1 - p_S1H[v_Ts1] - p_S1S2[v_Ts1])   
  m_p_t["S2", M_t == "S1"] <- (1 - p_S1D[v_Ts1]) *                     p_S1S2[v_Ts1]
  m_p_t["D",  M_t == "S1"] <-      p_S1D[v_Ts1]
  
  # transition probabilities when sicker
  m_p_t["H",  M_t == "S2"] <-  0   
  m_p_t["S1", M_t == "S2"] <-  0
  m_p_t["S2", M_t == "S2"] <-  1 - p_S2D[v_Ts2]
  m_p_t["D",  M_t == "S2"] <-      p_S2D[v_Ts2]
  
  # transition probabilities when dead  
  m_p_t["H",  M_t == "D"]  <-  0   
  m_p_t["S1", M_t == "D"]  <-  0
  m_p_t["S2", M_t == "D"]  <-  0
  m_p_t["D",  M_t == "D"]  <-  1
  
  return(t(m_p_t))
}       
```

## 05.2 Cost function

The `Costs` function estimates the costs at every cycle.

```{r}
Costs <- function (M_t, Trt = FALSE, yearly = FALSE) {
  # M_t   : health state occupied by individual i at cycle t (character variable)
  # Trt   : is the individual being treated? (default is FALSE) 
  # yearly: whether the cycle is annual
  
  # determine weekly or yearly
  if (yearly) {
    c_H   <- c_H_yr
    c_S1  <- c_S1_yr
    c_S2  <- c_S2_yr
    c_D   <- c_D_yr
    c_Trt <- c_Trt_yr
  }
  
  c_t <- 0                                 # create the cost variable 
  c_t[M_t == "H"]  <- c_H                  # update the cost if healthy
  c_t[M_t == "S1"] <- c_S1 + c_Trt * Trt   # update the cost if sick conditional 
                                           # on treatment
  c_t[M_t == "S2"] <- c_S2 + c_Trt * Trt   # update the cost if sicker conditional 
                                           # on treatment
  c_t[M_t == "D"]  <- c_D                  # update the cost if dead
  
  return(c_t)        		                   # return the costs
}
```

## 05.3 Health outcome function

The `Effs` function to update the utilities at every cycle.

```{r}
Effs <- function (M_t, df_X, Trt = FALSE, cl = 1, yearly = FALSE) {
  # M_it  : health state occupied by individual i at cycle t (character variable)
  # df_X  : individual characteristics including Age, Sex and the effect modifier of the treatment effect
  # Trt   : is the individual treated? (default is FALSE) 
  # cl    : cycle length (default is 1)
  # yearly: whether the cycle is annual
  
  # determine weekly or yearly
  if (yearly) {
    u_H   <- u_H_yr
    u_S1  <- u_S1_yr
    u_S2  <- u_S2_yr
    u_D   <- u_D_yr
    u_Trt <- u_Trt_yr
  }
  
  u_t <- 0                                 # by default the utility for everyone is zero
  u_t[M_t == "H"]  <- u_H                  # update the utility if healthy
  u_t[M_t == "S1" & Trt == FALSE] <- u_S1  # update the utility if sick
  # update the utility if sick but on treatment (adjust for individual effect modifier) 
  u_t[M_t == "S1" & Trt == TRUE]  <- u_Trt * df_X$x[M_t == "S1"]   
  u_t[M_t == "S2"] <- u_S2                 # update the utility if sicker
  u_t[M_t == "D"]  <- u_D                  # update the utility if dead
  
  return(u_t)                              # return the QALYs accrued this cycle
}
```

# 06 Run Microsimulation

```{r}
max_cycle <- 10 / c_l                  # max cycle (individual can only stay in any state other than the dead state for   
                                       # this many cycles before moving from weekly to annual cycles) - 10 years in weeks
n_t1 <- (10/c_l) * (n_states - 1)      # max number of weekly cycles one can have before moving to annual cycles
v_M_init  <- rep("H", n_i)             # a vector with the initial health state for all individuals 
v_Ts1_init <- rep(0, n_i)              # a vector with the time in sick at the start of the model 
v_Ts2_init <- rep(0, n_i)              # a vector with the time in sicker at the start of the model 
```

```{r}
MicroSim_v_switch <- function(Trt = FALSE, seed = 1) {
# Arguments:  
  # Trt : is this the individual receiving treatment? (default is FALSE)
  # seed: seed for random number generator
  
  set.seed(seed) # set the seed
  
  # m_M is used to store the health state information over time for every individual
  # m_C is used to store the costs information over time for every individual
  # m_E is used to store the effects information over time for every individual
  m_M <- matrix(nrow = n_i, ncol = n_t1, 
                dimnames = list(paste("individual", 1:n_i,  sep = " "),
                                paste("cycle",      1:n_t1, sep = " "))) 
  m_C <- m_E <- matrix(0, nrow = n_i, ncol = n_t1, 
                       dimnames = list(paste("individual", 1:n_i,  sep = " "),
                                       paste("cycle",      1:n_t1, sep = " ")))  
  
  # initial health state at cycle 0 for individual i
  m_M[, 1] <- v_M_init    # initial health state at cycle 0 for all individuals
  v_Ts1    <- v_Ts1_init   # initialize time since sick for all individuals
  v_Ts2    <- v_Ts2_init   # initialize time since sicker for all individuals
  # calculate costs per individual during cycle 0 (t = 1)
  m_C[, 1] <- Costs(m_M[, 1], Trt = Trt)     
  # calculate QALYs per individual during cycle 0
  m_E[, 1] <- Effs (m_M[, 1], df_X = df_X, Trt = Trt)   
  
  # initialize trackers
  m_track <- matrix(0, nrow = n_i, ncol = n_states, dimnames = list(paste("individual", 1:n_i, sep = " "), 
                                                                    v_names_states))
  m_track[, 1] <- 1
  for (t in 1:(n_t1-1)) {  # loop through max number of weekly cycles 
    # only sample individuals who are not dead or not "full"
    to_allocate <- m_track[, 1] < max_cycle & m_track[, 2] < max_cycle & m_track[, 3] < max_cycle & m_track[, 4] == 0
    # calculate the transition probabilities for the cycle based on health state t
    m_P <- Probs(m_M[to_allocate, t], df_X = df_X[to_allocate, ], t = t, 
                 v_Ts1 = v_Ts1[to_allocate], v_Ts2 = v_Ts2[to_allocate], n_i = sum(to_allocate))       
    # check if transition probabilities are between 0 and 1
    check_transition_probability(m_P, verbose = TRUE)
    # check if checks if each of the rows of the transition probabilities matrix sum to one
    check_sum_of_transition_array(m_P, n_rows = sum(to_allocate), n_cycles = n_t, verbose = TRUE)
    # sample the current health state and store that state in matrix m_M 
    m_M[to_allocate, t + 1] <- samplev(m_P, 1)                 
    # calculate costs per individual during cycle t + 1
    m_C[to_allocate, t + 1] <- Costs(m_M[to_allocate, t + 1], Trt = Trt)         
    # calculate QALYs per individual during cycle t + 1
    m_E[to_allocate, t + 1] <- Effs( m_M[to_allocate, t + 1], df_X = df_X[to_allocate, ], Trt = Trt)  
    # track time in PF, P and D
    m_track[m_M[, t + 1] %in% "H",  1] <- m_track[m_M[, t + 1] %in% "H" , 1] + 1
    m_track[m_M[, t + 1] %in% "S1", 2] <- m_track[m_M[, t + 1] %in% "S1", 2] + 1
    m_track[m_M[, t + 1] %in% "S2", 3] <- m_track[m_M[, t + 1] %in% "S2", 3] + 1
    m_track[m_M[, t + 1] %in% "D",  4] <- m_track[m_M[, t + 1] %in% "D" , 4] + 1
    # track time spent in S1 and S2
    v_Ts1[to_allocate] <- if_else(m_M[to_allocate, t + 1] == "S1", v_Ts1[to_allocate] + 1, 0)
    v_Ts2[to_allocate] <- if_else(m_M[to_allocate, t + 1] == "S2", v_Ts2[to_allocate] + 1, 0)
    # track age
    df_X$Age[!m_M[, t + 1] %in% "D"]  <- floor(df_X$Age[!m_M[, t + 1] %in% "D"] + (1 * c_l))
    
  }  # close the weekly cycles loop
  
  # get everyone's last cycle and state
  # Dataframe to store each individual's last cycle and state
  df_last <- data.frame(ind = 1:n_i)
  # Find out what each person's last cycle is
  df_last$last_cycle <- apply(m_M, 1, function(x){which(is.na(x))[1]-1})
  df_last$last_cycle[is.na(df_last$last_cycle)] <- n_t1   
  # Find out what the corresponding state is
  df_last$last_state <- rep(NA, n_i)
  for (i in 1:n_i) {
    df_last$last_state[i] <- m_M[i, df_last$last_cycle[i]]
  }
  df_last$last_cycle_yr <- round(df_last$last_cycle/52, 0) 

  # only select individuals who are alive
  alive <- df_last$last_state != "D"
  df_last_alive <- df_last[alive,]
  df_X_alive <- df_X[df_X$ID %in% df_last_alive$ind, ]
  
  # m_M_yr is used to store the health state information over time for every individual (yearly)
  # m_C_yr is used to store the costs information over time for every individual (yearly)
  # m_E_yr is used to store the effects information over time for every individual (yearly)
  m_M_yr  <- matrix(nrow = sum(alive), ncol = n_t_yr) 
  m_C_yr  <- m_E_yr <- matrix(0, nrow = sum(alive), ncol = n_t_yr) 
  v_Ts1_yr <- rep(0, sum(alive))   # initialize time since sick for all individuals
  v_Ts1_yr[df_last_alive$last_state == "S1"] <- 1
  v_Ts2_yr <- rep(0, sum(alive))   # initialize time since sicker for all individuals
  v_Ts2_yr[df_last_alive$last_state == "S2"] <- 1
  
  if (sum(alive) > 0) {
  # start everyone from year 10 (minimum) in annual cycle for loop
  in_pool <- rep(0, sum(alive))
  for (t_yr in 10:(n_t_yr-1)) {# switch to annual cycles and go all the way to 101 years
      # initialize start state for those who start at the current cycle
      indi_start <- df_last_alive$last_cycle_yr == t_yr
      m_M_yr[indi_start, t_yr] <- df_last_alive$last_state[indi_start]
      # only sample individuals that start at the current cycle or in the pool
      to_allocate <- indi_start | in_pool > 0
      in_pool <- in_pool + to_allocate
      # calculate the transition probabilities for the cycle based on health state at t_yr
      m_P_yr <- Probs(m_M_yr[to_allocate, t_yr], t = t_yr, df_X = df_X_alive[to_allocate, ],  
                      v_Ts1 = v_Ts1_yr[to_allocate], v_Ts2 = v_Ts2_yr[to_allocate], n_i = sum(to_allocate), 
                      yearly = T)       
      # check if transition probabilities are between 0 and 1
      check_transition_probability(m_P_yr, verbose = TRUE)
      # check if checks if each of the rows of the transition probabilities matrix sum to one
      check_sum_of_transition_array(m_P_yr, n_rows = sum(to_allocate), n_cycles = n_t_yr, verbose = TRUE)
      # sample the current health state and store that state in matrix m_M_yr 
      m_M_yr[to_allocate, t_yr + 1] <- samplev(m_P_yr, 1)
      # calculate costs per individual during cycle t_yr + 1
      m_C_yr[to_allocate, t_yr + 1] <- Costs(m_M_yr[to_allocate, t_yr + 1], Trt, yearly = T)         
      # calculate QALYs per individual during cycle t_yr + 1
      m_E_yr[to_allocate, t_yr + 1] <- Effs( m_M_yr[to_allocate, t_yr + 1], df_X = df_X[to_allocate, ], 
                                             Trt, yearly = T) 
      # track time spent in S1 and S2
      v_Ts1_yr[to_allocate] <- if_else(m_M_yr[to_allocate, t_yr + 1] == "S1", v_Ts1_yr[to_allocate] + 1, 0)
      v_Ts2_yr[to_allocate] <- if_else(m_M_yr[to_allocate, t_yr + 1] == "S2", v_Ts2_yr[to_allocate] + 1, 0)
      # track age
      df_X$Age[!m_M[, t + 1] %in% "D"] <- df_X$Age[!m_M[, t + 1] %in% "D"] + 1
  }  # close the annual cycles loop
  }
  # calculate costs and utilities
  v_dw_wk      <- v_dw[1:n_t1]
  tc_wk        <- m_C    %*% v_dw_wk     # total (discounted) cost per individual (weekly)
  te_wk        <- m_E    %*% v_dw_wk     # total (discounted) QALYs per individual (weekly)
  tc_yr        <- m_C_yr %*% v_dw_yr     # total (discounted) cost per individual (annual)
  te_yr        <- m_E_yr %*% v_dw_yr     # total (discounted) QALYs per individual (annual)
  tc_wk[alive] <- tc_wk[alive] + tc_yr   # total (discounted) cost per individual (weekly + annual)
  te_wk[alive] <- te_wk[alive] + te_yr   # total (discounted) QALYs per individual (weekly + annual)
  tc           <- tc_wk
  te           <- te_wk
  tc_hat       <- mean(tc)               # average (discounted) cost 
  te_hat       <- mean(te)               # average (discounted) QALYs
  
  # store the results from the simulation in a list
  results <- list(m_M = m_M, m_C = m_C, m_E = m_E, m_M_yr = m_M_yr, m_C_yr = m_C_yr, m_E_yr = m_E_yr,
                  tc = tc, te = te, tc_hat = tc_hat, te_hat = te_hat)   
  
  return(results)  # return the results

} # end of the MicroSim function  

# By specifying all the arguments in the `MicroSim()` the simulation can be started
# In this example the outcomes are of the simulation are stored in the variables `outcomes_no_trt` and `outcomes_trt`.
outcomes_no_trt <- MicroSim_v_switch(Trt = FALSE)
outcomes_trt    <- MicroSim_v_switch(Trt = TRUE)
```

# 07 Visualize results

```{r}
# No treatment
plot(density(outcomes_no_trt$tc), main = paste("Total cost per person"), xlab = "Cost ($)")
plot(density(outcomes_no_trt$te), main = paste("Total QALYs per person"), xlab = "QALYs")

# Treatment
plot(density(outcomes_trt$tc), main = paste("Total cost per person"), xlab = "Cost ($)")
plot(density(outcomes_trt$te), main = paste("Total QALYs per person"), xlab = "QALYs")
```

# 08 Cost Effectiveness Analysis

```{r}
# store the mean costs of each strategy in a new variable C (vector of costs)
v_C <- c(outcomes_no_trt$tc_hat, outcomes_trt$tc_hat)
# store the mean QALYs of each strategy in a new variable E (vector of effects)
v_E <- c(outcomes_no_trt$te_hat, outcomes_trt$te_hat)

# use dampack to calculate the ICER
df_cea <- calculate_icers(cost       = v_C,
                          effect     = v_E,
                          strategies = v_names_str)
df_cea
plot(df_cea)
```

